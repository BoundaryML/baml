---
title: class
slug: docs/snippets/class
---


Classes consist of a name, a list of properties, and their [types](supported-types.mdx).
In the context of LLMs, classes describe the type of the variables you can inject into prompts and extract out from the response.

<Warning>
  Note properties have no `:`
</Warning>

<CodeBlocks>
```baml Baml
class Foo {
  property1 string
  property2 int?
  property3 Bar[]
  property4 MyEnum
}
```

```python Python Equivalent
from pydantic import BaseModel
from path.to.bar import Bar
from path.to.my_enum import MyEnum

class Foo(BaseModel):
  property1: str
  property2: Optional[int]= None
  property3: List[Bar]
  property4: MyEnum
```

```typescript Typescript Equivalent
import z from "zod";
import { BarZod } from "./path/to/bar";
import { MyEnumZod } from "./path/to/my_enum";

const FooZod = z.object({
  property1: z.string(),
  property2: z.number().int().nullable().optional(),
  property3: z.array(BarZod),
  property4: MyEnumZod,
});

type Foo = z.infer<typeof FooZod>;
```

</CodeBlocks>

## Class Attributes

<ParamField
  path="@@dynamic"
>
If set, will allow you to add fields to the class dynamically at runtime (in your python/ts/etc code). See [dynamic classes](../calling-baml/dynamic-types.mdx) for more information.
</ParamField>

<ParamField
  path="@@assert"
>
Add class-level assertions using Jinja templates to ensure certain properties. If an assertion fails, a `BAMLValidationError` is raised. See [custom type assertions](../calling-baml/assertions.mdx) for details.


```baml BAML
class MyClass {
  property1 string
  property2 int?

  @@dynamic // allows me to later propert3 float[] at runtime
}
```

## Field Attributes

When prompt engineering, you can also alias values and add descriptions.

<ParamField
  path="@alias"
  type="string"
>
Aliasing renames the field for the llm to potentially "understand" your value better, while keeping the original name in your code, so you don't need to change your downstream code everytime.

This will also be used for parsing the output of the LLM back into the original object.
</ParamField>

<ParamField
  path="@description"
  type="string"
>
This adds some additional context to the field in the prompt.
</ParamField>


```baml BAML
class MyClass {
  property1 string @alias("name") @description("The name of the object")
  age int? @description("The age of the object")
}
```

</ParamField>


### Validation Attributes
Validation attributes are used to enforce constraints on the fields of a class. They do not modify the prompt, but rather the post hoc validation logic of the BAML parser. 

<Warning>
`@assert` and `@check` attributes are mutually exclusive and cannot be applied to the same field.
</Warning>
<ParamField
  path ="@assert"
  type = "jinja"
>
Add field assertions using Jinja templates to ensure specific properties. If the assertion fails, the prompt will fail. Because assertions are evaluated at runtime, `Union` cases must have type-instance-specific assertions. See [custom type assertions](../calling-baml/assertions.mdx) for more information.

```baml BAML
class MyClass {
  property1 string @alias("name") @assert(this|length > 0, "name_not_empty")
  age int? @assert(this > 0, "age_positive")
}
```
</ParamField>

<ParamField
  path ="@check"
  type = "jinja"
>
The `@check` attribute allows you to access data even if an assertion fails. This is useful in scenarios where you want to be informed of a validation failure but still need the data. 

When using `@check`, the field returns a `BamlCheckedValue<T>` object, which includes both the parsed data and the validation results. You can access the actual value through the `value` attribute and the validation results through the `checks_results` attribute. For more details, see [non-exception raising type checks](../calling-baml/assertions.mdx#non-exception-checks).

```baml BAML
class MyClass {
  property1 string @alias("name") @check(this|length > 0, "name_not_empty")
  age int? @check(this > 0, "age_positive")
  hometown string @check(this == "New York", "hometown_new_york")
}
```

</ParamField>





## Constraints

Classes may have any number of properties.
Property names must follow these rules:
- Must start with a letter
- Must contain only letters, numbers, and underscores
- Must be unique within the class
- classes cannot be self-referential (cannot have a property of the same type as the class itself)

The type of a property can be any [supported type](supported-types.mdx)

### Default values

- Not yet supported. For optional properties, the default value is `None` in python.

## Inheritance

Never supported. Like rust, we take the stance that [composition is better than inheritance](https://www.digitalocean.com/community/tutorials/composition-vs-inheritance).

