---
title: "Level 0: The BAML Project Structure"
---

At a high level, you will define your AI prompts/interfaces in BAML files, which will then compile into generated Python (soon TS) code that you can import and use in your codebase.

Here is the typical project structure:

```bash
.
├── baml_client/ # Generated code
├── baml_src/ # Prompts live here
│   ├── __tests__/ # Tests loaded by playground
│   │   ├── YourAIFunction/
│   │   │   ├── test_name_monkey.json
│   │   │   └── test_name_cricket.json
│   │   └── YourAIFunction2/
│   │       └── test_name_jellyfish.json
│   ├── main.baml
│   ├── any_directory/
│   │   ├── bar.baml
│   │   └── baz.baml
│   └── foo.baml
# The rest of your project (not generated / used by BAML)
├── app/
│  ├── __init__.py
│  └── main.py
├── pyproject.toml
└── poetry.lock

```

1. **baml_src** is the directory where you write your BAML files with the AI function declarations, prompts, retry policies, etc. It also contains [generator](/v3/syntax/generator) blocks which configure how and where to transpile your BAML code.
2. **baml_client** is the directory where the generated python or TS client code lives. This is the code that you import into your python or TS program (more on this later)

<Warning>
  **You should never edit any files inside baml_client directory** as the whole
  directory gets regenerated everytime you save a .baml file in VSCode. VScode runs `baml build` under the hood.
</Warning>

<Tip>
  If you ever run into any issues with the generated code (like merge
  conflicts), you can always delete the `baml_client` directory and it will get
  regenerated automatically once you fix any other conflicts in your `.baml`
  files.
</Tip>
