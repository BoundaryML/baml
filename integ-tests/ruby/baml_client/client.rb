###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ bundle add baml sorbet-runtime
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# frozen_string_literal: true
# rubocop: disable
# formatter:off
# typed: false
require "baml"
require "sorbet-runtime"

require_relative "inlined"
require_relative "partial-types"
require_relative "types"
require_relative "type-registry"

module Baml
  @instance = nil

  def self.Client
    if @instance.nil?
      @instance = BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_files("baml_src", Baml::Inlined::FILE_MAP, ENV))
    end
  
    @instance
  end

  class BamlClient
    extend T::Sig

    sig { returns(BamlStreamClient) }
    attr_reader :stream

    sig {params(runtime: Baml::Ffi::BamlRuntime).void}
    def initialize(runtime:)
      @runtime = runtime
      @ctx_manager = runtime.create_context_manager()
      @stream = BamlStreamClient.new(runtime: @runtime, ctx_manager: @ctx_manager)
    end

    sig {params(path: String).returns(BamlClient)}
    def self.from_directory(path)
      BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_directory(path, ENV))
    end

    sig {
      params(
        varargs: T.untyped,
        recipe: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::Recipe)
    }
    def AaaSamOutputFormat(
        *varargs,
        recipe:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AaaSamOutputFormat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AaaSamOutputFormat",
        {
          recipe: recipe,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::InputClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AliasedInputClass(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AliasedInputClass",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::InputClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AliasedInputClass2(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputClass2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AliasedInputClass2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::InputClassNested,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AliasedInputClassNested(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputClassNested may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AliasedInputClassNested",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: T.any(Baml::Types::AliasedEnum, String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AliasedInputEnum(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputEnum may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AliasedInputEnum",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: T::Array[T.any(Baml::Types::AliasedEnum, String)],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AliasedInputList(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AliasedInputList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        aud: Baml::Audio,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AudioInput(
        *varargs,
        aud:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AudioInput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "AudioInput",
        {
          aud: aud,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::DynEnumTwo, String))
    }
    def ClassifyDynEnumTwo(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyDynEnumTwo may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ClassifyDynEnumTwo",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::Category, String))
    }
    def ClassifyMessage(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyMessage may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ClassifyMessage",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::Category, String))
    }
    def ClassifyMessage2(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyMessage2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ClassifyMessage2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::Category, String))
    }
    def ClassifyMessage3(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyMessage3 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ClassifyMessage3",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::BookOrder, Baml::Types::FlightConfirmation, Baml::Types::GroceryReceipt))
    }
    def CustomTask(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("CustomTask may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "CustomTask",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DescribeImage",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage2(
        *varargs,
        classWithImage:,img2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DescribeImage2",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage3(
        *varargs,
        classWithImage:,img2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage3 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DescribeImage3",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage4(
        *varargs,
        classWithImage:,img2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage4 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DescribeImage4",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::OriginalA, Baml::Types::OriginalB))
    }
    def DifferentiateUnions(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DifferentiateUnions may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DifferentiateUnions",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::DummyOutput)
    }
    def DummyOutputFunction(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DummyOutputFunction may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DummyOutputFunction",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::DynamicClassOne,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::DynamicClassTwo)
    }
    def DynamicFunc(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DynamicFunc may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DynamicFunc",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::DynInputOutput,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::DynInputOutput)
    }
    def DynamicInputOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DynamicInputOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DynamicInputOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: T::Array[Baml::Types::DynInputOutput],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::DynInputOutput])
    }
    def DynamicListInputOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DynamicListInputOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "DynamicListInputOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def ExpectFailure(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExpectFailure may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ExpectFailure",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[String])
    }
    def ExtractNames(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractNames may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ExtractNames",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::Person])
    }
    def ExtractPeople(
        *varargs,
        text:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractPeople may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ExtractPeople",
        {
          text: text,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        email: String,reason: T.any(String, String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::ReceiptInfo)
    }
    def ExtractReceiptInfo(
        *varargs,
        email:,reason:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractReceiptInfo may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ExtractReceiptInfo",
        {
          email: email,reason: reason,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        resume: String,img: T.nilable(Baml::Image),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::Resume)
    }
    def ExtractResume(
        *varargs,
        resume:,img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractResume may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ExtractResume",
        {
          resume: resume,img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        resume: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::Resume)
    }
    def ExtractResume2(
        *varargs,
        resume:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractResume2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "ExtractResume2",
        {
          resume: resume,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.nilable(Baml::Types::ClassOptionalOutput))
    }
    def FnClassOptionalOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnClassOptionalOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnClassOptionalOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.nilable(Baml::Types::ClassOptionalOutput2))
    }
    def FnClassOptionalOutput2(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnClassOptionalOutput2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnClassOptionalOutput2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[T.any(Baml::Types::EnumOutput, String)])
    }
    def FnEnumListOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnEnumListOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnEnumListOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::EnumOutput, String))
    }
    def FnEnumOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnEnumOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnEnumOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myString: T.nilable(String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def FnNamedArgsSingleStringOptional(
        *varargs,
        myString:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnNamedArgsSingleStringOptional may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnNamedArgsSingleStringOptional",
        {
          myString: myString,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Boolean)
    }
    def FnOutputBool(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputBool may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnOutputBool",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestOutputClass)
    }
    def FnOutputClass(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnOutputClass",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::TestOutputClass])
    }
    def FnOutputClassList(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClassList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnOutputClassList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestClassNested)
    }
    def FnOutputClassNested(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClassNested may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnOutputClassNested",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestClassWithEnum)
    }
    def FnOutputClassWithEnum(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClassWithEnum may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnOutputClassWithEnum",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[String])
    }
    def FnOutputStringList(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputStringList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnOutputStringList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T.any(Baml::Types::TestEnum, String))
    }
    def FnTestAliasedEnumOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnTestAliasedEnumOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnTestAliasedEnumOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestClassAlias)
    }
    def FnTestClassAlias(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnTestClassAlias may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnTestClassAlias",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: T.any(Baml::Types::NamedArgsSingleEnum, String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def FnTestNamedArgsSingleEnum(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnTestNamedArgsSingleEnum may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "FnTestNamedArgsSingleEnum",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::RaysData)
    }
    def GetDataType(
        *varargs,
        text:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("GetDataType may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "GetDataType",
        {
          text: text,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        email: Baml::Types::Email,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::OrderInfo)
    }
    def GetOrderInfo(
        *varargs,
        email:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("GetOrderInfo may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "GetOrderInfo",
        {
          email: email,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        query: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::SearchParams)
    }
    def GetQuery(
        *varargs,
        query:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("GetQuery may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "GetQuery",
        {
          query: query,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::DynamicOutput)
    }
    def MyFunc(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("MyFunc may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "MyFunc",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)])
    }
    def OptionalTest_Function(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("OptionalTest_Function may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "OptionalTest_Function",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestClaude(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestClaude may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestClaude",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestClaudeChat(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestClaudeChat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestClaudeChat",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestClaudeChatNoSystem(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestClaudeChatNoSystem may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestClaudeChatNoSystem",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestOpenAI(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestOpenAI may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestOpenAI",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestOpenAIChat(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestOpenAIChat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestOpenAIChat",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestOpenAIChatNoSystem(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestOpenAIChatNoSystem may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestOpenAIChatNoSystem",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestStreaming(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestStreaming may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "PromptTestStreaming",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::Schema)
    }
    def SchemaDescriptions(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("SchemaDescriptions may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "SchemaDescriptions",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::BigNumbers)
    }
    def StreamBigNumbers(
        *varargs,
        digits:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamBigNumbers may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "StreamBigNumbers",
        {
          digits: digits,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Integer)
    }
    def StreamOneBigNumber(
        *varargs,
        digits:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamOneBigNumber may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "StreamOneBigNumber",
        {
          digits: digits,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Array[T.any(Integer, String)])
    }
    def StreamUnionIntegers(
        *varargs,
        digits:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamUnionIntegers may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "StreamUnionIntegers",
        {
          digits: digits,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,yapping: T::Boolean,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::CompoundBigNumbers)
    }
    def StreamingCompoundNumbers(
        *varargs,
        digits:,yapping:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamingCompoundNumbers may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "StreamingCompoundNumbers",
        {
          digits: digits,yapping: yapping,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAnthropic(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAnthropic may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestAnthropic",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAnthropicShorthand(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAnthropicShorthand may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestAnthropicShorthand",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAws(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAws may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestAws",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAzure(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAzure may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestAzure",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestCaching(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestCaching may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestCaching",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFallbackClient(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFallbackClient may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFallbackClient",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFallbackToShorthand(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFallbackToShorthand may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFallbackToShorthand",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myBool: T::Boolean,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleBool(
        *varargs,
        myBool:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleBool may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleBool",
        {
          myBool: myBool,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleClass(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleClass",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: T::Array[T.any(Baml::Types::NamedArgsSingleEnumList, String)],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleEnumList(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleEnumList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleEnumList",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myFloat: Float,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleFloat(
        *varargs,
        myFloat:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleFloat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleFloat",
        {
          myFloat: myFloat,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myInt: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleInt(
        *varargs,
        myInt:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleInt may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleInt",
        {
          myInt: myInt,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myMap: T::Hash[String, Baml::Types::StringToClassEntry],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Hash[String, Baml::Types::StringToClassEntry])
    }
    def TestFnNamedArgsSingleMapStringToClass(
        *varargs,
        myMap:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleMapStringToClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleMapStringToClass",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myMap: T::Hash[String, T::Hash[String, String]],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Hash[String, T::Hash[String, String]])
    }
    def TestFnNamedArgsSingleMapStringToMap(
        *varargs,
        myMap:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleMapStringToMap may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleMapStringToMap",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myMap: T::Hash[String, String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(T::Hash[String, String])
    }
    def TestFnNamedArgsSingleMapStringToString(
        *varargs,
        myMap:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleMapStringToString may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleMapStringToString",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myString: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleString(
        *varargs,
        myString:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleString may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleString",
        {
          myString: myString,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myStringArray: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleStringArray(
        *varargs,
        myStringArray:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleStringArray may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleStringArray",
        {
          myStringArray: myStringArray,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleStringList(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleStringList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestFnNamedArgsSingleStringList",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestGemini(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestGemini may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestGemini",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestImageInput(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestImageInput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestImageInput",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestImageInputAnthropic(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestImageInputAnthropic may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestImageInputAnthropic",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        imgs: T::Array[Baml::Image],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestImageListInput(
        *varargs,
        imgs:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestImageListInput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestImageListInput",
        {
          imgs: imgs,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: Baml::Types::NamedArgsSingleClass,myArg2: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestMulticlassNamedArgs(
        *varargs,
        myArg:,myArg2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestMulticlassNamedArgs may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestMulticlassNamedArgs",
        {
          myArg: myArg,myArg2: myArg2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestOllama(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestOllama may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestOllama",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestOpenAILegacyProvider(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestOpenAILegacyProvider may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestOpenAILegacyProvider",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestOpenAIShorthand(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestOpenAIShorthand may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestOpenAIShorthand",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestRetryConstant(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestRetryConstant may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestRetryConstant",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestRetryExponential(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestRetryExponential may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestRetryExponential",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestVertex(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestVertex may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "TestVertex",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        varargs: T.untyped,
        input: T.any(String, T::Boolean),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::Types::UnionTest_ReturnType)
    }
    def UnionTest_Function(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("UnionTest_Function may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.call_function(
        "UnionTest_Function",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    

  end

  class BamlStreamClient
    extend T::Sig

    sig {params(runtime: Baml::Ffi::BamlRuntime, ctx_manager: Baml::Ffi::RuntimeContextManager).void}
    def initialize(runtime:, ctx_manager:)
      @runtime = runtime
      @ctx_manager = ctx_manager
    end

    sig {
      params(
        varargs: T.untyped,
        recipe: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Recipe])
    }
    def AaaSamOutputFormat(
        *varargs,
        recipe:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AaaSamOutputFormat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AaaSamOutputFormat",
        {
          recipe: recipe,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::Recipe, Baml::Types::Recipe].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::InputClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AliasedInputClass(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AliasedInputClass",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::InputClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AliasedInputClass2(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputClass2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AliasedInputClass2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::InputClassNested,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AliasedInputClassNested(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputClassNested may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AliasedInputClassNested",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: T.any(Baml::Types::AliasedEnum, String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AliasedInputEnum(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputEnum may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AliasedInputEnum",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: T::Array[T.any(Baml::Types::AliasedEnum, String)],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AliasedInputList(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AliasedInputList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AliasedInputList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        aud: Baml::Audio,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AudioInput(
        *varargs,
        aud:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AudioInput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "AudioInput",
        {
          aud: aud,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::DynEnumTwo, String)])
    }
    def ClassifyDynEnumTwo(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyDynEnumTwo may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ClassifyDynEnumTwo",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Baml::Types::DynEnumTwo), T.any(Baml::Types::DynEnumTwo, String)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::Category, String)])
    }
    def ClassifyMessage(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyMessage may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ClassifyMessage",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), T.any(Baml::Types::Category, String)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::Category, String)])
    }
    def ClassifyMessage2(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyMessage2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ClassifyMessage2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), T.any(Baml::Types::Category, String)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::Category, String)])
    }
    def ClassifyMessage3(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ClassifyMessage3 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ClassifyMessage3",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), T.any(Baml::Types::Category, String)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::BookOrder, Baml::Types::FlightConfirmation, Baml::Types::GroceryReceipt)])
    }
    def CustomTask(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("CustomTask may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "CustomTask",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(T.any(Baml::PartialTypes::BookOrder, Baml::PartialTypes::FlightConfirmation, Baml::PartialTypes::GroceryReceipt)), T.any(Baml::Types::BookOrder, Baml::Types::FlightConfirmation, Baml::Types::GroceryReceipt)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DescribeImage",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage2(
        *varargs,
        classWithImage:,img2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DescribeImage2",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage3(
        *varargs,
        classWithImage:,img2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage3 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DescribeImage3",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage4(
        *varargs,
        classWithImage:,img2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DescribeImage4 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DescribeImage4",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::OriginalA, Baml::Types::OriginalB)])
    }
    def DifferentiateUnions(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DifferentiateUnions may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DifferentiateUnions",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(T.any(Baml::PartialTypes::OriginalA, Baml::PartialTypes::OriginalB)), T.any(Baml::Types::OriginalA, Baml::Types::OriginalB)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DummyOutput])
    }
    def DummyOutputFunction(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DummyOutputFunction may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DummyOutputFunction",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::DummyOutput, Baml::Types::DummyOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::DynamicClassOne,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DynamicClassTwo])
    }
    def DynamicFunc(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DynamicFunc may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DynamicFunc",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::DynamicClassTwo, Baml::Types::DynamicClassTwo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: Baml::Types::DynInputOutput,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DynInputOutput])
    }
    def DynamicInputOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DynamicInputOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DynamicInputOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::DynInputOutput, Baml::Types::DynInputOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: T::Array[Baml::Types::DynInputOutput],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::DynInputOutput]])
    }
    def DynamicListInputOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("DynamicListInputOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "DynamicListInputOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::DynInputOutput], T::Array[Baml::Types::DynInputOutput]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def ExpectFailure(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExpectFailure may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ExpectFailure",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[String]])
    }
    def ExtractNames(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractNames may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ExtractNames",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[T.nilable(String)], T::Array[String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::Person]])
    }
    def ExtractPeople(
        *varargs,
        text:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractPeople may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ExtractPeople",
        {
          text: text,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::Person], T::Array[Baml::Types::Person]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        email: String,reason: T.any(String, String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::ReceiptInfo])
    }
    def ExtractReceiptInfo(
        *varargs,
        email:,reason:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractReceiptInfo may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ExtractReceiptInfo",
        {
          email: email,reason: reason,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::ReceiptInfo, Baml::Types::ReceiptInfo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        resume: String,img: T.nilable(Baml::Image),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Resume])
    }
    def ExtractResume(
        *varargs,
        resume:,img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractResume may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ExtractResume",
        {
          resume: resume,img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::Resume, Baml::Types::Resume].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        resume: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Resume])
    }
    def ExtractResume2(
        *varargs,
        resume:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("ExtractResume2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "ExtractResume2",
        {
          resume: resume,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::Resume, Baml::Types::Resume].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.nilable(Baml::Types::ClassOptionalOutput)])
    }
    def FnClassOptionalOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnClassOptionalOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnClassOptionalOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::ClassOptionalOutput, T.nilable(Baml::Types::ClassOptionalOutput)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.nilable(Baml::Types::ClassOptionalOutput2)])
    }
    def FnClassOptionalOutput2(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnClassOptionalOutput2 may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnClassOptionalOutput2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::ClassOptionalOutput2, T.nilable(Baml::Types::ClassOptionalOutput2)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[T.any(Baml::Types::EnumOutput, String)]])
    }
    def FnEnumListOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnEnumListOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnEnumListOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[T.nilable(Baml::Types::EnumOutput)], T::Array[T.any(Baml::Types::EnumOutput, String)]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::EnumOutput, String)])
    }
    def FnEnumOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnEnumOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnEnumOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Baml::Types::EnumOutput), T.any(Baml::Types::EnumOutput, String)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myString: T.nilable(String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def FnNamedArgsSingleStringOptional(
        *varargs,
        myString:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnNamedArgsSingleStringOptional may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnNamedArgsSingleStringOptional",
        {
          myString: myString,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Boolean])
    }
    def FnOutputBool(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputBool may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnOutputBool",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(T::Boolean), T::Boolean].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestOutputClass])
    }
    def FnOutputClass(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnOutputClass",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::TestOutputClass, Baml::Types::TestOutputClass].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::TestOutputClass]])
    }
    def FnOutputClassList(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClassList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnOutputClassList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::TestOutputClass], T::Array[Baml::Types::TestOutputClass]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestClassNested])
    }
    def FnOutputClassNested(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClassNested may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnOutputClassNested",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassNested, Baml::Types::TestClassNested].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestClassWithEnum])
    }
    def FnOutputClassWithEnum(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputClassWithEnum may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnOutputClassWithEnum",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassWithEnum, Baml::Types::TestClassWithEnum].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[String]])
    }
    def FnOutputStringList(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnOutputStringList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnOutputStringList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[T.nilable(String)], T::Array[String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.any(Baml::Types::TestEnum, String)])
    }
    def FnTestAliasedEnumOutput(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnTestAliasedEnumOutput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnTestAliasedEnumOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Baml::Types::TestEnum), T.any(Baml::Types::TestEnum, String)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestClassAlias])
    }
    def FnTestClassAlias(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnTestClassAlias may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnTestClassAlias",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassAlias, Baml::Types::TestClassAlias].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: T.any(Baml::Types::NamedArgsSingleEnum, String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def FnTestNamedArgsSingleEnum(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FnTestNamedArgsSingleEnum may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "FnTestNamedArgsSingleEnum",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::RaysData])
    }
    def GetDataType(
        *varargs,
        text:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("GetDataType may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "GetDataType",
        {
          text: text,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::RaysData, Baml::Types::RaysData].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        email: Baml::Types::Email,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::OrderInfo])
    }
    def GetOrderInfo(
        *varargs,
        email:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("GetOrderInfo may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "GetOrderInfo",
        {
          email: email,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::OrderInfo, Baml::Types::OrderInfo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        query: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::SearchParams])
    }
    def GetQuery(
        *varargs,
        query:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("GetQuery may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "GetQuery",
        {
          query: query,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::SearchParams, Baml::Types::SearchParams].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DynamicOutput])
    }
    def MyFunc(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("MyFunc may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "MyFunc",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::DynamicOutput, Baml::Types::DynamicOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)]])
    }
    def OptionalTest_Function(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("OptionalTest_Function may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "OptionalTest_Function",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::OptionalTest_ReturnType], T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaude(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestClaude may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestClaude",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaudeChat(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestClaudeChat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestClaudeChat",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaudeChatNoSystem(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestClaudeChatNoSystem may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestClaudeChatNoSystem",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAI(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestOpenAI may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestOpenAI",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAIChat(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestOpenAIChat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestOpenAIChat",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAIChatNoSystem(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestOpenAIChatNoSystem may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestOpenAIChatNoSystem",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestStreaming(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("PromptTestStreaming may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "PromptTestStreaming",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Schema])
    }
    def SchemaDescriptions(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("SchemaDescriptions may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "SchemaDescriptions",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::Schema, Baml::Types::Schema].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::BigNumbers])
    }
    def StreamBigNumbers(
        *varargs,
        digits:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamBigNumbers may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "StreamBigNumbers",
        {
          digits: digits,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::BigNumbers, Baml::Types::BigNumbers].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Integer])
    }
    def StreamOneBigNumber(
        *varargs,
        digits:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamOneBigNumber may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "StreamOneBigNumber",
        {
          digits: digits,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(Integer), Integer].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[T.any(Integer, String)]])
    }
    def StreamUnionIntegers(
        *varargs,
        digits:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamUnionIntegers may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "StreamUnionIntegers",
        {
          digits: digits,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Array[T.nilable(T.any(T.nilable(Integer), T.nilable(String)))], T::Array[T.any(Integer, String)]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        digits: Integer,yapping: T::Boolean,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::CompoundBigNumbers])
    }
    def StreamingCompoundNumbers(
        *varargs,
        digits:,yapping:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("StreamingCompoundNumbers may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "StreamingCompoundNumbers",
        {
          digits: digits,yapping: yapping,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::CompoundBigNumbers, Baml::Types::CompoundBigNumbers].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAnthropic(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAnthropic may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestAnthropic",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAnthropicShorthand(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAnthropicShorthand may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestAnthropicShorthand",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAws(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAws may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestAws",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAzure(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestAzure may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestAzure",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestCaching(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestCaching may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestCaching",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFallbackClient(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFallbackClient may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFallbackClient",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFallbackToShorthand(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFallbackToShorthand may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFallbackToShorthand",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myBool: T::Boolean,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleBool(
        *varargs,
        myBool:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleBool may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleBool",
        {
          myBool: myBool,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleClass(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleClass",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: T::Array[T.any(Baml::Types::NamedArgsSingleEnumList, String)],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleEnumList(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleEnumList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleEnumList",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myFloat: Float,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleFloat(
        *varargs,
        myFloat:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleFloat may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleFloat",
        {
          myFloat: myFloat,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myInt: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleInt(
        *varargs,
        myInt:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleInt may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleInt",
        {
          myInt: myInt,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myMap: T::Hash[String, Baml::Types::StringToClassEntry],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Hash[String, Baml::Types::StringToClassEntry]])
    }
    def TestFnNamedArgsSingleMapStringToClass(
        *varargs,
        myMap:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleMapStringToClass may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToClass",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Hash[String, Baml::PartialTypes::StringToClassEntry], T::Hash[String, Baml::Types::StringToClassEntry]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myMap: T::Hash[String, T::Hash[String, String]],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Hash[String, T::Hash[String, String]]])
    }
    def TestFnNamedArgsSingleMapStringToMap(
        *varargs,
        myMap:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleMapStringToMap may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToMap",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Hash[String, T::Hash[String, T.nilable(String)]], T::Hash[String, T::Hash[String, String]]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myMap: T::Hash[String, String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Hash[String, String]])
    }
    def TestFnNamedArgsSingleMapStringToString(
        *varargs,
        myMap:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleMapStringToString may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToString",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T::Hash[String, T.nilable(String)], T::Hash[String, String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myString: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleString(
        *varargs,
        myString:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleString may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleString",
        {
          myString: myString,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myStringArray: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleStringArray(
        *varargs,
        myStringArray:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleStringArray may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleStringArray",
        {
          myStringArray: myStringArray,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleStringList(
        *varargs,
        myArg:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestFnNamedArgsSingleStringList may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleStringList",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestGemini(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestGemini may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestGemini",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestImageInput(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestImageInput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestImageInput",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestImageInputAnthropic(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestImageInputAnthropic may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestImageInputAnthropic",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        imgs: T::Array[Baml::Image],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestImageListInput(
        *varargs,
        imgs:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestImageListInput may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestImageListInput",
        {
          imgs: imgs,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        myArg: Baml::Types::NamedArgsSingleClass,myArg2: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestMulticlassNamedArgs(
        *varargs,
        myArg:,myArg2:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestMulticlassNamedArgs may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestMulticlassNamedArgs",
        {
          myArg: myArg,myArg2: myArg2,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestOllama(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestOllama may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestOllama",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestOpenAILegacyProvider(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestOpenAILegacyProvider may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestOpenAILegacyProvider",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestOpenAIShorthand(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestOpenAIShorthand may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestOpenAIShorthand",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestRetryConstant(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestRetryConstant may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestRetryConstant",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestRetryExponential(
        *varargs,
        
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestRetryExponential may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestRetryExponential",
        {
          
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestVertex(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("TestVertex may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "TestVertex",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        input: T.any(String, T::Boolean),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::UnionTest_ReturnType])
    }
    def UnionTest_Function(
        *varargs,
        input:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("UnionTest_Function may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb): #{baml_options.keys - [:client_registry, :tb]}")
      end

      raw = @runtime.stream_function(
        "UnionTest_Function",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
      )
      Baml::BamlStream[Baml::PartialTypes::UnionTest_ReturnType, Baml::Types::UnionTest_ReturnType].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    
  end
end