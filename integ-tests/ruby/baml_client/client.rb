###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ bundle add baml sorbet-runtime sorbet-struct-comparable
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# frozen_string_literal: true
# rubocop: disable
# formatter:off
# typed: false
require "baml"
require "sorbet-runtime"

require_relative "inlined"
require_relative "partial-types"
require_relative "types"

module Baml
  @instance = nil

  def self.Client
    if @instance.nil?
      @instance = BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_files("baml_src", Baml::Inlined::FILE_MAP, ENV))
    end
  
    @instance
  end

  class BamlClient
    extend T::Sig

    sig { returns(BamlStreamClient) }
    attr_reader :stream

    sig {params(runtime: Baml::Ffi::BamlRuntime).void}
    def initialize(runtime:)
      @runtime = runtime
      @ctx_manager = runtime.create_context_manager()
      @stream = BamlStreamClient.new(runtime: @runtime, ctx_manager: @ctx_manager)
    end

    sig {params(path: String).returns(BamlClient)}
    def self.from_directory(path)
      BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_directory(path, ENV))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::Category)
    }
    def ClassifyMessage(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ClassifyMessage",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::Category)
    }
    def ClassifyMessage2(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ClassifyMessage2",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::Category)
    }
    def ClassifyMessage3(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ClassifyMessage3",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def DescribeImage(
        img:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "DescribeImage",
        {
          "img" => img,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def DescribeImage2(
        classWithImage:,img2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "DescribeImage2",
        {
          "classWithImage" => classWithImage,"img2" => img2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def DescribeImage3(
        classWithImage:,img2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "DescribeImage3",
        {
          "classWithImage" => classWithImage,"img2" => img2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def DescribeImage4(
        classWithImage:,img2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "DescribeImage4",
        {
          "classWithImage" => classWithImage,"img2" => img2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: Baml::Types::DynamicClassOne,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::DynamicClassTwo)
    }
    def DynamicFunc(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "DynamicFunc",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Array[String])
    }
    def ExtractNames(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ExtractNames",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Array[Baml::Types::Person])
    }
    def ExtractPeople(
        text:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ExtractPeople",
        {
          "text" => text,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        resume: String,img: T.nilable(Baml::Image),
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::Resume)
    }
    def ExtractResume(
        resume:,img:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ExtractResume",
        {
          "resume" => resume,"img" => img,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        resume: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::Resume)
    }
    def ExtractResume2(
        resume:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "ExtractResume2",
        {
          "resume" => resume,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T.nilable(Baml::Types::ClassOptionalOutput))
    }
    def FnClassOptionalOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnClassOptionalOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T.nilable(Baml::Types::ClassOptionalOutput2))
    }
    def FnClassOptionalOutput2(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnClassOptionalOutput2",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Array[Baml::Types::EnumOutput])
    }
    def FnEnumListOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnEnumListOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::EnumOutput)
    }
    def FnEnumOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnEnumOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myString: T.nilable(String),
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def FnNamedArgsSingleStringOptional(
        myString:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnNamedArgsSingleStringOptional",
        {
          "myString" => myString,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Boolean)
    }
    def FnOutputBool(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnOutputBool",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::TestOutputClass)
    }
    def FnOutputClass(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnOutputClass",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Array[Baml::Types::TestOutputClass])
    }
    def FnOutputClassList(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnOutputClassList",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::TestClassWithEnum)
    }
    def FnOutputClassWithEnum(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnOutputClassWithEnum",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::TestOutputClassNested)
    }
    def FnOutputNestedClass(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnOutputNestedClass",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Array[String])
    }
    def FnOutputStringList(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnOutputStringList",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::TestEnum)
    }
    def FnTestAliasedEnumOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnTestAliasedEnumOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::TestClassAlias)
    }
    def FnTestClassAlias(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnTestClassAlias",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleEnum,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def FnTestNamedArgsSingleEnum(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "FnTestNamedArgsSingleEnum",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::RaysData)
    }
    def GetDataType(
        text:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "GetDataType",
        {
          "text" => text,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        email: Baml::Types::Email,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::OrderInfo)
    }
    def GetOrderInfo(
        email:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "GetOrderInfo",
        {
          "email" => email,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        query: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::SearchParams)
    }
    def GetQuery(
        query:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "GetQuery",
        {
          "query" => query,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::DynamicOutput)
    }
    def MyFunc(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "MyFunc",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)])
    }
    def OptionalTest_Function(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "OptionalTest_Function",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def PromptTestClaude(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "PromptTestClaude",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def PromptTestClaudeChat(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "PromptTestClaudeChat",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def PromptTestClaudeChatNoSystem(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "PromptTestClaudeChatNoSystem",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def PromptTestOpenAI(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "PromptTestOpenAI",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def PromptTestOpenAIChat(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "PromptTestOpenAIChat",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def PromptTestOpenAIChatNoSystem(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "PromptTestOpenAIChatNoSystem",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFallbackClient(
        
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFallbackClient",
        {
          
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myBool: T::Boolean,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleBool(
        myBool:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleBool",
        {
          "myBool" => myBool,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleClass(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleClass",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: T::Array[Baml::Types::NamedArgsSingleEnumList],
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleEnumList(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleEnumList",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myFloat: Float,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleFloat(
        myFloat:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleFloat",
        {
          "myFloat" => myFloat,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myInt: Integer,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleInt(
        myInt:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleInt",
        {
          "myInt" => myInt,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myString: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleString(
        myString:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleString",
        {
          "myString" => myString,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myStringArray: T::Array[String],
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleStringArray(
        myStringArray:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleStringArray",
        {
          "myStringArray" => myStringArray,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: T::Array[String],
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestFnNamedArgsSingleStringList(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleStringList",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestImageInput(
        img:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestImageInput",
        {
          "img" => img,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,myArg2: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestMulticlassNamedArgs(
        myArg:,myArg2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestMulticlassNamedArgs",
        {
          "myArg" => myArg,"myArg2" => myArg2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestOllama(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestOllama",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestRetryConstant(
        
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestRetryConstant",
        {
          
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(String)
    }
    def TestRetryExponential(
        
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "TestRetryExponential",
        {
          
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: T.any(String, T::Boolean),
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::Types::UnionTest_ReturnType)
    }
    def UnionTest_Function(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.call_function(
        "UnionTest_Function",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      (raw.parsed_using_types(Baml::Types))
    end

    

  end

  class BamlStreamClient
    extend T::Sig

    sig {params(runtime: Baml::Ffi::BamlRuntime, ctx_manager: Baml::Ffi::RuntimeContextManager).void}
    def initialize(runtime:, ctx_manager:)
      @runtime = runtime
      @ctx_manager = ctx_manager
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::Category])
    }
    def ClassifyMessage(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ClassifyMessage",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), Baml::Types::Category].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::Category])
    }
    def ClassifyMessage2(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ClassifyMessage2",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), Baml::Types::Category].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::Category])
    }
    def ClassifyMessage3(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ClassifyMessage3",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), Baml::Types::Category].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage(
        img:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "DescribeImage",
        {
          "img" => img,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage2(
        classWithImage:,img2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "DescribeImage2",
        {
          "classWithImage" => classWithImage,"img2" => img2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage3(
        classWithImage:,img2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "DescribeImage3",
        {
          "classWithImage" => classWithImage,"img2" => img2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage4(
        classWithImage:,img2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "DescribeImage4",
        {
          "classWithImage" => classWithImage,"img2" => img2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: Baml::Types::DynamicClassOne,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::DynamicClassTwo])
    }
    def DynamicFunc(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "DynamicFunc",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::DynamicClassTwo, Baml::Types::DynamicClassTwo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Array[String]])
    }
    def ExtractNames(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ExtractNames",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T::Array[T.nilable(String)], T::Array[String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::Person]])
    }
    def ExtractPeople(
        text:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ExtractPeople",
        {
          "text" => text,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::Person], T::Array[Baml::Types::Person]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        resume: String,img: T.nilable(Baml::Image),
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::Resume])
    }
    def ExtractResume(
        resume:,img:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ExtractResume",
        {
          "resume" => resume,"img" => img,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::Resume, Baml::Types::Resume].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        resume: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::Resume])
    }
    def ExtractResume2(
        resume:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "ExtractResume2",
        {
          "resume" => resume,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::Resume, Baml::Types::Resume].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T.nilable(Baml::Types::ClassOptionalOutput)])
    }
    def FnClassOptionalOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnClassOptionalOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::ClassOptionalOutput, T.nilable(Baml::Types::ClassOptionalOutput)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T.nilable(Baml::Types::ClassOptionalOutput2)])
    }
    def FnClassOptionalOutput2(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnClassOptionalOutput2",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::ClassOptionalOutput2, T.nilable(Baml::Types::ClassOptionalOutput2)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::EnumOutput]])
    }
    def FnEnumListOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnEnumListOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T::Array[T.nilable(Baml::Types::EnumOutput)], T::Array[Baml::Types::EnumOutput]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::EnumOutput])
    }
    def FnEnumOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnEnumOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(Baml::Types::EnumOutput), Baml::Types::EnumOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myString: T.nilable(String),
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def FnNamedArgsSingleStringOptional(
        myString:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnNamedArgsSingleStringOptional",
        {
          "myString" => myString,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Boolean])
    }
    def FnOutputBool(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnOutputBool",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(T::Boolean), T::Boolean].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::TestOutputClass])
    }
    def FnOutputClass(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnOutputClass",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::TestOutputClass, Baml::Types::TestOutputClass].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::TestOutputClass]])
    }
    def FnOutputClassList(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnOutputClassList",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::TestOutputClass], T::Array[Baml::Types::TestOutputClass]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::TestClassWithEnum])
    }
    def FnOutputClassWithEnum(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnOutputClassWithEnum",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassWithEnum, Baml::Types::TestClassWithEnum].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::TestOutputClassNested])
    }
    def FnOutputNestedClass(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnOutputNestedClass",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::TestOutputClassNested, Baml::Types::TestOutputClassNested].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Array[String]])
    }
    def FnOutputStringList(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnOutputStringList",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T::Array[T.nilable(String)], T::Array[String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::TestEnum])
    }
    def FnTestAliasedEnumOutput(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnTestAliasedEnumOutput",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(Baml::Types::TestEnum), Baml::Types::TestEnum].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::TestClassAlias])
    }
    def FnTestClassAlias(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnTestClassAlias",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassAlias, Baml::Types::TestClassAlias].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleEnum,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def FnTestNamedArgsSingleEnum(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "FnTestNamedArgsSingleEnum",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::RaysData])
    }
    def GetDataType(
        text:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "GetDataType",
        {
          "text" => text,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::RaysData, Baml::Types::RaysData].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        email: Baml::Types::Email,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::OrderInfo])
    }
    def GetOrderInfo(
        email:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "GetOrderInfo",
        {
          "email" => email,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::OrderInfo, Baml::Types::OrderInfo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        query: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::SearchParams])
    }
    def GetQuery(
        query:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "GetQuery",
        {
          "query" => query,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::SearchParams, Baml::Types::SearchParams].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::DynamicOutput])
    }
    def MyFunc(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "MyFunc",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::DynamicOutput, Baml::Types::DynamicOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)]])
    }
    def OptionalTest_Function(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "OptionalTest_Function",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::OptionalTest_ReturnType], T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaude(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "PromptTestClaude",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaudeChat(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "PromptTestClaudeChat",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaudeChatNoSystem(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "PromptTestClaudeChatNoSystem",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAI(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "PromptTestOpenAI",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAIChat(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "PromptTestOpenAIChat",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAIChatNoSystem(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "PromptTestOpenAIChatNoSystem",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFallbackClient(
        
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFallbackClient",
        {
          
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myBool: T::Boolean,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleBool(
        myBool:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleBool",
        {
          "myBool" => myBool,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleClass(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleClass",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: T::Array[Baml::Types::NamedArgsSingleEnumList],
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleEnumList(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleEnumList",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myFloat: Float,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleFloat(
        myFloat:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleFloat",
        {
          "myFloat" => myFloat,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myInt: Integer,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleInt(
        myInt:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleInt",
        {
          "myInt" => myInt,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myString: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleString(
        myString:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleString",
        {
          "myString" => myString,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myStringArray: T::Array[String],
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleStringArray(
        myStringArray:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleStringArray",
        {
          "myStringArray" => myStringArray,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: T::Array[String],
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleStringList(
        myArg:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleStringList",
        {
          "myArg" => myArg,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestImageInput(
        img:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestImageInput",
        {
          "img" => img,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,myArg2: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestMulticlassNamedArgs(
        myArg:,myArg2:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestMulticlassNamedArgs",
        {
          "myArg" => myArg,"myArg2" => myArg2,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestOllama(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestOllama",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestRetryConstant(
        
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestRetryConstant",
        {
          
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[String])
    }
    def TestRetryExponential(
        
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "TestRetryExponential",
        {
          
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: T.any(String, T::Boolean),
        baml_options: T::Hash[Symbol, T.untyped]
      ).returns(Baml::BamlStream[Baml::Types::UnionTest_ReturnType])
    }
    def UnionTest_Function(
        input:,
        baml_options: {
          :types => nil
        }
    )
      raw = @runtime.stream_function(
        "UnionTest_Function",
        {
          "input" => input,
        },
        @ctx_manager,
        baml_options[:types]
      )
      Baml::BamlStream[Baml::PartialTypes::UnionTest_ReturnType, Baml::Types::UnionTest_ReturnType].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    
  end
end