###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ bundle add baml sorbet-runtime sorbet-struct-comparable
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# frozen_string_literal: true
# rubocop: disable
# formatter:off
# typed: false
require "baml"
require "sorbet-runtime"

require_relative "inlined"
require_relative "partial-types"
require_relative "types"
require_relative "type-registry"

module Baml
  @instance = nil

  def self.Client
    if @instance.nil?
      @instance = BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_files("baml_src", Baml::Inlined::FILE_MAP, ENV))
    end
  
    @instance
  end

  class BamlClient
    extend T::Sig

    sig { returns(BamlStreamClient) }
    attr_reader :stream

    sig {params(runtime: Baml::Ffi::BamlRuntime).void}
    def initialize(runtime:)
      @runtime = runtime
      @ctx_manager = runtime.create_context_manager()
      @stream = BamlStreamClient.new(runtime: @runtime, ctx_manager: @ctx_manager)
    end

    sig {params(path: String).returns(BamlClient)}
    def self.from_directory(path)
      BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_directory(path, ENV))
    end

    sig {
      params(
        recipe: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::Recipe)
    }
    def AaaSamOutputFormat(
        recipe:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "AaaSamOutputFormat",
        {
          recipe: recipe,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        aud: Baml::Audio,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def AudioInput(
        aud:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "AudioInput",
        {
          aud: aud,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::Category)
    }
    def ClassifyMessage(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ClassifyMessage",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::Category)
    }
    def ClassifyMessage2(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ClassifyMessage2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::Category)
    }
    def ClassifyMessage3(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ClassifyMessage3",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage(
        img:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DescribeImage",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage2(
        classWithImage:,img2:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DescribeImage2",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage3(
        classWithImage:,img2:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DescribeImage3",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def DescribeImage4(
        classWithImage:,img2:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DescribeImage4",
        {
          classWithImage: classWithImage,img2: img2,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::DummyOutput)
    }
    def DummyOutputFunction(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DummyOutputFunction",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: Baml::Types::DynamicClassOne,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::DynamicClassTwo)
    }
    def DynamicFunc(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DynamicFunc",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: Baml::Types::DynInputOutput,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::DynInputOutput)
    }
    def DynamicInputOutput(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DynamicInputOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: T::Array[Baml::Types::DynInputOutput],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::DynInputOutput])
    }
    def DynamicListInputOutput(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "DynamicListInputOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def ExpectFailure(
        
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ExpectFailure",
        {
          
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[String])
    }
    def ExtractNames(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ExtractNames",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::Person])
    }
    def ExtractPeople(
        text:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ExtractPeople",
        {
          text: text,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        email: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::ReceiptInfo)
    }
    def ExtractReceiptInfo(
        email:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ExtractReceiptInfo",
        {
          email: email,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        resume: String,img: T.nilable(Baml::Image),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::Resume)
    }
    def ExtractResume(
        resume:,img:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ExtractResume",
        {
          resume: resume,img: img,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        resume: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::Resume)
    }
    def ExtractResume2(
        resume:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "ExtractResume2",
        {
          resume: resume,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T.nilable(Baml::Types::ClassOptionalOutput))
    }
    def FnClassOptionalOutput(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnClassOptionalOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T.nilable(Baml::Types::ClassOptionalOutput2))
    }
    def FnClassOptionalOutput2(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnClassOptionalOutput2",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::EnumOutput])
    }
    def FnEnumListOutput(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnEnumListOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::EnumOutput)
    }
    def FnEnumOutput(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnEnumOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myString: T.nilable(String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def FnNamedArgsSingleStringOptional(
        myString:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnNamedArgsSingleStringOptional",
        {
          myString: myString,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Boolean)
    }
    def FnOutputBool(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnOutputBool",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestOutputClass)
    }
    def FnOutputClass(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnOutputClass",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[Baml::Types::TestOutputClass])
    }
    def FnOutputClassList(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnOutputClassList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestClassNested)
    }
    def FnOutputClassNested(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnOutputClassNested",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestClassWithEnum)
    }
    def FnOutputClassWithEnum(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnOutputClassWithEnum",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[String])
    }
    def FnOutputStringList(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnOutputStringList",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestEnum)
    }
    def FnTestAliasedEnumOutput(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnTestAliasedEnumOutput",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::TestClassAlias)
    }
    def FnTestClassAlias(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnTestClassAlias",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleEnum,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def FnTestNamedArgsSingleEnum(
        myArg:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "FnTestNamedArgsSingleEnum",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::RaysData)
    }
    def GetDataType(
        text:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "GetDataType",
        {
          text: text,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        email: Baml::Types::Email,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::OrderInfo)
    }
    def GetOrderInfo(
        email:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "GetOrderInfo",
        {
          email: email,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        query: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::SearchParams)
    }
    def GetQuery(
        query:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "GetQuery",
        {
          query: query,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::DynamicOutput)
    }
    def MyFunc(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "MyFunc",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)])
    }
    def OptionalTest_Function(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "OptionalTest_Function",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestClaude(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestClaude",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestClaudeChat(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestClaudeChat",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestClaudeChatNoSystem(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestClaudeChatNoSystem",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestOpenAI(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestOpenAI",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestOpenAIChat(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestOpenAIChat",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestOpenAIChatNoSystem(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestOpenAIChatNoSystem",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def PromptTestStreaming(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "PromptTestStreaming",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAnthropic(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestAnthropic",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAws(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestAws",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestAzure(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestAzure",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFallbackClient(
        
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFallbackClient",
        {
          
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myBool: T::Boolean,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleBool(
        myBool:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleBool",
        {
          myBool: myBool,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleClass(
        myArg:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleClass",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: T::Array[Baml::Types::NamedArgsSingleEnumList],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleEnumList(
        myArg:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleEnumList",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myFloat: Float,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleFloat(
        myFloat:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleFloat",
        {
          myFloat: myFloat,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myInt: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleInt(
        myInt:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleInt",
        {
          myInt: myInt,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myMap: T::Hash[String, Baml::Types::StringToClassEntry],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Hash[String, Baml::Types::StringToClassEntry])
    }
    def TestFnNamedArgsSingleMapStringToClass(
        myMap:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleMapStringToClass",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myMap: T::Hash[String, T::Hash[String, String]],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Hash[String, T::Hash[String, String]])
    }
    def TestFnNamedArgsSingleMapStringToMap(
        myMap:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleMapStringToMap",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myMap: T::Hash[String, String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(T::Hash[String, String])
    }
    def TestFnNamedArgsSingleMapStringToString(
        myMap:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleMapStringToString",
        {
          myMap: myMap,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myString: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleString(
        myString:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleString",
        {
          myString: myString,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myStringArray: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleStringArray(
        myStringArray:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleStringArray",
        {
          myStringArray: myStringArray,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestFnNamedArgsSingleStringList(
        myArg:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestFnNamedArgsSingleStringList",
        {
          myArg: myArg,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestGemini(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestGemini",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestImageInput(
        img:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestImageInput",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,myArg2: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestMulticlassNamedArgs(
        myArg:,myArg2:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestMulticlassNamedArgs",
        {
          myArg: myArg,myArg2: myArg2,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestOllama(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestOllama",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestOpenAILegacyProvider(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestOpenAILegacyProvider",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestRetryConstant(
        
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestRetryConstant",
        {
          
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestRetryExponential(
        
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestRetryExponential",
        {
          
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(String)
    }
    def TestVertex(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "TestVertex",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    sig {
      params(
        input: T.any(String, T::Boolean),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::Types::UnionTest_ReturnType)
    }
    def UnionTest_Function(
        input:,
        baml_options: {}
    )
      raw = @runtime.call_function(
        "UnionTest_Function",
        {
          input: input,
        },
        @ctx_manager,
        baml_options[:type_registry],
        baml_options[:client_registry],
      )
      (raw.parsed_using_types(Baml::Types))
    end

    

  end

  class BamlStreamClient
    extend T::Sig

    sig {params(runtime: Baml::Ffi::BamlRuntime, ctx_manager: Baml::Ffi::RuntimeContextManager).void}
    def initialize(runtime:, ctx_manager:)
      @runtime = runtime
      @ctx_manager = ctx_manager
    end

    sig {
      params(
        recipe: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Recipe])
    }
    def AaaSamOutputFormat(
        recipe:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "AaaSamOutputFormat",
        {
          name: recipe,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::Recipe, Baml::Types::Recipe].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        aud: Baml::Audio,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def AudioInput(
        aud:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "AudioInput",
        {
          name: aud,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Category])
    }
    def ClassifyMessage(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ClassifyMessage",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), Baml::Types::Category].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Category])
    }
    def ClassifyMessage2(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ClassifyMessage2",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), Baml::Types::Category].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Category])
    }
    def ClassifyMessage3(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ClassifyMessage3",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(Baml::Types::Category), Baml::Types::Category].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage(
        img:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DescribeImage",
        {
          name: img,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage2(
        classWithImage:,img2:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DescribeImage2",
        {
          name: classWithImage,name: img2,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage3(
        classWithImage:,img2:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DescribeImage3",
        {
          name: classWithImage,name: img2,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        classWithImage: Baml::Types::ClassWithImage,img2: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def DescribeImage4(
        classWithImage:,img2:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DescribeImage4",
        {
          name: classWithImage,name: img2,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DummyOutput])
    }
    def DummyOutputFunction(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DummyOutputFunction",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::DummyOutput, Baml::Types::DummyOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: Baml::Types::DynamicClassOne,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DynamicClassTwo])
    }
    def DynamicFunc(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DynamicFunc",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::DynamicClassTwo, Baml::Types::DynamicClassTwo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: Baml::Types::DynInputOutput,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DynInputOutput])
    }
    def DynamicInputOutput(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DynamicInputOutput",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::DynInputOutput, Baml::Types::DynInputOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: T::Array[Baml::Types::DynInputOutput],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::DynInputOutput]])
    }
    def DynamicListInputOutput(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "DynamicListInputOutput",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::DynInputOutput], T::Array[Baml::Types::DynInputOutput]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def ExpectFailure(
        
        baml_options:
    )
      raw = @runtime.stream_function(
        "ExpectFailure",
        {
          
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[String]])
    }
    def ExtractNames(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ExtractNames",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[T.nilable(String)], T::Array[String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::Person]])
    }
    def ExtractPeople(
        text:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ExtractPeople",
        {
          name: text,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::Person], T::Array[Baml::Types::Person]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        email: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::ReceiptInfo])
    }
    def ExtractReceiptInfo(
        email:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ExtractReceiptInfo",
        {
          name: email,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::ReceiptInfo, Baml::Types::ReceiptInfo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        resume: String,img: T.nilable(Baml::Image),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Resume])
    }
    def ExtractResume(
        resume:,img:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ExtractResume",
        {
          name: resume,name: img,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::Resume, Baml::Types::Resume].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        resume: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::Resume])
    }
    def ExtractResume2(
        resume:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "ExtractResume2",
        {
          name: resume,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::Resume, Baml::Types::Resume].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.nilable(Baml::Types::ClassOptionalOutput)])
    }
    def FnClassOptionalOutput(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnClassOptionalOutput",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::ClassOptionalOutput, T.nilable(Baml::Types::ClassOptionalOutput)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T.nilable(Baml::Types::ClassOptionalOutput2)])
    }
    def FnClassOptionalOutput2(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnClassOptionalOutput2",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::ClassOptionalOutput2, T.nilable(Baml::Types::ClassOptionalOutput2)].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::EnumOutput]])
    }
    def FnEnumListOutput(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnEnumListOutput",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[T.nilable(Baml::Types::EnumOutput)], T::Array[Baml::Types::EnumOutput]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::EnumOutput])
    }
    def FnEnumOutput(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnEnumOutput",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(Baml::Types::EnumOutput), Baml::Types::EnumOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myString: T.nilable(String),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def FnNamedArgsSingleStringOptional(
        myString:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnNamedArgsSingleStringOptional",
        {
          name: myString,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Boolean])
    }
    def FnOutputBool(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnOutputBool",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(T::Boolean), T::Boolean].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestOutputClass])
    }
    def FnOutputClass(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnOutputClass",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::TestOutputClass, Baml::Types::TestOutputClass].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[Baml::Types::TestOutputClass]])
    }
    def FnOutputClassList(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnOutputClassList",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::TestOutputClass], T::Array[Baml::Types::TestOutputClass]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestClassNested])
    }
    def FnOutputClassNested(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnOutputClassNested",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassNested, Baml::Types::TestClassNested].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestClassWithEnum])
    }
    def FnOutputClassWithEnum(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnOutputClassWithEnum",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassWithEnum, Baml::Types::TestClassWithEnum].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[String]])
    }
    def FnOutputStringList(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnOutputStringList",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[T.nilable(String)], T::Array[String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestEnum])
    }
    def FnTestAliasedEnumOutput(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnTestAliasedEnumOutput",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(Baml::Types::TestEnum), Baml::Types::TestEnum].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::TestClassAlias])
    }
    def FnTestClassAlias(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnTestClassAlias",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::TestClassAlias, Baml::Types::TestClassAlias].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleEnum,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def FnTestNamedArgsSingleEnum(
        myArg:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "FnTestNamedArgsSingleEnum",
        {
          name: myArg,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        text: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::RaysData])
    }
    def GetDataType(
        text:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "GetDataType",
        {
          name: text,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::RaysData, Baml::Types::RaysData].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        email: Baml::Types::Email,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::OrderInfo])
    }
    def GetOrderInfo(
        email:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "GetOrderInfo",
        {
          name: email,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::OrderInfo, Baml::Types::OrderInfo].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        query: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::SearchParams])
    }
    def GetQuery(
        query:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "GetQuery",
        {
          name: query,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::SearchParams, Baml::Types::SearchParams].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::DynamicOutput])
    }
    def MyFunc(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "MyFunc",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::DynamicOutput, Baml::Types::DynamicOutput].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)]])
    }
    def OptionalTest_Function(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "OptionalTest_Function",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Array[Baml::PartialTypes::OptionalTest_ReturnType], T::Array[T.nilable(Baml::Types::OptionalTest_ReturnType)]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaude(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestClaude",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaudeChat(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestClaudeChat",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestClaudeChatNoSystem(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestClaudeChatNoSystem",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAI(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestOpenAI",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAIChat(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestOpenAIChat",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestOpenAIChatNoSystem(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestOpenAIChatNoSystem",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def PromptTestStreaming(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "PromptTestStreaming",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAnthropic(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestAnthropic",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAws(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestAws",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestAzure(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestAzure",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFallbackClient(
        
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFallbackClient",
        {
          
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myBool: T::Boolean,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleBool(
        myBool:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleBool",
        {
          name: myBool,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleClass(
        myArg:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleClass",
        {
          name: myArg,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: T::Array[Baml::Types::NamedArgsSingleEnumList],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleEnumList(
        myArg:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleEnumList",
        {
          name: myArg,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myFloat: Float,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleFloat(
        myFloat:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleFloat",
        {
          name: myFloat,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myInt: Integer,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleInt(
        myInt:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleInt",
        {
          name: myInt,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myMap: T::Hash[String, Baml::Types::StringToClassEntry],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Hash[String, Baml::Types::StringToClassEntry]])
    }
    def TestFnNamedArgsSingleMapStringToClass(
        myMap:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToClass",
        {
          name: myMap,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Hash[String, Baml::PartialTypes::StringToClassEntry], T::Hash[String, Baml::Types::StringToClassEntry]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myMap: T::Hash[String, T::Hash[String, String]],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Hash[String, T::Hash[String, String]]])
    }
    def TestFnNamedArgsSingleMapStringToMap(
        myMap:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToMap",
        {
          name: myMap,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Hash[String, T::Hash[String, T.nilable(String)]], T::Hash[String, T::Hash[String, String]]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myMap: T::Hash[String, String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[T::Hash[String, String]])
    }
    def TestFnNamedArgsSingleMapStringToString(
        myMap:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToString",
        {
          name: myMap,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T::Hash[String, T.nilable(String)], T::Hash[String, String]].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myString: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleString(
        myString:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleString",
        {
          name: myString,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myStringArray: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleStringArray(
        myStringArray:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleStringArray",
        {
          name: myStringArray,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: T::Array[String],
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestFnNamedArgsSingleStringList(
        myArg:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestFnNamedArgsSingleStringList",
        {
          name: myArg,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestGemini(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestGemini",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestImageInput(
        img:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestImageInput",
        {
          name: img,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        myArg: Baml::Types::NamedArgsSingleClass,myArg2: Baml::Types::NamedArgsSingleClass,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestMulticlassNamedArgs(
        myArg:,myArg2:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestMulticlassNamedArgs",
        {
          name: myArg,name: myArg2,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestOllama(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestOllama",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestOpenAILegacyProvider(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestOpenAILegacyProvider",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestRetryConstant(
        
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestRetryConstant",
        {
          
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestRetryExponential(
        
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestRetryExponential",
        {
          
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[String])
    }
    def TestVertex(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "TestVertex",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        input: T.any(String, T::Boolean),
        baml_options: T::Hash[Symbol, T.any(Baml::TypeRegistry, Baml::ClientRegistry)]
      ).returns(Baml::BamlStream[Baml::Types::UnionTest_ReturnType])
    }
    def UnionTest_Function(
        input:,
        baml_options:
    )
      raw = @runtime.stream_function(
        "UnionTest_Function",
        {
          name: input,
        },
        @ctx_manager,
      )
      Baml::BamlStream[Baml::PartialTypes::UnionTest_ReturnType, Baml::Types::UnionTest_ReturnType].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    
  end
end