###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
from typing import Any, Dict, List, Optional, TypeVar, Union, TypedDict, Type, Literal, cast
from typing_extensions import NotRequired
import pprint

import baml_py
from pydantic import BaseModel, ValidationError, create_model

from . import partial_types, types
from .type_builder import TypeBuilder
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


OutputType = TypeVar('OutputType')


# Define the TypedDict with optional parameters having default values
class BamlCallOptions(TypedDict, total=False):
    tb: NotRequired[TypeBuilder]
    client_registry: NotRequired[baml_py.baml_py.ClientRegistry]

class BamlAsyncClient:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager
    __stream_client: "BamlStreamClient"

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager
      self.__stream_client = BamlStreamClient(self.__runtime, self.__ctx_manager)

    @property
    def stream(self):
      return self.__stream_client


    
    async def AaaSamOutputFormat(
        self,
        recipe: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Recipe:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AaaSamOutputFormat",
        {
          "recipe": recipe,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Recipe, raw.cast_to(types, types))
    
    async def AliasedInputClass(
        self,
        input: types.InputClass,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AliasedInputClass",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def AliasedInputClass2(
        self,
        input: types.InputClass,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AliasedInputClass2",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def AliasedInputClassNested(
        self,
        input: types.InputClassNested,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AliasedInputClassNested",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def AliasedInputEnum(
        self,
        input: types.AliasedEnum,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AliasedInputEnum",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def AliasedInputList(
        self,
        input: List[types.AliasedEnum],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AliasedInputList",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def AudioInput(
        self,
        aud: baml_py.Audio,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "AudioInput",
        {
          "aud": aud,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def ClassifyDynEnumTwo(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> Union[types.DynEnumTwo, str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ClassifyDynEnumTwo",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Union[types.DynEnumTwo, str], raw.cast_to(types, types))
    
    async def ClassifyMessage(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Category:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ClassifyMessage",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Category, raw.cast_to(types, types))
    
    async def ClassifyMessage2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Category:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ClassifyMessage2",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Category, raw.cast_to(types, types))
    
    async def ClassifyMessage3(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Category:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ClassifyMessage3",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Category, raw.cast_to(types, types))
    
    async def CustomTask(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> Union[types.BookOrder, types.FlightConfirmation, types.GroceryReceipt]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "CustomTask",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Union[types.BookOrder, types.FlightConfirmation, types.GroceryReceipt], raw.cast_to(types, types))
    
    async def DescribeImage(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DescribeImage",
        {
          "img": img,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def DescribeImage2(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DescribeImage2",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def DescribeImage3(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DescribeImage3",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def DescribeImage4(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DescribeImage4",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def DifferentiateUnions(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> Union[types.OriginalA, types.OriginalB]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DifferentiateUnions",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Union[types.OriginalA, types.OriginalB], raw.cast_to(types, types))
    
    async def DummyOutputFunction(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.DummyOutput:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DummyOutputFunction",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.DummyOutput, raw.cast_to(types, types))
    
    async def DynamicFunc(
        self,
        input: types.DynamicClassOne,
        baml_options: BamlCallOptions = {},
    ) -> types.DynamicClassTwo:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DynamicFunc",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.DynamicClassTwo, raw.cast_to(types, types))
    
    async def DynamicInputOutput(
        self,
        input: types.DynInputOutput,
        baml_options: BamlCallOptions = {},
    ) -> types.DynInputOutput:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DynamicInputOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.DynInputOutput, raw.cast_to(types, types))
    
    async def DynamicListInputOutput(
        self,
        input: List[types.DynInputOutput],
        baml_options: BamlCallOptions = {},
    ) -> List[types.DynInputOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "DynamicListInputOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[types.DynInputOutput], raw.cast_to(types, types))
    
    async def ExpectFailure(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExpectFailure",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def ExtractContactInfo(
        self,
        document: str,
        baml_options: BamlCallOptions = {},
    ) -> types.ContactInfo:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractContactInfo",
        {
          "document": document,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.ContactInfo, raw.cast_to(types, types))
    
    async def ExtractHobby(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> List[Union[types.Hobby, str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractHobby",
        {
          "text": text,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[Union[types.Hobby, str]], raw.cast_to(types, types))
    
    async def ExtractNames(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractNames",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[str], raw.cast_to(types, types))
    
    async def ExtractPeople(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Person]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractPeople",
        {
          "text": text,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[types.Person], raw.cast_to(types, types))
    
    async def ExtractReceiptInfo(
        self,
        email: str,reason: Union[Literal["curiosity"], Literal["personal_finance"]],
        baml_options: BamlCallOptions = {},
    ) -> types.ReceiptInfo:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractReceiptInfo",
        {
          "email": email,"reason": reason,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.ReceiptInfo, raw.cast_to(types, types))
    
    async def ExtractResume(
        self,
        resume: str,img: Optional[baml_py.Image],
        baml_options: BamlCallOptions = {},
    ) -> types.Resume:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractResume",
        {
          "resume": resume,"img": img,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Resume, raw.cast_to(types, types))
    
    async def ExtractResume2(
        self,
        resume: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Resume:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ExtractResume2",
        {
          "resume": resume,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Resume, raw.cast_to(types, types))
    
    async def FnClassOptionalOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> Optional[types.ClassOptionalOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnClassOptionalOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Optional[types.ClassOptionalOutput], raw.cast_to(types, types))
    
    async def FnClassOptionalOutput2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> Optional[types.ClassOptionalOutput2]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnClassOptionalOutput2",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Optional[types.ClassOptionalOutput2], raw.cast_to(types, types))
    
    async def FnEnumListOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.EnumOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnEnumListOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[types.EnumOutput], raw.cast_to(types, types))
    
    async def FnEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.EnumOutput:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnEnumOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.EnumOutput, raw.cast_to(types, types))
    
    async def FnNamedArgsSingleStringOptional(
        self,
        myString: Optional[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnNamedArgsSingleStringOptional",
        {
          "myString": myString,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def FnOutputBool(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> bool:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnOutputBool",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(bool, raw.cast_to(types, types))
    
    async def FnOutputClass(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestOutputClass:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnOutputClass",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.TestOutputClass, raw.cast_to(types, types))
    
    async def FnOutputClassList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.TestOutputClass]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnOutputClassList",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[types.TestOutputClass], raw.cast_to(types, types))
    
    async def FnOutputClassNested(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestClassNested:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnOutputClassNested",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.TestClassNested, raw.cast_to(types, types))
    
    async def FnOutputClassWithEnum(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestClassWithEnum:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnOutputClassWithEnum",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.TestClassWithEnum, raw.cast_to(types, types))
    
    async def FnOutputStringList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnOutputStringList",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[str], raw.cast_to(types, types))
    
    async def FnTestAliasedEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestEnum:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnTestAliasedEnumOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.TestEnum, raw.cast_to(types, types))
    
    async def FnTestClassAlias(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestClassAlias:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnTestClassAlias",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.TestClassAlias, raw.cast_to(types, types))
    
    async def FnTestNamedArgsSingleEnum(
        self,
        myArg: types.NamedArgsSingleEnum,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "FnTestNamedArgsSingleEnum",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def GetDataType(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> types.RaysData:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "GetDataType",
        {
          "text": text,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.RaysData, raw.cast_to(types, types))
    
    async def GetOrderInfo(
        self,
        email: types.Email,
        baml_options: BamlCallOptions = {},
    ) -> types.OrderInfo:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "GetOrderInfo",
        {
          "email": email,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.OrderInfo, raw.cast_to(types, types))
    
    async def GetQuery(
        self,
        query: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SearchParams:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "GetQuery",
        {
          "query": query,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.SearchParams, raw.cast_to(types, types))
    
    async def MyFunc(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.DynamicOutput:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "MyFunc",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.DynamicOutput, raw.cast_to(types, types))
    
    async def OptionalTest_Function(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[Optional[types.OptionalTest_ReturnType]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "OptionalTest_Function",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[Optional[types.OptionalTest_ReturnType]], raw.cast_to(types, types))
    
    async def PredictAge(
        self,
        name: str,
        baml_options: BamlCallOptions = {},
    ) -> types.FooAny:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PredictAge",
        {
          "name": name,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.FooAny, raw.cast_to(types, types))
    
    async def PredictAgeBare(
        self,
        inp: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.Checked[int,types.Literal["too_big"]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PredictAgeBare",
        {
          "inp": inp,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(baml_py.Checked[int,types.Literal["too_big"]], raw.cast_to(types, types))
    
    async def PromptTestClaude(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestClaude",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def PromptTestClaudeChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestClaudeChat",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def PromptTestClaudeChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestClaudeChatNoSystem",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def PromptTestOpenAI(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestOpenAI",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def PromptTestOpenAIChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestOpenAIChat",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def PromptTestOpenAIChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestOpenAIChatNoSystem",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def PromptTestStreaming(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "PromptTestStreaming",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def ReturnFailingAssert(
        self,
        inp: int,
        baml_options: BamlCallOptions = {},
    ) -> int:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ReturnFailingAssert",
        {
          "inp": inp,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(int, raw.cast_to(types, types))
    
    async def ReturnMalformedConstraints(
        self,
        a: int,
        baml_options: BamlCallOptions = {},
    ) -> types.MalformedConstraints:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "ReturnMalformedConstraints",
        {
          "a": a,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.MalformedConstraints, raw.cast_to(types, types))
    
    async def SchemaDescriptions(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Schema:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "SchemaDescriptions",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.Schema, raw.cast_to(types, types))
    
    async def StreamBigNumbers(
        self,
        digits: int,
        baml_options: BamlCallOptions = {},
    ) -> types.BigNumbers:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "StreamBigNumbers",
        {
          "digits": digits,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.BigNumbers, raw.cast_to(types, types))
    
    async def StreamFailingAssertion(
        self,
        theme: str,length: int,
        baml_options: BamlCallOptions = {},
    ) -> types.TwoStoriesOneTitle:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "StreamFailingAssertion",
        {
          "theme": theme,"length": length,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.TwoStoriesOneTitle, raw.cast_to(types, types))
    
    async def StreamOneBigNumber(
        self,
        digits: int,
        baml_options: BamlCallOptions = {},
    ) -> int:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "StreamOneBigNumber",
        {
          "digits": digits,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(int, raw.cast_to(types, types))
    
    async def StreamUnionIntegers(
        self,
        digits: int,
        baml_options: BamlCallOptions = {},
    ) -> List[Union[int, str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "StreamUnionIntegers",
        {
          "digits": digits,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(List[Union[int, str]], raw.cast_to(types, types))
    
    async def StreamingCompoundNumbers(
        self,
        digits: int,yapping: bool,
        baml_options: BamlCallOptions = {},
    ) -> types.CompoundBigNumbers:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "StreamingCompoundNumbers",
        {
          "digits": digits,"yapping": yapping,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.CompoundBigNumbers, raw.cast_to(types, types))
    
    async def TestAnthropic(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestAnthropic",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestAnthropicShorthand(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestAnthropicShorthand",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestAws(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestAws",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestAzure(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestAzure",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestCaching(
        self,
        input: str,not_cached: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestCaching",
        {
          "input": input,"not_cached": not_cached,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFallbackClient(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFallbackClient",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFallbackToShorthand(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFallbackToShorthand",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleBool(
        self,
        myBool: bool,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleBool",
        {
          "myBool": myBool,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleClass(
        self,
        myArg: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleClass",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleEnumList(
        self,
        myArg: List[types.NamedArgsSingleEnumList],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleEnumList",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleFloat(
        self,
        myFloat: float,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleFloat",
        {
          "myFloat": myFloat,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleInt(
        self,
        myInt: int,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleInt",
        {
          "myInt": myInt,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleMapStringToClass(
        self,
        myMap: Dict[str, types.StringToClassEntry],
        baml_options: BamlCallOptions = {},
    ) -> Dict[str, types.StringToClassEntry]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleMapStringToClass",
        {
          "myMap": myMap,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Dict[str, types.StringToClassEntry], raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleMapStringToMap(
        self,
        myMap: Dict[str, Dict[str, str]],
        baml_options: BamlCallOptions = {},
    ) -> Dict[str, Dict[str, str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleMapStringToMap",
        {
          "myMap": myMap,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Dict[str, Dict[str, str]], raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleMapStringToString(
        self,
        myMap: Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> Dict[str, str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleMapStringToString",
        {
          "myMap": myMap,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(Dict[str, str], raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleString(
        self,
        myString: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleString",
        {
          "myString": myString,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleStringArray(
        self,
        myStringArray: List[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleStringArray",
        {
          "myStringArray": myStringArray,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestFnNamedArgsSingleStringList(
        self,
        myArg: List[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleStringList",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestGemini(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestGemini",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestImageInput(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestImageInput",
        {
          "img": img,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestImageInputAnthropic(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestImageInputAnthropic",
        {
          "img": img,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestImageListInput(
        self,
        imgs: List[baml_py.Image],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestImageListInput",
        {
          "imgs": imgs,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestMulticlassNamedArgs(
        self,
        myArg: types.NamedArgsSingleClass,myArg2: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestMulticlassNamedArgs",
        {
          "myArg": myArg,"myArg2": myArg2,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestOllama(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestOllama",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestOpenAILegacyProvider(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestOpenAILegacyProvider",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestOpenAIShorthand(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestOpenAIShorthand",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestRetryConstant(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestRetryConstant",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestRetryExponential(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestRetryExponential",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestSingleFallbackClient(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestSingleFallbackClient",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def TestVertex(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "TestVertex",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(str, raw.cast_to(types, types))
    
    async def UnionTest_Function(
        self,
        input: Union[str, bool],
        baml_options: BamlCallOptions = {},
    ) -> types.UnionTest_ReturnType:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "UnionTest_Function",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(types.UnionTest_ReturnType, raw.cast_to(types, types))
    
    async def UseMalformedConstraints(
        self,
        a: types.MalformedConstraints2,
        baml_options: BamlCallOptions = {},
    ) -> int:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = await self.__runtime.call_function(
        "UseMalformedConstraints",
        {
          "a": a,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )
      return cast(int, raw.cast_to(types, types))
    


class BamlStreamClient:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager

    
    def AaaSamOutputFormat(
        self,
        recipe: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.Recipe, types.Recipe]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AaaSamOutputFormat",
        {
          "recipe": recipe,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.Recipe, types.Recipe](
        raw,
        lambda x: cast(partial_types.Recipe, x.cast_to(types, partial_types)),
        lambda x: cast(types.Recipe, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def AliasedInputClass(
        self,
        input: types.InputClass,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AliasedInputClass",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def AliasedInputClass2(
        self,
        input: types.InputClass,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AliasedInputClass2",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def AliasedInputClassNested(
        self,
        input: types.InputClassNested,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AliasedInputClassNested",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def AliasedInputEnum(
        self,
        input: types.AliasedEnum,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AliasedInputEnum",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def AliasedInputList(
        self,
        input: List[types.AliasedEnum],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AliasedInputList",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def AudioInput(
        self,
        aud: baml_py.Audio,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "AudioInput",
        {
          "aud": aud,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ClassifyDynEnumTwo(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[Union[types.DynEnumTwo, str]], Union[types.DynEnumTwo, str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ClassifyDynEnumTwo",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[Union[types.DynEnumTwo, str]], Union[types.DynEnumTwo, str]](
        raw,
        lambda x: cast(Optional[Union[types.DynEnumTwo, str]], x.cast_to(types, partial_types)),
        lambda x: cast(Union[types.DynEnumTwo, str], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ClassifyMessage(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.Category], types.Category]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ClassifyMessage",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[types.Category], types.Category](
        raw,
        lambda x: cast(Optional[types.Category], x.cast_to(types, partial_types)),
        lambda x: cast(types.Category, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ClassifyMessage2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.Category], types.Category]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ClassifyMessage2",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[types.Category], types.Category](
        raw,
        lambda x: cast(Optional[types.Category], x.cast_to(types, partial_types)),
        lambda x: cast(types.Category, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ClassifyMessage3(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.Category], types.Category]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ClassifyMessage3",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[types.Category], types.Category](
        raw,
        lambda x: cast(Optional[types.Category], x.cast_to(types, partial_types)),
        lambda x: cast(types.Category, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def CustomTask(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[Union[partial_types.BookOrder, partial_types.FlightConfirmation, partial_types.GroceryReceipt]], Union[types.BookOrder, types.FlightConfirmation, types.GroceryReceipt]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "CustomTask",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[Union[partial_types.BookOrder, partial_types.FlightConfirmation, partial_types.GroceryReceipt]], Union[types.BookOrder, types.FlightConfirmation, types.GroceryReceipt]](
        raw,
        lambda x: cast(Optional[Union[partial_types.BookOrder, partial_types.FlightConfirmation, partial_types.GroceryReceipt]], x.cast_to(types, partial_types)),
        lambda x: cast(Union[types.BookOrder, types.FlightConfirmation, types.GroceryReceipt], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DescribeImage(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DescribeImage",
        {
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DescribeImage2(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DescribeImage2",
        {
          "classWithImage": classWithImage,
          "img2": img2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DescribeImage3(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DescribeImage3",
        {
          "classWithImage": classWithImage,
          "img2": img2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DescribeImage4(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DescribeImage4",
        {
          "classWithImage": classWithImage,
          "img2": img2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DifferentiateUnions(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[Union[partial_types.OriginalA, partial_types.OriginalB]], Union[types.OriginalA, types.OriginalB]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DifferentiateUnions",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[Union[partial_types.OriginalA, partial_types.OriginalB]], Union[types.OriginalA, types.OriginalB]](
        raw,
        lambda x: cast(Optional[Union[partial_types.OriginalA, partial_types.OriginalB]], x.cast_to(types, partial_types)),
        lambda x: cast(Union[types.OriginalA, types.OriginalB], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DummyOutputFunction(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DummyOutput, types.DummyOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DummyOutputFunction",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.DummyOutput, types.DummyOutput](
        raw,
        lambda x: cast(partial_types.DummyOutput, x.cast_to(types, partial_types)),
        lambda x: cast(types.DummyOutput, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DynamicFunc(
        self,
        input: types.DynamicClassOne,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DynamicClassTwo, types.DynamicClassTwo]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DynamicFunc",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.DynamicClassTwo, types.DynamicClassTwo](
        raw,
        lambda x: cast(partial_types.DynamicClassTwo, x.cast_to(types, partial_types)),
        lambda x: cast(types.DynamicClassTwo, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DynamicInputOutput(
        self,
        input: types.DynInputOutput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DynInputOutput, types.DynInputOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DynamicInputOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.DynInputOutput, types.DynInputOutput](
        raw,
        lambda x: cast(partial_types.DynInputOutput, x.cast_to(types, partial_types)),
        lambda x: cast(types.DynInputOutput, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def DynamicListInputOutput(
        self,
        input: List[types.DynInputOutput],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.DynInputOutput], List[types.DynInputOutput]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "DynamicListInputOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[partial_types.DynInputOutput], List[types.DynInputOutput]](
        raw,
        lambda x: cast(List[partial_types.DynInputOutput], x.cast_to(types, partial_types)),
        lambda x: cast(List[types.DynInputOutput], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExpectFailure(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExpectFailure",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractContactInfo(
        self,
        document: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ContactInfo, types.ContactInfo]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractContactInfo",
        {
          "document": document,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.ContactInfo, types.ContactInfo](
        raw,
        lambda x: cast(partial_types.ContactInfo, x.cast_to(types, partial_types)),
        lambda x: cast(types.ContactInfo, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractHobby(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[Union[types.Hobby, str]]], List[Union[types.Hobby, str]]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractHobby",
        {
          "text": text,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[Optional[Union[types.Hobby, str]]], List[Union[types.Hobby, str]]](
        raw,
        lambda x: cast(List[Optional[Union[types.Hobby, str]]], x.cast_to(types, partial_types)),
        lambda x: cast(List[Union[types.Hobby, str]], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractNames(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[str]], List[str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractNames",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[Optional[str]], List[str]](
        raw,
        lambda x: cast(List[Optional[str]], x.cast_to(types, partial_types)),
        lambda x: cast(List[str], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractPeople(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.Person], List[types.Person]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractPeople",
        {
          "text": text,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[partial_types.Person], List[types.Person]](
        raw,
        lambda x: cast(List[partial_types.Person], x.cast_to(types, partial_types)),
        lambda x: cast(List[types.Person], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractReceiptInfo(
        self,
        email: str,reason: Union[Literal["curiosity"], Literal["personal_finance"]],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ReceiptInfo, types.ReceiptInfo]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractReceiptInfo",
        {
          "email": email,
          "reason": reason,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.ReceiptInfo, types.ReceiptInfo](
        raw,
        lambda x: cast(partial_types.ReceiptInfo, x.cast_to(types, partial_types)),
        lambda x: cast(types.ReceiptInfo, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractResume(
        self,
        resume: str,img: Optional[baml_py.Image],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.Resume, types.Resume]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractResume",
        {
          "resume": resume,
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.Resume, types.Resume](
        raw,
        lambda x: cast(partial_types.Resume, x.cast_to(types, partial_types)),
        lambda x: cast(types.Resume, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ExtractResume2(
        self,
        resume: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.Resume, types.Resume]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ExtractResume2",
        {
          "resume": resume,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.Resume, types.Resume](
        raw,
        lambda x: cast(partial_types.Resume, x.cast_to(types, partial_types)),
        lambda x: cast(types.Resume, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnClassOptionalOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ClassOptionalOutput, Optional[types.ClassOptionalOutput]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnClassOptionalOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.ClassOptionalOutput, Optional[types.ClassOptionalOutput]](
        raw,
        lambda x: cast(partial_types.ClassOptionalOutput, x.cast_to(types, partial_types)),
        lambda x: cast(Optional[types.ClassOptionalOutput], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnClassOptionalOutput2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ClassOptionalOutput2, Optional[types.ClassOptionalOutput2]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnClassOptionalOutput2",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.ClassOptionalOutput2, Optional[types.ClassOptionalOutput2]](
        raw,
        lambda x: cast(partial_types.ClassOptionalOutput2, x.cast_to(types, partial_types)),
        lambda x: cast(Optional[types.ClassOptionalOutput2], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnEnumListOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[types.EnumOutput]], List[types.EnumOutput]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnEnumListOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[Optional[types.EnumOutput]], List[types.EnumOutput]](
        raw,
        lambda x: cast(List[Optional[types.EnumOutput]], x.cast_to(types, partial_types)),
        lambda x: cast(List[types.EnumOutput], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.EnumOutput], types.EnumOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnEnumOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[types.EnumOutput], types.EnumOutput](
        raw,
        lambda x: cast(Optional[types.EnumOutput], x.cast_to(types, partial_types)),
        lambda x: cast(types.EnumOutput, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnNamedArgsSingleStringOptional(
        self,
        myString: Optional[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnNamedArgsSingleStringOptional",
        {
          "myString": myString,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnOutputBool(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[bool], bool]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnOutputBool",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[bool], bool](
        raw,
        lambda x: cast(Optional[bool], x.cast_to(types, partial_types)),
        lambda x: cast(bool, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnOutputClass(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestOutputClass, types.TestOutputClass]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnOutputClass",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.TestOutputClass, types.TestOutputClass](
        raw,
        lambda x: cast(partial_types.TestOutputClass, x.cast_to(types, partial_types)),
        lambda x: cast(types.TestOutputClass, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnOutputClassList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.TestOutputClass], List[types.TestOutputClass]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnOutputClassList",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[partial_types.TestOutputClass], List[types.TestOutputClass]](
        raw,
        lambda x: cast(List[partial_types.TestOutputClass], x.cast_to(types, partial_types)),
        lambda x: cast(List[types.TestOutputClass], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnOutputClassNested(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestClassNested, types.TestClassNested]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnOutputClassNested",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.TestClassNested, types.TestClassNested](
        raw,
        lambda x: cast(partial_types.TestClassNested, x.cast_to(types, partial_types)),
        lambda x: cast(types.TestClassNested, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnOutputClassWithEnum(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestClassWithEnum, types.TestClassWithEnum]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnOutputClassWithEnum",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.TestClassWithEnum, types.TestClassWithEnum](
        raw,
        lambda x: cast(partial_types.TestClassWithEnum, x.cast_to(types, partial_types)),
        lambda x: cast(types.TestClassWithEnum, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnOutputStringList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[str]], List[str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnOutputStringList",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[Optional[str]], List[str]](
        raw,
        lambda x: cast(List[Optional[str]], x.cast_to(types, partial_types)),
        lambda x: cast(List[str], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnTestAliasedEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.TestEnum], types.TestEnum]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnTestAliasedEnumOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[types.TestEnum], types.TestEnum](
        raw,
        lambda x: cast(Optional[types.TestEnum], x.cast_to(types, partial_types)),
        lambda x: cast(types.TestEnum, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnTestClassAlias(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestClassAlias, types.TestClassAlias]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnTestClassAlias",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.TestClassAlias, types.TestClassAlias](
        raw,
        lambda x: cast(partial_types.TestClassAlias, x.cast_to(types, partial_types)),
        lambda x: cast(types.TestClassAlias, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def FnTestNamedArgsSingleEnum(
        self,
        myArg: types.NamedArgsSingleEnum,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "FnTestNamedArgsSingleEnum",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def GetDataType(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.RaysData, types.RaysData]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "GetDataType",
        {
          "text": text,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.RaysData, types.RaysData](
        raw,
        lambda x: cast(partial_types.RaysData, x.cast_to(types, partial_types)),
        lambda x: cast(types.RaysData, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def GetOrderInfo(
        self,
        email: types.Email,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.OrderInfo, types.OrderInfo]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "GetOrderInfo",
        {
          "email": email,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.OrderInfo, types.OrderInfo](
        raw,
        lambda x: cast(partial_types.OrderInfo, x.cast_to(types, partial_types)),
        lambda x: cast(types.OrderInfo, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def GetQuery(
        self,
        query: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SearchParams, types.SearchParams]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "GetQuery",
        {
          "query": query,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.SearchParams, types.SearchParams](
        raw,
        lambda x: cast(partial_types.SearchParams, x.cast_to(types, partial_types)),
        lambda x: cast(types.SearchParams, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def MyFunc(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DynamicOutput, types.DynamicOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "MyFunc",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.DynamicOutput, types.DynamicOutput](
        raw,
        lambda x: cast(partial_types.DynamicOutput, x.cast_to(types, partial_types)),
        lambda x: cast(types.DynamicOutput, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def OptionalTest_Function(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.OptionalTest_ReturnType], List[Optional[types.OptionalTest_ReturnType]]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "OptionalTest_Function",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[partial_types.OptionalTest_ReturnType], List[Optional[types.OptionalTest_ReturnType]]](
        raw,
        lambda x: cast(List[partial_types.OptionalTest_ReturnType], x.cast_to(types, partial_types)),
        lambda x: cast(List[Optional[types.OptionalTest_ReturnType]], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PredictAge(
        self,
        name: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.FooAny, types.FooAny]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PredictAge",
        {
          "name": name,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.FooAny, types.FooAny](
        raw,
        lambda x: cast(partial_types.FooAny, x.cast_to(types, partial_types)),
        lambda x: cast(types.FooAny, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PredictAgeBare(
        self,
        inp: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[baml_py.Checked[Optional[int],types.Literal["too_big"]], baml_py.Checked[int,types.Literal["too_big"]]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PredictAgeBare",
        {
          "inp": inp,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[baml_py.Checked[Optional[int],types.Literal["too_big"]], baml_py.Checked[int,types.Literal["too_big"]]](
        raw,
        lambda x: cast(baml_py.Checked[Optional[int],types.Literal["too_big"]], x.cast_to(types, partial_types)),
        lambda x: cast(baml_py.Checked[int,types.Literal["too_big"]], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestClaude(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestClaude",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestClaudeChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestClaudeChat",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestClaudeChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestClaudeChatNoSystem",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestOpenAI(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestOpenAI",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestOpenAIChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestOpenAIChat",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestOpenAIChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestOpenAIChatNoSystem",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def PromptTestStreaming(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "PromptTestStreaming",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ReturnFailingAssert(
        self,
        inp: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[int], int]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ReturnFailingAssert",
        {
          "inp": inp,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[int], int](
        raw,
        lambda x: cast(Optional[int], x.cast_to(types, partial_types)),
        lambda x: cast(int, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def ReturnMalformedConstraints(
        self,
        a: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.MalformedConstraints, types.MalformedConstraints]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "ReturnMalformedConstraints",
        {
          "a": a,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.MalformedConstraints, types.MalformedConstraints](
        raw,
        lambda x: cast(partial_types.MalformedConstraints, x.cast_to(types, partial_types)),
        lambda x: cast(types.MalformedConstraints, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def SchemaDescriptions(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.Schema, types.Schema]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "SchemaDescriptions",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.Schema, types.Schema](
        raw,
        lambda x: cast(partial_types.Schema, x.cast_to(types, partial_types)),
        lambda x: cast(types.Schema, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def StreamBigNumbers(
        self,
        digits: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.BigNumbers, types.BigNumbers]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "StreamBigNumbers",
        {
          "digits": digits,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.BigNumbers, types.BigNumbers](
        raw,
        lambda x: cast(partial_types.BigNumbers, x.cast_to(types, partial_types)),
        lambda x: cast(types.BigNumbers, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def StreamFailingAssertion(
        self,
        theme: str,length: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TwoStoriesOneTitle, types.TwoStoriesOneTitle]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "StreamFailingAssertion",
        {
          "theme": theme,
          "length": length,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.TwoStoriesOneTitle, types.TwoStoriesOneTitle](
        raw,
        lambda x: cast(partial_types.TwoStoriesOneTitle, x.cast_to(types, partial_types)),
        lambda x: cast(types.TwoStoriesOneTitle, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def StreamOneBigNumber(
        self,
        digits: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[int], int]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "StreamOneBigNumber",
        {
          "digits": digits,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[int], int](
        raw,
        lambda x: cast(Optional[int], x.cast_to(types, partial_types)),
        lambda x: cast(int, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def StreamUnionIntegers(
        self,
        digits: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[Union[Optional[int], Optional[str]]]], List[Union[int, str]]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "StreamUnionIntegers",
        {
          "digits": digits,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[List[Optional[Union[Optional[int], Optional[str]]]], List[Union[int, str]]](
        raw,
        lambda x: cast(List[Optional[Union[Optional[int], Optional[str]]]], x.cast_to(types, partial_types)),
        lambda x: cast(List[Union[int, str]], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def StreamingCompoundNumbers(
        self,
        digits: int,yapping: bool,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.CompoundBigNumbers, types.CompoundBigNumbers]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "StreamingCompoundNumbers",
        {
          "digits": digits,
          "yapping": yapping,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.CompoundBigNumbers, types.CompoundBigNumbers](
        raw,
        lambda x: cast(partial_types.CompoundBigNumbers, x.cast_to(types, partial_types)),
        lambda x: cast(types.CompoundBigNumbers, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestAnthropic(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestAnthropic",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestAnthropicShorthand(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestAnthropicShorthand",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestAws(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestAws",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestAzure(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestAzure",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestCaching(
        self,
        input: str,not_cached: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestCaching",
        {
          "input": input,
          "not_cached": not_cached,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFallbackClient(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFallbackClient",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFallbackToShorthand(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFallbackToShorthand",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleBool(
        self,
        myBool: bool,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleBool",
        {
          "myBool": myBool,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleClass(
        self,
        myArg: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleClass",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleEnumList(
        self,
        myArg: List[types.NamedArgsSingleEnumList],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleEnumList",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleFloat(
        self,
        myFloat: float,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleFloat",
        {
          "myFloat": myFloat,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleInt(
        self,
        myInt: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleInt",
        {
          "myInt": myInt,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleMapStringToClass(
        self,
        myMap: Dict[str, types.StringToClassEntry],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Dict[str, partial_types.StringToClassEntry], Dict[str, types.StringToClassEntry]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToClass",
        {
          "myMap": myMap,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Dict[str, partial_types.StringToClassEntry], Dict[str, types.StringToClassEntry]](
        raw,
        lambda x: cast(Dict[str, partial_types.StringToClassEntry], x.cast_to(types, partial_types)),
        lambda x: cast(Dict[str, types.StringToClassEntry], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleMapStringToMap(
        self,
        myMap: Dict[str, Dict[str, str]],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Dict[str, Dict[str, Optional[str]]], Dict[str, Dict[str, str]]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToMap",
        {
          "myMap": myMap,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Dict[str, Dict[str, Optional[str]]], Dict[str, Dict[str, str]]](
        raw,
        lambda x: cast(Dict[str, Dict[str, Optional[str]]], x.cast_to(types, partial_types)),
        lambda x: cast(Dict[str, Dict[str, str]], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleMapStringToString(
        self,
        myMap: Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Dict[str, Optional[str]], Dict[str, str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleMapStringToString",
        {
          "myMap": myMap,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Dict[str, Optional[str]], Dict[str, str]](
        raw,
        lambda x: cast(Dict[str, Optional[str]], x.cast_to(types, partial_types)),
        lambda x: cast(Dict[str, str], x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleString(
        self,
        myString: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleString",
        {
          "myString": myString,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleStringArray(
        self,
        myStringArray: List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleStringArray",
        {
          "myStringArray": myStringArray,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestFnNamedArgsSingleStringList(
        self,
        myArg: List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleStringList",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestGemini(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestGemini",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestImageInput(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestImageInput",
        {
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestImageInputAnthropic(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestImageInputAnthropic",
        {
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestImageListInput(
        self,
        imgs: List[baml_py.Image],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestImageListInput",
        {
          "imgs": imgs,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestMulticlassNamedArgs(
        self,
        myArg: types.NamedArgsSingleClass,myArg2: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestMulticlassNamedArgs",
        {
          "myArg": myArg,
          "myArg2": myArg2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestOllama(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestOllama",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestOpenAILegacyProvider(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestOpenAILegacyProvider",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestOpenAIShorthand(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestOpenAIShorthand",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestRetryConstant(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestRetryConstant",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestRetryExponential(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestRetryExponential",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestSingleFallbackClient(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestSingleFallbackClient",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def TestVertex(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "TestVertex",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: cast(Optional[str], x.cast_to(types, partial_types)),
        lambda x: cast(str, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def UnionTest_Function(
        self,
        input: Union[str, bool],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.UnionTest_ReturnType, types.UnionTest_ReturnType]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "UnionTest_Function",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[partial_types.UnionTest_ReturnType, types.UnionTest_ReturnType](
        raw,
        lambda x: cast(partial_types.UnionTest_ReturnType, x.cast_to(types, partial_types)),
        lambda x: cast(types.UnionTest_ReturnType, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    
    def UseMalformedConstraints(
        self,
        a: types.MalformedConstraints2,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[int], int]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      raw = self.__runtime.stream_function(
        "UseMalformedConstraints",
        {
          "a": a,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return baml_py.BamlStream[Optional[int], int](
        raw,
        lambda x: cast(Optional[int], x.cast_to(types, partial_types)),
        lambda x: cast(int, x.cast_to(types, types)),
        self.__ctx_manager.get(),
      )
    

b = BamlAsyncClient(DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX)

__all__ = ["b"]