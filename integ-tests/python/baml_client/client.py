###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
from typing import Any, List, Optional, TypeVar, Union, TypedDict, Type
from typing_extensions import NotRequired
import pprint

import baml_py
from pydantic import BaseModel, ValidationError, create_model

from . import partial_types, types
from .type_builder import TypeBuilder

OutputType = TypeVar('OutputType')

def coerce(cls: Type[BaseModel], parsed: Any) -> Any:
  try:
    return cls.model_validate({"inner": parsed}).inner # type: ignore
  except ValidationError as e:
    raise TypeError(
      "Internal BAML error while casting output to {}\n{}".format(
        cls.__name__,
        pprint.pformat(parsed)
      )
    ) from e

# Define the TypedDict with optional parameters having default values
class BamlCallOptions(TypedDict, total=False):
    tb: NotRequired[TypeBuilder]

class BamlClient:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager
    __stream_client: "BamlStreamClient"

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager
      self.__stream_client = BamlStreamClient(self.__runtime, self.__ctx_manager)

    @property
    def stream(self):
      return self.__stream_client

    
    async def ClassifyMessage(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Category:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ClassifyMessage",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ClassifyMessageReturnType", inner=(types.Category, ...))
      return coerce(mdl, raw.parsed())
    
    async def ClassifyMessage2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Category:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ClassifyMessage2",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ClassifyMessage2ReturnType", inner=(types.Category, ...))
      return coerce(mdl, raw.parsed())
    
    async def ClassifyMessage3(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Category:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ClassifyMessage3",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ClassifyMessage3ReturnType", inner=(types.Category, ...))
      return coerce(mdl, raw.parsed())
    
    async def DescribeImage(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "DescribeImage",
        {
          "img": img,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("DescribeImageReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def DescribeImage2(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "DescribeImage2",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("DescribeImage2ReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def DescribeImage3(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "DescribeImage3",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("DescribeImage3ReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def DescribeImage4(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "DescribeImage4",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("DescribeImage4ReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def DynamicFunc(
        self,
        input: types.DynamicClassOne,
        baml_options: BamlCallOptions = {},
    ) -> types.DynamicClassTwo:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "DynamicFunc",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("DynamicFuncReturnType", inner=(types.DynamicClassTwo, ...))
      return coerce(mdl, raw.parsed())
    
    async def ExtractNames(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ExtractNames",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ExtractNamesReturnType", inner=(List[str], ...))
      return coerce(mdl, raw.parsed())
    
    async def ExtractPeople(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Person]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ExtractPeople",
        {
          "text": text,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ExtractPeopleReturnType", inner=(List[types.Person], ...))
      return coerce(mdl, raw.parsed())
    
    async def ExtractResume(
        self,
        resume: str,img: Optional[baml_py.Image],
        baml_options: BamlCallOptions = {},
    ) -> types.Resume:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ExtractResume",
        {
          "resume": resume,"img": img,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ExtractResumeReturnType", inner=(types.Resume, ...))
      return coerce(mdl, raw.parsed())
    
    async def ExtractResume2(
        self,
        resume: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Resume:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "ExtractResume2",
        {
          "resume": resume,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("ExtractResume2ReturnType", inner=(types.Resume, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnClassOptionalOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> Optional[types.ClassOptionalOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnClassOptionalOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnClassOptionalOutputReturnType", inner=(Optional[types.ClassOptionalOutput], ...))
      return coerce(mdl, raw.parsed())
    
    async def FnClassOptionalOutput2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> Optional[types.ClassOptionalOutput2]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnClassOptionalOutput2",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnClassOptionalOutput2ReturnType", inner=(Optional[types.ClassOptionalOutput2], ...))
      return coerce(mdl, raw.parsed())
    
    async def FnEnumListOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.EnumOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnEnumListOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnEnumListOutputReturnType", inner=(List[types.EnumOutput], ...))
      return coerce(mdl, raw.parsed())
    
    async def FnEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.EnumOutput:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnEnumOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnEnumOutputReturnType", inner=(types.EnumOutput, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnNamedArgsSingleStringOptional(
        self,
        myString: Optional[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnNamedArgsSingleStringOptional",
        {
          "myString": myString,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnNamedArgsSingleStringOptionalReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnOutputBool(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> bool:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnOutputBool",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnOutputBoolReturnType", inner=(bool, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnOutputClass(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestOutputClass:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnOutputClass",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnOutputClassReturnType", inner=(types.TestOutputClass, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnOutputClassList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.TestOutputClass]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnOutputClassList",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnOutputClassListReturnType", inner=(List[types.TestOutputClass], ...))
      return coerce(mdl, raw.parsed())
    
    async def FnOutputClassWithEnum(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestClassWithEnum:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnOutputClassWithEnum",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnOutputClassWithEnumReturnType", inner=(types.TestClassWithEnum, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnOutputNestedClass(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestOutputClassNested:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnOutputNestedClass",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnOutputNestedClassReturnType", inner=(types.TestOutputClassNested, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnOutputStringList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnOutputStringList",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnOutputStringListReturnType", inner=(List[str], ...))
      return coerce(mdl, raw.parsed())
    
    async def FnTestAliasedEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestEnum:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnTestAliasedEnumOutput",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnTestAliasedEnumOutputReturnType", inner=(types.TestEnum, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnTestClassAlias(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TestClassAlias:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnTestClassAlias",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnTestClassAliasReturnType", inner=(types.TestClassAlias, ...))
      return coerce(mdl, raw.parsed())
    
    async def FnTestNamedArgsSingleEnum(
        self,
        myArg: types.NamedArgsSingleEnum,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "FnTestNamedArgsSingleEnum",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("FnTestNamedArgsSingleEnumReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def GetDataType(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> types.RaysData:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "GetDataType",
        {
          "text": text,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("GetDataTypeReturnType", inner=(types.RaysData, ...))
      return coerce(mdl, raw.parsed())
    
    async def GetOrderInfo(
        self,
        email: types.Email,
        baml_options: BamlCallOptions = {},
    ) -> types.OrderInfo:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "GetOrderInfo",
        {
          "email": email,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("GetOrderInfoReturnType", inner=(types.OrderInfo, ...))
      return coerce(mdl, raw.parsed())
    
    async def GetQuery(
        self,
        query: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SearchParams:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "GetQuery",
        {
          "query": query,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("GetQueryReturnType", inner=(types.SearchParams, ...))
      return coerce(mdl, raw.parsed())
    
    async def MyFunc(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.DynamicOutput:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "MyFunc",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("MyFuncReturnType", inner=(types.DynamicOutput, ...))
      return coerce(mdl, raw.parsed())
    
    async def OptionalTest_Function(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> List[Optional[types.OptionalTest_ReturnType]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "OptionalTest_Function",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("OptionalTest_FunctionReturnType", inner=(List[Optional[types.OptionalTest_ReturnType]], ...))
      return coerce(mdl, raw.parsed())
    
    async def PromptTestClaude(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "PromptTestClaude",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("PromptTestClaudeReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def PromptTestClaudeChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "PromptTestClaudeChat",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("PromptTestClaudeChatReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def PromptTestClaudeChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "PromptTestClaudeChatNoSystem",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("PromptTestClaudeChatNoSystemReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def PromptTestOpenAI(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "PromptTestOpenAI",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("PromptTestOpenAIReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def PromptTestOpenAIChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "PromptTestOpenAIChat",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("PromptTestOpenAIChatReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def PromptTestOpenAIChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "PromptTestOpenAIChatNoSystem",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("PromptTestOpenAIChatNoSystemReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFallbackClient(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFallbackClient",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFallbackClientReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleBool(
        self,
        myBool: bool,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleBool",
        {
          "myBool": myBool,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleBoolReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleClass(
        self,
        myArg: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleClass",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleClassReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleEnumList(
        self,
        myArg: List[types.NamedArgsSingleEnumList],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleEnumList",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleEnumListReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleFloat(
        self,
        myFloat: float,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleFloat",
        {
          "myFloat": myFloat,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleFloatReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleInt(
        self,
        myInt: int,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleInt",
        {
          "myInt": myInt,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleIntReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleString(
        self,
        myString: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleString",
        {
          "myString": myString,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleStringReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleStringArray(
        self,
        myStringArray: List[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleStringArray",
        {
          "myStringArray": myStringArray,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleStringArrayReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestFnNamedArgsSingleStringList(
        self,
        myArg: List[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestFnNamedArgsSingleStringList",
        {
          "myArg": myArg,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestFnNamedArgsSingleStringListReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestImageInput(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestImageInput",
        {
          "img": img,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestImageInputReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestMulticlassNamedArgs(
        self,
        myArg: types.NamedArgsSingleClass,myArg2: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestMulticlassNamedArgs",
        {
          "myArg": myArg,"myArg2": myArg2,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestMulticlassNamedArgsReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestOllama(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestOllama",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestOllamaReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestRetryConstant(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestRetryConstant",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestRetryConstantReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def TestRetryExponential(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> str:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "TestRetryExponential",
        {
          
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("TestRetryExponentialReturnType", inner=(str, ...))
      return coerce(mdl, raw.parsed())
    
    async def UnionTest_Function(
        self,
        input: Union[str, bool],
        baml_options: BamlCallOptions = {},
    ) -> types.UnionTest_ReturnType:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = await self.__runtime.call_function(
        "UnionTest_Function",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
      )
      mdl = create_model("UnionTest_FunctionReturnType", inner=(types.UnionTest_ReturnType, ...))
      return coerce(mdl, raw.parsed())
    

class BamlStreamClient:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager

    
    def ClassifyMessage(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.Category], types.Category]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ClassifyMessage",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ClassifyMessageReturnType", inner=(types.Category, ...))
      partial_mdl = create_model("ClassifyMessagePartialReturnType", inner=(Optional[types.Category], ...))

      return baml_py.BamlStream[Optional[types.Category], types.Category](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def ClassifyMessage2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.Category], types.Category]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ClassifyMessage2",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ClassifyMessage2ReturnType", inner=(types.Category, ...))
      partial_mdl = create_model("ClassifyMessage2PartialReturnType", inner=(Optional[types.Category], ...))

      return baml_py.BamlStream[Optional[types.Category], types.Category](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def ClassifyMessage3(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.Category], types.Category]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ClassifyMessage3",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ClassifyMessage3ReturnType", inner=(types.Category, ...))
      partial_mdl = create_model("ClassifyMessage3PartialReturnType", inner=(Optional[types.Category], ...))

      return baml_py.BamlStream[Optional[types.Category], types.Category](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def DescribeImage(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "DescribeImage",
        {
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("DescribeImageReturnType", inner=(str, ...))
      partial_mdl = create_model("DescribeImagePartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def DescribeImage2(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "DescribeImage2",
        {
          "classWithImage": classWithImage,
          "img2": img2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("DescribeImage2ReturnType", inner=(str, ...))
      partial_mdl = create_model("DescribeImage2PartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def DescribeImage3(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "DescribeImage3",
        {
          "classWithImage": classWithImage,
          "img2": img2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("DescribeImage3ReturnType", inner=(str, ...))
      partial_mdl = create_model("DescribeImage3PartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def DescribeImage4(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "DescribeImage4",
        {
          "classWithImage": classWithImage,
          "img2": img2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("DescribeImage4ReturnType", inner=(str, ...))
      partial_mdl = create_model("DescribeImage4PartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def DynamicFunc(
        self,
        input: types.DynamicClassOne,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DynamicClassTwo, types.DynamicClassTwo]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "DynamicFunc",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("DynamicFuncReturnType", inner=(types.DynamicClassTwo, ...))
      partial_mdl = create_model("DynamicFuncPartialReturnType", inner=(partial_types.DynamicClassTwo, ...))

      return baml_py.BamlStream[partial_types.DynamicClassTwo, types.DynamicClassTwo](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def ExtractNames(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[str]], List[str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ExtractNames",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ExtractNamesReturnType", inner=(List[str], ...))
      partial_mdl = create_model("ExtractNamesPartialReturnType", inner=(List[Optional[str]], ...))

      return baml_py.BamlStream[List[Optional[str]], List[str]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def ExtractPeople(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.Person], List[types.Person]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ExtractPeople",
        {
          "text": text,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ExtractPeopleReturnType", inner=(List[types.Person], ...))
      partial_mdl = create_model("ExtractPeoplePartialReturnType", inner=(List[partial_types.Person], ...))

      return baml_py.BamlStream[List[partial_types.Person], List[types.Person]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def ExtractResume(
        self,
        resume: str,img: Optional[baml_py.Image],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.Resume, types.Resume]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ExtractResume",
        {
          "resume": resume,
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ExtractResumeReturnType", inner=(types.Resume, ...))
      partial_mdl = create_model("ExtractResumePartialReturnType", inner=(partial_types.Resume, ...))

      return baml_py.BamlStream[partial_types.Resume, types.Resume](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def ExtractResume2(
        self,
        resume: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.Resume, types.Resume]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "ExtractResume2",
        {
          "resume": resume,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("ExtractResume2ReturnType", inner=(types.Resume, ...))
      partial_mdl = create_model("ExtractResume2PartialReturnType", inner=(partial_types.Resume, ...))

      return baml_py.BamlStream[partial_types.Resume, types.Resume](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnClassOptionalOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ClassOptionalOutput, Optional[types.ClassOptionalOutput]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnClassOptionalOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnClassOptionalOutputReturnType", inner=(Optional[types.ClassOptionalOutput], ...))
      partial_mdl = create_model("FnClassOptionalOutputPartialReturnType", inner=(partial_types.ClassOptionalOutput, ...))

      return baml_py.BamlStream[partial_types.ClassOptionalOutput, Optional[types.ClassOptionalOutput]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnClassOptionalOutput2(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ClassOptionalOutput2, Optional[types.ClassOptionalOutput2]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnClassOptionalOutput2",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnClassOptionalOutput2ReturnType", inner=(Optional[types.ClassOptionalOutput2], ...))
      partial_mdl = create_model("FnClassOptionalOutput2PartialReturnType", inner=(partial_types.ClassOptionalOutput2, ...))

      return baml_py.BamlStream[partial_types.ClassOptionalOutput2, Optional[types.ClassOptionalOutput2]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnEnumListOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[types.EnumOutput]], List[types.EnumOutput]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnEnumListOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnEnumListOutputReturnType", inner=(List[types.EnumOutput], ...))
      partial_mdl = create_model("FnEnumListOutputPartialReturnType", inner=(List[Optional[types.EnumOutput]], ...))

      return baml_py.BamlStream[List[Optional[types.EnumOutput]], List[types.EnumOutput]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.EnumOutput], types.EnumOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnEnumOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnEnumOutputReturnType", inner=(types.EnumOutput, ...))
      partial_mdl = create_model("FnEnumOutputPartialReturnType", inner=(Optional[types.EnumOutput], ...))

      return baml_py.BamlStream[Optional[types.EnumOutput], types.EnumOutput](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnNamedArgsSingleStringOptional(
        self,
        myString: Optional[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnNamedArgsSingleStringOptional",
        {
          "myString": myString,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnNamedArgsSingleStringOptionalReturnType", inner=(str, ...))
      partial_mdl = create_model("FnNamedArgsSingleStringOptionalPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnOutputBool(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[bool], bool]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnOutputBool",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnOutputBoolReturnType", inner=(bool, ...))
      partial_mdl = create_model("FnOutputBoolPartialReturnType", inner=(Optional[bool], ...))

      return baml_py.BamlStream[Optional[bool], bool](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnOutputClass(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestOutputClass, types.TestOutputClass]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnOutputClass",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnOutputClassReturnType", inner=(types.TestOutputClass, ...))
      partial_mdl = create_model("FnOutputClassPartialReturnType", inner=(partial_types.TestOutputClass, ...))

      return baml_py.BamlStream[partial_types.TestOutputClass, types.TestOutputClass](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnOutputClassList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.TestOutputClass], List[types.TestOutputClass]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnOutputClassList",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnOutputClassListReturnType", inner=(List[types.TestOutputClass], ...))
      partial_mdl = create_model("FnOutputClassListPartialReturnType", inner=(List[partial_types.TestOutputClass], ...))

      return baml_py.BamlStream[List[partial_types.TestOutputClass], List[types.TestOutputClass]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnOutputClassWithEnum(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestClassWithEnum, types.TestClassWithEnum]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnOutputClassWithEnum",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnOutputClassWithEnumReturnType", inner=(types.TestClassWithEnum, ...))
      partial_mdl = create_model("FnOutputClassWithEnumPartialReturnType", inner=(partial_types.TestClassWithEnum, ...))

      return baml_py.BamlStream[partial_types.TestClassWithEnum, types.TestClassWithEnum](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnOutputNestedClass(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestOutputClassNested, types.TestOutputClassNested]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnOutputNestedClass",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnOutputNestedClassReturnType", inner=(types.TestOutputClassNested, ...))
      partial_mdl = create_model("FnOutputNestedClassPartialReturnType", inner=(partial_types.TestOutputClassNested, ...))

      return baml_py.BamlStream[partial_types.TestOutputClassNested, types.TestOutputClassNested](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnOutputStringList(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[Optional[str]], List[str]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnOutputStringList",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnOutputStringListReturnType", inner=(List[str], ...))
      partial_mdl = create_model("FnOutputStringListPartialReturnType", inner=(List[Optional[str]], ...))

      return baml_py.BamlStream[List[Optional[str]], List[str]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnTestAliasedEnumOutput(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[types.TestEnum], types.TestEnum]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnTestAliasedEnumOutput",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnTestAliasedEnumOutputReturnType", inner=(types.TestEnum, ...))
      partial_mdl = create_model("FnTestAliasedEnumOutputPartialReturnType", inner=(Optional[types.TestEnum], ...))

      return baml_py.BamlStream[Optional[types.TestEnum], types.TestEnum](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnTestClassAlias(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TestClassAlias, types.TestClassAlias]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnTestClassAlias",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnTestClassAliasReturnType", inner=(types.TestClassAlias, ...))
      partial_mdl = create_model("FnTestClassAliasPartialReturnType", inner=(partial_types.TestClassAlias, ...))

      return baml_py.BamlStream[partial_types.TestClassAlias, types.TestClassAlias](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def FnTestNamedArgsSingleEnum(
        self,
        myArg: types.NamedArgsSingleEnum,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "FnTestNamedArgsSingleEnum",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("FnTestNamedArgsSingleEnumReturnType", inner=(str, ...))
      partial_mdl = create_model("FnTestNamedArgsSingleEnumPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def GetDataType(
        self,
        text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.RaysData, types.RaysData]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "GetDataType",
        {
          "text": text,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("GetDataTypeReturnType", inner=(types.RaysData, ...))
      partial_mdl = create_model("GetDataTypePartialReturnType", inner=(partial_types.RaysData, ...))

      return baml_py.BamlStream[partial_types.RaysData, types.RaysData](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def GetOrderInfo(
        self,
        email: types.Email,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.OrderInfo, types.OrderInfo]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "GetOrderInfo",
        {
          "email": email,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("GetOrderInfoReturnType", inner=(types.OrderInfo, ...))
      partial_mdl = create_model("GetOrderInfoPartialReturnType", inner=(partial_types.OrderInfo, ...))

      return baml_py.BamlStream[partial_types.OrderInfo, types.OrderInfo](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def GetQuery(
        self,
        query: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SearchParams, types.SearchParams]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "GetQuery",
        {
          "query": query,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("GetQueryReturnType", inner=(types.SearchParams, ...))
      partial_mdl = create_model("GetQueryPartialReturnType", inner=(partial_types.SearchParams, ...))

      return baml_py.BamlStream[partial_types.SearchParams, types.SearchParams](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def MyFunc(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DynamicOutput, types.DynamicOutput]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "MyFunc",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("MyFuncReturnType", inner=(types.DynamicOutput, ...))
      partial_mdl = create_model("MyFuncPartialReturnType", inner=(partial_types.DynamicOutput, ...))

      return baml_py.BamlStream[partial_types.DynamicOutput, types.DynamicOutput](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def OptionalTest_Function(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[List[partial_types.OptionalTest_ReturnType], List[Optional[types.OptionalTest_ReturnType]]]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "OptionalTest_Function",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("OptionalTest_FunctionReturnType", inner=(List[Optional[types.OptionalTest_ReturnType]], ...))
      partial_mdl = create_model("OptionalTest_FunctionPartialReturnType", inner=(List[partial_types.OptionalTest_ReturnType], ...))

      return baml_py.BamlStream[List[partial_types.OptionalTest_ReturnType], List[Optional[types.OptionalTest_ReturnType]]](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def PromptTestClaude(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "PromptTestClaude",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("PromptTestClaudeReturnType", inner=(str, ...))
      partial_mdl = create_model("PromptTestClaudePartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def PromptTestClaudeChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "PromptTestClaudeChat",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("PromptTestClaudeChatReturnType", inner=(str, ...))
      partial_mdl = create_model("PromptTestClaudeChatPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def PromptTestClaudeChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "PromptTestClaudeChatNoSystem",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("PromptTestClaudeChatNoSystemReturnType", inner=(str, ...))
      partial_mdl = create_model("PromptTestClaudeChatNoSystemPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def PromptTestOpenAI(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "PromptTestOpenAI",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("PromptTestOpenAIReturnType", inner=(str, ...))
      partial_mdl = create_model("PromptTestOpenAIPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def PromptTestOpenAIChat(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "PromptTestOpenAIChat",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("PromptTestOpenAIChatReturnType", inner=(str, ...))
      partial_mdl = create_model("PromptTestOpenAIChatPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def PromptTestOpenAIChatNoSystem(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "PromptTestOpenAIChatNoSystem",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("PromptTestOpenAIChatNoSystemReturnType", inner=(str, ...))
      partial_mdl = create_model("PromptTestOpenAIChatNoSystemPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFallbackClient(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFallbackClient",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFallbackClientReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFallbackClientPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleBool(
        self,
        myBool: bool,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleBool",
        {
          "myBool": myBool,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleBoolReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleBoolPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleClass(
        self,
        myArg: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleClass",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleClassReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleClassPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleEnumList(
        self,
        myArg: List[types.NamedArgsSingleEnumList],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleEnumList",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleEnumListReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleEnumListPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleFloat(
        self,
        myFloat: float,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleFloat",
        {
          "myFloat": myFloat,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleFloatReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleFloatPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleInt(
        self,
        myInt: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleInt",
        {
          "myInt": myInt,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleIntReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleIntPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleString(
        self,
        myString: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleString",
        {
          "myString": myString,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleStringReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleStringPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleStringArray(
        self,
        myStringArray: List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleStringArray",
        {
          "myStringArray": myStringArray,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleStringArrayReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleStringArrayPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestFnNamedArgsSingleStringList(
        self,
        myArg: List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestFnNamedArgsSingleStringList",
        {
          "myArg": myArg,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestFnNamedArgsSingleStringListReturnType", inner=(str, ...))
      partial_mdl = create_model("TestFnNamedArgsSingleStringListPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestImageInput(
        self,
        img: baml_py.Image,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestImageInput",
        {
          "img": img,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestImageInputReturnType", inner=(str, ...))
      partial_mdl = create_model("TestImageInputPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestMulticlassNamedArgs(
        self,
        myArg: types.NamedArgsSingleClass,myArg2: types.NamedArgsSingleClass,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestMulticlassNamedArgs",
        {
          "myArg": myArg,
          "myArg2": myArg2,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestMulticlassNamedArgsReturnType", inner=(str, ...))
      partial_mdl = create_model("TestMulticlassNamedArgsPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestOllama(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestOllama",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestOllamaReturnType", inner=(str, ...))
      partial_mdl = create_model("TestOllamaPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestRetryConstant(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestRetryConstant",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestRetryConstantReturnType", inner=(str, ...))
      partial_mdl = create_model("TestRetryConstantPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def TestRetryExponential(
        self,
        
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[Optional[str], str]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "TestRetryExponential",
        {
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("TestRetryExponentialReturnType", inner=(str, ...))
      partial_mdl = create_model("TestRetryExponentialPartialReturnType", inner=(Optional[str], ...))

      return baml_py.BamlStream[Optional[str], str](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    
    def UnionTest_Function(
        self,
        input: Union[str, bool],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.UnionTest_ReturnType, types.UnionTest_ReturnType]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb
      else:
        tb = None

      raw = self.__runtime.stream_function(
        "UnionTest_Function",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
      )

      mdl = create_model("UnionTest_FunctionReturnType", inner=(types.UnionTest_ReturnType, ...))
      partial_mdl = create_model("UnionTest_FunctionPartialReturnType", inner=(partial_types.UnionTest_ReturnType, ...))

      return baml_py.BamlStream[partial_types.UnionTest_ReturnType, types.UnionTest_ReturnType](
        raw,
        lambda x: coerce(partial_mdl, x),
        lambda x: coerce(mdl, x),
        self.__ctx_manager.get(),
        tb,
      )
    