###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import baml_py
from enum import Enum
from pydantic import BaseModel
from typing import List, Optional, Union

from . import types

###############################################################################
#
#  These types are used for streaming, for when an instance of a type
#  is still being built up and any of its fields is not yet fully available.
#
###############################################################################


class Blah(BaseModel):
    prop4: Optional[str]

class Blah2(BaseModel):
    prop4: Optional[str]

class ClassOptionalFields(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class ClassOptionalFieldsv2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class ClassOptionalOutput(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class ClassOptionalOutput2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]
    prop3: "Blah"

class ClassOptionalOutput2v2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]
    prop3: "Blah2"

class ClassWithImage(BaseModel):
    myImage: Optional[baml_py.Image]
    param2: Optional[str]
    fake_image: "FakeImage"

class DynamicPropsClass(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]
    prop3: Optional[int]

class Email(BaseModel):
    subject: Optional[str]
    body: Optional[str]
    from_address: Optional[str]

class Event(BaseModel):
    title: Optional[str]
    date: Optional[str]
    location: Optional[str]
    description: Optional[str]

class FakeImage(BaseModel):
    url: Optional[str]

class ModifiedOutput(BaseModel):
    reasoning: Optional[str]
    answer: Optional[str]

class NamedArgsSingleClass(BaseModel):
    key: Optional[str]
    key_two: Optional[bool]
    key_three: Optional[int]

class NamedArgsSingleClass2(BaseModel):
    key: Optional[str]
    key_two: Optional[bool]
    key_three: Optional[int]

class NamedArgsSingleClassList2(BaseModel):
    key: Optional[str]
    key_two: Optional[bool]
    key_three: Optional[int]

class OptionalClass(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class OptionalClassv2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class OptionalTest_Prop1(BaseModel):
    omega_a: Optional[str]
    omega_b: Optional[int]

class OptionalTest_Prop1v2(BaseModel):
    omega_a: Optional[str]
    omega_b: Optional[int]

class OptionalTest_ReturnType(BaseModel):
    omega_1: "OptionalTest_Prop1"
    omega_2: Optional[str]
    omega_3: List[Optional[types.OptionalTest_CategoryType]]

class OptionalTest_ReturnTypev2(BaseModel):
    omega_1: "OptionalTest_Prop1v2"
    omega_2: Optional[str]
    omega_3: List[Optional[types.OptionalTest_CategoryTypev2]]

class OrderInfo(BaseModel):
    order_status: Optional[types.OrderStatus]
    tracking_number: Optional[str]
    estimated_arrival_date: Optional[str]

class OverrideClass(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class RaysData(BaseModel):
    dataType: Optional[types.DataType]
    value: Optional[Union["Resume", "Event"]]

class Resume(BaseModel):
    name: Optional[str]
    email: Optional[str]
    phone: Optional[str]
    experience: List[Optional[str]]
    education: List[Optional[str]]
    skills: List[Optional[str]]

class SearchParams(BaseModel):
    dateRange: Optional[int]
    location: List[Optional[str]]
    jobTitle: "WithReasoning"
    company: "WithReasoning"
    description: List["WithReasoning"]
    tags: List[Optional[Union[Optional[types.Tag], Optional[str]]]]

class SomeClass2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[str]

class TestClassAlias(BaseModel):
    key: Optional[str]
    key2: Optional[str]
    key3: Optional[str]
    key4: Optional[str]
    key5: Optional[str]

class TestClassWithEnum(BaseModel):
    prop1: Optional[str]
    prop2: Optional[types.EnumInClass]

class TestClassWithEnum2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[types.EnumInClass]

class TestOutputClass(BaseModel):
    prop1: Optional[str]
    prop2: Optional[int]

class TestOutputClass2(BaseModel):
    prop1: Optional[str]
    prop2: Optional[int]

class UnionTest_ReturnType(BaseModel):
    prop1: Optional[Union[Optional[str], Optional[bool]]]
    prop2: List[Optional[Union[Optional[float], Optional[bool]]]]
    prop3: Optional[Union[List[Optional[float]], List[Optional[bool]]]]

class UnionTest_ReturnTypev2(BaseModel):
    prop1: Optional[Union[Optional[str], Optional[bool]]]
    prop2: List[Optional[Union[Optional[float], Optional[bool]]]]
    prop3: Optional[Union[List[Optional[float]], List[Optional[bool]]]]

class WithReasoning(BaseModel):
    value: Optional[str]
    reasoning: Optional[str]
