###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.type_builder import FieldType, TypeBuilder as _TypeBuilder, ClassPropertyBuilder, EnumValueBuilder

class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Blah","ClassOptionalOutput","ClassOptionalOutput2","ClassWithImage","Education","Email","Event","FakeImage","NamedArgsSingleClass","OptionalTest_Prop1","OptionalTest_ReturnType","OrderInfo","Person","RaysData","Resume","SearchParams","TestClassAlias","TestClassWithEnum","TestOutputClass","TestOutputClassNested","UnionTest_ReturnType","WithReasoning",]
        ), enums=set(
          ["Category","Category2","Category3","DataType","EnumInClass","EnumOutput","Hobby","NamedArgsSingleEnum","NamedArgsSingleEnumList","OptionalTest_CategoryType","OrderStatus","Tag","TestEnum",]
        ))

    @property
    def Person(self) -> "PersonBuilder":
        return PersonBuilder(self)

    @property
    def Hobby(self) -> "HobbyBuilder":
        return HobbyBuilder(self)


class PersonBuilder:
    def __init__(self, tb: _TypeBuilder):
        self.__bldr = tb._tb.class_("Person")
        self.__properties = set([ "name",  "hair_color", ])
        self.__props = PersonProperties(self)

    def field(self) -> FieldType:
        return self.__bldr.field()

    @property
    def props(self) -> "PersonProperties":
        return self.__props
    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyBuilder]]:
        return [(name, self.__bldr.property(name)) for name in self.__properties]

    def add_property(self, name: str, type: FieldType) -> ClassPropertyBuilder:
        if name in self.__properties:
            raise ValueError(f"Property {name} already exists.")
        return ClassPropertyBuilder(self.__bldr.property(name).type(type))

class PersonProperties:
    def __init__(self, class_builder: "PersonBuilder"):
        self.__cls_builder = class_builder

    @property
    def name(self) -> ClassPropertyBuilder:
        return self.__cls_builder.__bldr.property("name")

    @property
    def hair_color(self) -> ClassPropertyBuilder:
        return self.__cls_builder.__bldr.property("hair_color")

    def __getattr__(self, name: str) -> ClassPropertyBuilder:
        if name not in self.__cls_builder.__properties:
            raise AttributeError(f"Property {name} not found.")
        return ClassPropertyBuilder(self.__cls_builder.__bldr.property(name))


class HobbyBuilder:
    def __init__(self, tb: _TypeBuilder):
        self.__bldr = tb._tb.enum("Hobby")
        self.__values = set([ "SPORTS",  "MUSIC",  "READING", ])
        self.__vals = HobbyValues(self)

    def field(self) -> FieldType:
        return self.__bldr.field()

    @property
    def values(self) -> "HobbyValues":
        return self.__vals

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueBuilder]]:
        return [(name, self.__bldr.value(name)) for name in self.__values]

    def add_value(self, name: str) -> EnumValueBuilder:
        if name in self.__values:
            raise ValueError(f"Value {name} already exists.")
        self.__values.add(name)
        return self.__bldr.value(name)

class HobbyValues:
    def __init__(self, enum_builder: "HobbyBuilder"):
        self.__enum_builder = enum_builder

    @property
    def SPORTS(self) -> EnumValueBuilder:
        return self.__enum_builder.__bldr.value("SPORTS")

    @property
    def MUSIC(self) -> EnumValueBuilder:
        return self.__enum_builder.__bldr.value("MUSIC")

    @property
    def READING(self) -> EnumValueBuilder:
        return self.__enum_builder.__bldr.value("READING")

    def __getattr__(self, name: str) -> EnumValueBuilder:
        if name not in self.__enum_builder.__values:
            raise AttributeError(f"Value {name} not found.")
        return self.__enum_builder.__bldr.value(name)

__all__ = ["TypeBuilder"]