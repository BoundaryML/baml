// This file is auto-generated. Do not edit this file manually.
//
// Disable formatting for this file to avoid linting errors.
// tslint:disable
// @ts-nocheck
/* eslint-disable */


import { Category, ClassOptionalFields, ClassOptionalFieldsv2, ClassOptionalOutput, ClassOptionalOutput2, ClassOptionalOutput2v2, Email, EnumOutput, EnumOutput2, NamedArgsSingleClass, NamedArgsSingleClass2, NamedArgsSingleClassList2, NamedArgsSingleEnum, NamedArgsSingleEnum2, NamedArgsSingleEnumList, NamedArgsSingleEnumList2, OptionalClass, OptionalClassv2, OptionalTest_ReturnType, OptionalTest_ReturnTypev2, OrderInfo, OverrideClass, OverrideEnum, RaysData, Resume, SearchParams, TestClassAlias, TestClassWithEnum, TestClassWithEnum2, TestEnum, TestOutputClass, TestOutputClass2, UnionTest_ReturnType, UnionTest_ReturnTypev2 } from './types';
import { FireBamlEvent, traceAsync } from '@boundaryml/baml-core/ffi_layer';


type IClassifyMessage = (args: {
  input: string
}) => Promise<Category>

type ClassifyMessageImpls = 'default_config';

interface ClassifyMessageImpl {
    run: IClassifyMessage;
    name: ClassifyMessageImpls;
}

interface ClassifyMessageFunction {
  registerImpl: (name: ClassifyMessageImpls, impl: ClassifyMessageImpl) => void;
  getImpl: (name: ClassifyMessageImpls) => ClassifyMessageImpl;
}

function createClassifyMessageInstance(): IClassifyMessage & ClassifyMessageFunction {

  const registry: Record<ClassifyMessageImpls, ClassifyMessageImpl> = {}

  const wrapper: ClassifyMessageFunction = {
    getImpl: (name: ClassifyMessageImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ClassifyMessage with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ClassifyMessageImpls, cb: IClassifyMessage) => {
      if (registry[name]) {
        throw new Error(`Implementation for ClassifyMessage with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ClassifyMessage",
          /* returnType */ "Category",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ClassifyMessage: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IClassifyMessage & ClassifyMessageFunction;
}

const ClassifyMessage = createClassifyMessageInstance();

type IClassifyMessage2 = (args: {
  input: string
}) => Promise<Category>

type ClassifyMessage2Impls = 'default_config';

interface ClassifyMessage2Impl {
    run: IClassifyMessage2;
    name: ClassifyMessage2Impls;
}

interface ClassifyMessage2Function {
  registerImpl: (name: ClassifyMessage2Impls, impl: ClassifyMessage2Impl) => void;
  getImpl: (name: ClassifyMessage2Impls) => ClassifyMessage2Impl;
}

function createClassifyMessage2Instance(): IClassifyMessage2 & ClassifyMessage2Function {

  const registry: Record<ClassifyMessage2Impls, ClassifyMessage2Impl> = {}

  const wrapper: ClassifyMessage2Function = {
    getImpl: (name: ClassifyMessage2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ClassifyMessage2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ClassifyMessage2Impls, cb: IClassifyMessage2) => {
      if (registry[name]) {
        throw new Error(`Implementation for ClassifyMessage2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ClassifyMessage2",
          /* returnType */ "Category",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ClassifyMessage2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IClassifyMessage2 & ClassifyMessage2Function;
}

const ClassifyMessage2 = createClassifyMessage2Instance();

type IClassifyMessage3 = (args: {
  input: string
}) => Promise<Category>

type ClassifyMessage3Impls = 'default_config';

interface ClassifyMessage3Impl {
    run: IClassifyMessage3;
    name: ClassifyMessage3Impls;
}

interface ClassifyMessage3Function {
  registerImpl: (name: ClassifyMessage3Impls, impl: ClassifyMessage3Impl) => void;
  getImpl: (name: ClassifyMessage3Impls) => ClassifyMessage3Impl;
}

function createClassifyMessage3Instance(): IClassifyMessage3 & ClassifyMessage3Function {

  const registry: Record<ClassifyMessage3Impls, ClassifyMessage3Impl> = {}

  const wrapper: ClassifyMessage3Function = {
    getImpl: (name: ClassifyMessage3Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ClassifyMessage3 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ClassifyMessage3Impls, cb: IClassifyMessage3) => {
      if (registry[name]) {
        throw new Error(`Implementation for ClassifyMessage3 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ClassifyMessage3",
          /* returnType */ "Category",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ClassifyMessage3: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IClassifyMessage3 & ClassifyMessage3Function;
}

const ClassifyMessage3 = createClassifyMessage3Instance();

type IExtractNames = (args: {
  input: string
}) => Promise<string[]>

type ExtractNamesImpls = 'default_config';

interface ExtractNamesImpl {
    run: IExtractNames;
    name: ExtractNamesImpls;
}

interface ExtractNamesFunction {
  registerImpl: (name: ExtractNamesImpls, impl: ExtractNamesImpl) => void;
  getImpl: (name: ExtractNamesImpls) => ExtractNamesImpl;
}

function createExtractNamesInstance(): IExtractNames & ExtractNamesFunction {

  const registry: Record<ExtractNamesImpls, ExtractNamesImpl> = {}

  const wrapper: ExtractNamesFunction = {
    getImpl: (name: ExtractNamesImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractNames with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractNamesImpls, cb: IExtractNames) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractNames with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ExtractNames",
          /* returnType */ "string[]",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractNames: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractNames & ExtractNamesFunction;
}

const ExtractNames = createExtractNamesInstance();

type IExtractResume = (args: {
  resume: string
}) => Promise<Resume>

type ExtractResumeImpls = 'default_config';

interface ExtractResumeImpl {
    run: IExtractResume;
    name: ExtractResumeImpls;
}

interface ExtractResumeFunction {
  registerImpl: (name: ExtractResumeImpls, impl: ExtractResumeImpl) => void;
  getImpl: (name: ExtractResumeImpls) => ExtractResumeImpl;
}

function createExtractResumeInstance(): IExtractResume & ExtractResumeFunction {

  const registry: Record<ExtractResumeImpls, ExtractResumeImpl> = {}

  const wrapper: ExtractResumeFunction = {
    getImpl: (name: ExtractResumeImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractResume with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractResumeImpls, cb: IExtractResume) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractResume with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ExtractResume",
          /* returnType */ "Resume",
          /* paramters */ [
            [
              "resume",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            resume: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractResume: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    resume: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractResume & ExtractResumeFunction;
}

const ExtractResume = createExtractResumeInstance();

type IExtractResume2 = (args: {
  resume: string
}) => Promise<Resume>

type ExtractResume2Impls = 'default_config';

interface ExtractResume2Impl {
    run: IExtractResume2;
    name: ExtractResume2Impls;
}

interface ExtractResume2Function {
  registerImpl: (name: ExtractResume2Impls, impl: ExtractResume2Impl) => void;
  getImpl: (name: ExtractResume2Impls) => ExtractResume2Impl;
}

function createExtractResume2Instance(): IExtractResume2 & ExtractResume2Function {

  const registry: Record<ExtractResume2Impls, ExtractResume2Impl> = {}

  const wrapper: ExtractResume2Function = {
    getImpl: (name: ExtractResume2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractResume2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractResume2Impls, cb: IExtractResume2) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractResume2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ExtractResume2",
          /* returnType */ "Resume",
          /* paramters */ [
            [
              "resume",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            resume: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractResume2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    resume: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractResume2 & ExtractResume2Function;
}

const ExtractResume2 = createExtractResume2Instance();

type IFnClassOptional = (arg: OptionalClass | null) => Promise<string>

type FnClassOptionalImpls = 'v1';

interface FnClassOptionalImpl {
    run: IFnClassOptional;
    name: FnClassOptionalImpls;
}

interface FnClassOptionalFunction {
  registerImpl: (name: FnClassOptionalImpls, impl: FnClassOptionalImpl) => void;
  getImpl: (name: FnClassOptionalImpls) => FnClassOptionalImpl;
}

function createFnClassOptionalInstance(): IFnClassOptional & FnClassOptionalFunction {

  const registry: Record<FnClassOptionalImpls, FnClassOptionalImpl> = {}

  const wrapper: FnClassOptionalFunction = {
    getImpl: (name: FnClassOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalImpls, cb: IFnClassOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "OptionalClass | null"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: OptionalClass | null
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: OptionalClass | null) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptional & FnClassOptionalFunction;
}

const FnClassOptional = createFnClassOptionalInstance();

type IFnClassOptional2 = (arg: ClassOptionalFields) => Promise<string>

type FnClassOptional2Impls = 'v1';

interface FnClassOptional2Impl {
    run: IFnClassOptional2;
    name: FnClassOptional2Impls;
}

interface FnClassOptional2Function {
  registerImpl: (name: FnClassOptional2Impls, impl: FnClassOptional2Impl) => void;
  getImpl: (name: FnClassOptional2Impls) => FnClassOptional2Impl;
}

function createFnClassOptional2Instance(): IFnClassOptional2 & FnClassOptional2Function {

  const registry: Record<FnClassOptional2Impls, FnClassOptional2Impl> = {}

  const wrapper: FnClassOptional2Function = {
    getImpl: (name: FnClassOptional2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptional2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptional2Impls, cb: IFnClassOptional2) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptional2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptional2",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "ClassOptionalFields"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: ClassOptionalFields
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptional2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: ClassOptionalFields) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptional2 & FnClassOptional2Function;
}

const FnClassOptional2 = createFnClassOptional2Instance();

type IFnClassOptionalOutput = (arg: string) => Promise<ClassOptionalOutput | null>

type FnClassOptionalOutputImpls = 'v1';

interface FnClassOptionalOutputImpl {
    run: IFnClassOptionalOutput;
    name: FnClassOptionalOutputImpls;
}

interface FnClassOptionalOutputFunction {
  registerImpl: (name: FnClassOptionalOutputImpls, impl: FnClassOptionalOutputImpl) => void;
  getImpl: (name: FnClassOptionalOutputImpls) => FnClassOptionalOutputImpl;
}

function createFnClassOptionalOutputInstance(): IFnClassOptionalOutput & FnClassOptionalOutputFunction {

  const registry: Record<FnClassOptionalOutputImpls, FnClassOptionalOutputImpl> = {}

  const wrapper: FnClassOptionalOutputFunction = {
    getImpl: (name: FnClassOptionalOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutputImpls, cb: IFnClassOptionalOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput",
          /* returnType */ "ClassOptionalOutput | null",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptionalOutput & FnClassOptionalOutputFunction;
}

const FnClassOptionalOutput = createFnClassOptionalOutputInstance();

type IFnClassOptionalOutput2 = (arg: string) => Promise<ClassOptionalOutput2 | null>

type FnClassOptionalOutput2Impls = 'v1';

interface FnClassOptionalOutput2Impl {
    run: IFnClassOptionalOutput2;
    name: FnClassOptionalOutput2Impls;
}

interface FnClassOptionalOutput2Function {
  registerImpl: (name: FnClassOptionalOutput2Impls, impl: FnClassOptionalOutput2Impl) => void;
  getImpl: (name: FnClassOptionalOutput2Impls) => FnClassOptionalOutput2Impl;
}

function createFnClassOptionalOutput2Instance(): IFnClassOptionalOutput2 & FnClassOptionalOutput2Function {

  const registry: Record<FnClassOptionalOutput2Impls, FnClassOptionalOutput2Impl> = {}

  const wrapper: FnClassOptionalOutput2Function = {
    getImpl: (name: FnClassOptionalOutput2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutput2Impls, cb: IFnClassOptionalOutput2) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput2",
          /* returnType */ "ClassOptionalOutput2 | null",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptionalOutput2 & FnClassOptionalOutput2Function;
}

const FnClassOptionalOutput2 = createFnClassOptionalOutput2Instance();

type IFnClassOptionalOutput2_V2 = (args: {
  input: string
}) => Promise<ClassOptionalOutput2v2 | null>

type FnClassOptionalOutput2_V2Impls = 'default_config';

interface FnClassOptionalOutput2_V2Impl {
    run: IFnClassOptionalOutput2_V2;
    name: FnClassOptionalOutput2_V2Impls;
}

interface FnClassOptionalOutput2_V2Function {
  registerImpl: (name: FnClassOptionalOutput2_V2Impls, impl: FnClassOptionalOutput2_V2Impl) => void;
  getImpl: (name: FnClassOptionalOutput2_V2Impls) => FnClassOptionalOutput2_V2Impl;
}

function createFnClassOptionalOutput2_V2Instance(): IFnClassOptionalOutput2_V2 & FnClassOptionalOutput2_V2Function {

  const registry: Record<FnClassOptionalOutput2_V2Impls, FnClassOptionalOutput2_V2Impl> = {}

  const wrapper: FnClassOptionalOutput2_V2Function = {
    getImpl: (name: FnClassOptionalOutput2_V2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput2_V2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutput2_V2Impls, cb: IFnClassOptionalOutput2_V2) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput2_V2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput2_V2",
          /* returnType */ "ClassOptionalOutput2v2 | null",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput2_V2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptionalOutput2_V2 & FnClassOptionalOutput2_V2Function;
}

const FnClassOptionalOutput2_V2 = createFnClassOptionalOutput2_V2Instance();

type IFnEnumListOutput = (arg: string) => Promise<EnumOutput[]>

type FnEnumListOutputImpls = 'v1';

interface FnEnumListOutputImpl {
    run: IFnEnumListOutput;
    name: FnEnumListOutputImpls;
}

interface FnEnumListOutputFunction {
  registerImpl: (name: FnEnumListOutputImpls, impl: FnEnumListOutputImpl) => void;
  getImpl: (name: FnEnumListOutputImpls) => FnEnumListOutputImpl;
}

function createFnEnumListOutputInstance(): IFnEnumListOutput & FnEnumListOutputFunction {

  const registry: Record<FnEnumListOutputImpls, FnEnumListOutputImpl> = {}

  const wrapper: FnEnumListOutputFunction = {
    getImpl: (name: FnEnumListOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnEnumListOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnEnumListOutputImpls, cb: IFnEnumListOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnEnumListOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnEnumListOutput",
          /* returnType */ "EnumOutput[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnEnumListOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnEnumListOutput & FnEnumListOutputFunction;
}

const FnEnumListOutput = createFnEnumListOutputInstance();

type IFnEnumOutput = (arg: string) => Promise<EnumOutput>

type FnEnumOutputImpls = 'v1';

interface FnEnumOutputImpl {
    run: IFnEnumOutput;
    name: FnEnumOutputImpls;
}

interface FnEnumOutputFunction {
  registerImpl: (name: FnEnumOutputImpls, impl: FnEnumOutputImpl) => void;
  getImpl: (name: FnEnumOutputImpls) => FnEnumOutputImpl;
}

function createFnEnumOutputInstance(): IFnEnumOutput & FnEnumOutputFunction {

  const registry: Record<FnEnumOutputImpls, FnEnumOutputImpl> = {}

  const wrapper: FnEnumOutputFunction = {
    getImpl: (name: FnEnumOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnEnumOutputImpls, cb: IFnEnumOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnEnumOutput",
          /* returnType */ "EnumOutput",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnEnumOutput & FnEnumOutputFunction;
}

const FnEnumOutput = createFnEnumOutputInstance();

type IFnNamedArgsSingleStringOptional = (args: {
  myString: string | null
}) => Promise<string>

type FnNamedArgsSingleStringOptionalImpls = 'v1';

interface FnNamedArgsSingleStringOptionalImpl {
    run: IFnNamedArgsSingleStringOptional;
    name: FnNamedArgsSingleStringOptionalImpls;
}

interface FnNamedArgsSingleStringOptionalFunction {
  registerImpl: (name: FnNamedArgsSingleStringOptionalImpls, impl: FnNamedArgsSingleStringOptionalImpl) => void;
  getImpl: (name: FnNamedArgsSingleStringOptionalImpls) => FnNamedArgsSingleStringOptionalImpl;
}

function createFnNamedArgsSingleStringOptionalInstance(): IFnNamedArgsSingleStringOptional & FnNamedArgsSingleStringOptionalFunction {

  const registry: Record<FnNamedArgsSingleStringOptionalImpls, FnNamedArgsSingleStringOptionalImpl> = {}

  const wrapper: FnNamedArgsSingleStringOptionalFunction = {
    getImpl: (name: FnNamedArgsSingleStringOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnNamedArgsSingleStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnNamedArgsSingleStringOptionalImpls, cb: IFnNamedArgsSingleStringOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnNamedArgsSingleStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnNamedArgsSingleStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string | null"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string | null
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnNamedArgsSingleStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string | null
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnNamedArgsSingleStringOptional & FnNamedArgsSingleStringOptionalFunction;
}

const FnNamedArgsSingleStringOptional = createFnNamedArgsSingleStringOptionalInstance();

type IFnOutputBool = (arg: string) => Promise<boolean>

type FnOutputBoolImpls = 'v1';

interface FnOutputBoolImpl {
    run: IFnOutputBool;
    name: FnOutputBoolImpls;
}

interface FnOutputBoolFunction {
  registerImpl: (name: FnOutputBoolImpls, impl: FnOutputBoolImpl) => void;
  getImpl: (name: FnOutputBoolImpls) => FnOutputBoolImpl;
}

function createFnOutputBoolInstance(): IFnOutputBool & FnOutputBoolFunction {

  const registry: Record<FnOutputBoolImpls, FnOutputBoolImpl> = {}

  const wrapper: FnOutputBoolFunction = {
    getImpl: (name: FnOutputBoolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputBoolImpls, cb: IFnOutputBool) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputBool",
          /* returnType */ "boolean",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputBool & FnOutputBoolFunction;
}

const FnOutputBool = createFnOutputBoolInstance();

type IFnOutputClass = (arg: string) => Promise<TestOutputClass>

type FnOutputClassImpls = 'v1';

interface FnOutputClassImpl {
    run: IFnOutputClass;
    name: FnOutputClassImpls;
}

interface FnOutputClassFunction {
  registerImpl: (name: FnOutputClassImpls, impl: FnOutputClassImpl) => void;
  getImpl: (name: FnOutputClassImpls) => FnOutputClassImpl;
}

function createFnOutputClassInstance(): IFnOutputClass & FnOutputClassFunction {

  const registry: Record<FnOutputClassImpls, FnOutputClassImpl> = {}

  const wrapper: FnOutputClassFunction = {
    getImpl: (name: FnOutputClassImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassImpls, cb: IFnOutputClass) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClass",
          /* returnType */ "TestOutputClass",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClass & FnOutputClassFunction;
}

const FnOutputClass = createFnOutputClassInstance();

type IFnOutputClassList = (arg: string) => Promise<TestOutputClass[]>

type FnOutputClassListImpls = 'v1';

interface FnOutputClassListImpl {
    run: IFnOutputClassList;
    name: FnOutputClassListImpls;
}

interface FnOutputClassListFunction {
  registerImpl: (name: FnOutputClassListImpls, impl: FnOutputClassListImpl) => void;
  getImpl: (name: FnOutputClassListImpls) => FnOutputClassListImpl;
}

function createFnOutputClassListInstance(): IFnOutputClassList & FnOutputClassListFunction {

  const registry: Record<FnOutputClassListImpls, FnOutputClassListImpl> = {}

  const wrapper: FnOutputClassListFunction = {
    getImpl: (name: FnOutputClassListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassListImpls, cb: IFnOutputClassList) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassList",
          /* returnType */ "TestOutputClass[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClassList & FnOutputClassListFunction;
}

const FnOutputClassList = createFnOutputClassListInstance();

type IFnOutputClassWithEnum = (arg: string) => Promise<TestClassWithEnum>

type FnOutputClassWithEnumImpls = 'v1';

interface FnOutputClassWithEnumImpl {
    run: IFnOutputClassWithEnum;
    name: FnOutputClassWithEnumImpls;
}

interface FnOutputClassWithEnumFunction {
  registerImpl: (name: FnOutputClassWithEnumImpls, impl: FnOutputClassWithEnumImpl) => void;
  getImpl: (name: FnOutputClassWithEnumImpls) => FnOutputClassWithEnumImpl;
}

function createFnOutputClassWithEnumInstance(): IFnOutputClassWithEnum & FnOutputClassWithEnumFunction {

  const registry: Record<FnOutputClassWithEnumImpls, FnOutputClassWithEnumImpl> = {}

  const wrapper: FnOutputClassWithEnumFunction = {
    getImpl: (name: FnOutputClassWithEnumImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassWithEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassWithEnumImpls, cb: IFnOutputClassWithEnum) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassWithEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassWithEnum",
          /* returnType */ "TestClassWithEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassWithEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClassWithEnum & FnOutputClassWithEnumFunction;
}

const FnOutputClassWithEnum = createFnOutputClassWithEnumInstance();

type IFnOutputClassWithEnum_V2 = (args: {
  input: string
}) => Promise<TestClassWithEnum2>

type FnOutputClassWithEnum_V2Impls = 'default_config';

interface FnOutputClassWithEnum_V2Impl {
    run: IFnOutputClassWithEnum_V2;
    name: FnOutputClassWithEnum_V2Impls;
}

interface FnOutputClassWithEnum_V2Function {
  registerImpl: (name: FnOutputClassWithEnum_V2Impls, impl: FnOutputClassWithEnum_V2Impl) => void;
  getImpl: (name: FnOutputClassWithEnum_V2Impls) => FnOutputClassWithEnum_V2Impl;
}

function createFnOutputClassWithEnum_V2Instance(): IFnOutputClassWithEnum_V2 & FnOutputClassWithEnum_V2Function {

  const registry: Record<FnOutputClassWithEnum_V2Impls, FnOutputClassWithEnum_V2Impl> = {}

  const wrapper: FnOutputClassWithEnum_V2Function = {
    getImpl: (name: FnOutputClassWithEnum_V2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassWithEnum_V2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassWithEnum_V2Impls, cb: IFnOutputClassWithEnum_V2) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassWithEnum_V2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassWithEnum_V2",
          /* returnType */ "TestClassWithEnum2",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassWithEnum_V2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClassWithEnum_V2 & FnOutputClassWithEnum_V2Function;
}

const FnOutputClassWithEnum_V2 = createFnOutputClassWithEnum_V2Instance();

type IFnOutputStringList = (arg: string) => Promise<string[]>

type FnOutputStringListImpls = 'v1';

interface FnOutputStringListImpl {
    run: IFnOutputStringList;
    name: FnOutputStringListImpls;
}

interface FnOutputStringListFunction {
  registerImpl: (name: FnOutputStringListImpls, impl: FnOutputStringListImpl) => void;
  getImpl: (name: FnOutputStringListImpls) => FnOutputStringListImpl;
}

function createFnOutputStringListInstance(): IFnOutputStringList & FnOutputStringListFunction {

  const registry: Record<FnOutputStringListImpls, FnOutputStringListImpl> = {}

  const wrapper: FnOutputStringListFunction = {
    getImpl: (name: FnOutputStringListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputStringListImpls, cb: IFnOutputStringList) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputStringList",
          /* returnType */ "string[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputStringList & FnOutputStringListFunction;
}

const FnOutputStringList = createFnOutputStringListInstance();

type IFnStringOptional = (arg: string | null) => Promise<string>

type FnStringOptionalImpls = 'v1';

interface FnStringOptionalImpl {
    run: IFnStringOptional;
    name: FnStringOptionalImpls;
}

interface FnStringOptionalFunction {
  registerImpl: (name: FnStringOptionalImpls, impl: FnStringOptionalImpl) => void;
  getImpl: (name: FnStringOptionalImpls) => FnStringOptionalImpl;
}

function createFnStringOptionalInstance(): IFnStringOptional & FnStringOptionalFunction {

  const registry: Record<FnStringOptionalImpls, FnStringOptionalImpl> = {}

  const wrapper: FnStringOptionalFunction = {
    getImpl: (name: FnStringOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnStringOptionalImpls, cb: IFnStringOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string | null"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string | null
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string | null) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnStringOptional & FnStringOptionalFunction;
}

const FnStringOptional = createFnStringOptionalInstance();

type IFnTestAliasedEnumOutput = (arg: string) => Promise<TestEnum>

type FnTestAliasedEnumOutputImpls = 'v1';

interface FnTestAliasedEnumOutputImpl {
    run: IFnTestAliasedEnumOutput;
    name: FnTestAliasedEnumOutputImpls;
}

interface FnTestAliasedEnumOutputFunction {
  registerImpl: (name: FnTestAliasedEnumOutputImpls, impl: FnTestAliasedEnumOutputImpl) => void;
  getImpl: (name: FnTestAliasedEnumOutputImpls) => FnTestAliasedEnumOutputImpl;
}

function createFnTestAliasedEnumOutputInstance(): IFnTestAliasedEnumOutput & FnTestAliasedEnumOutputFunction {

  const registry: Record<FnTestAliasedEnumOutputImpls, FnTestAliasedEnumOutputImpl> = {}

  const wrapper: FnTestAliasedEnumOutputFunction = {
    getImpl: (name: FnTestAliasedEnumOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestAliasedEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestAliasedEnumOutputImpls, cb: IFnTestAliasedEnumOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestAliasedEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestAliasedEnumOutput",
          /* returnType */ "TestEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestAliasedEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestAliasedEnumOutput & FnTestAliasedEnumOutputFunction;
}

const FnTestAliasedEnumOutput = createFnTestAliasedEnumOutputInstance();

type IFnTestClassAlias = (arg: string) => Promise<TestClassAlias>

type FnTestClassAliasImpls = 'v1';

interface FnTestClassAliasImpl {
    run: IFnTestClassAlias;
    name: FnTestClassAliasImpls;
}

interface FnTestClassAliasFunction {
  registerImpl: (name: FnTestClassAliasImpls, impl: FnTestClassAliasImpl) => void;
  getImpl: (name: FnTestClassAliasImpls) => FnTestClassAliasImpl;
}

function createFnTestClassAliasInstance(): IFnTestClassAlias & FnTestClassAliasFunction {

  const registry: Record<FnTestClassAliasImpls, FnTestClassAliasImpl> = {}

  const wrapper: FnTestClassAliasFunction = {
    getImpl: (name: FnTestClassAliasImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestClassAlias with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestClassAliasImpls, cb: IFnTestClassAlias) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestClassAlias with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestClassAlias",
          /* returnType */ "TestClassAlias",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestClassAlias: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestClassAlias & FnTestClassAliasFunction;
}

const FnTestClassAlias = createFnTestClassAliasInstance();

type IFnTestClassOverride = (arg: string) => Promise<OverrideClass>

type FnTestClassOverrideImpls = 'v1';

interface FnTestClassOverrideImpl {
    run: IFnTestClassOverride;
    name: FnTestClassOverrideImpls;
}

interface FnTestClassOverrideFunction {
  registerImpl: (name: FnTestClassOverrideImpls, impl: FnTestClassOverrideImpl) => void;
  getImpl: (name: FnTestClassOverrideImpls) => FnTestClassOverrideImpl;
}

function createFnTestClassOverrideInstance(): IFnTestClassOverride & FnTestClassOverrideFunction {

  const registry: Record<FnTestClassOverrideImpls, FnTestClassOverrideImpl> = {}

  const wrapper: FnTestClassOverrideFunction = {
    getImpl: (name: FnTestClassOverrideImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestClassOverride with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestClassOverrideImpls, cb: IFnTestClassOverride) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestClassOverride with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestClassOverride",
          /* returnType */ "OverrideClass",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestClassOverride: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestClassOverride & FnTestClassOverrideFunction;
}

const FnTestClassOverride = createFnTestClassOverrideInstance();

type IFnTestEnumOverride = (arg: string) => Promise<OverrideEnum>

type FnTestEnumOverrideImpls = 'v1';

interface FnTestEnumOverrideImpl {
    run: IFnTestEnumOverride;
    name: FnTestEnumOverrideImpls;
}

interface FnTestEnumOverrideFunction {
  registerImpl: (name: FnTestEnumOverrideImpls, impl: FnTestEnumOverrideImpl) => void;
  getImpl: (name: FnTestEnumOverrideImpls) => FnTestEnumOverrideImpl;
}

function createFnTestEnumOverrideInstance(): IFnTestEnumOverride & FnTestEnumOverrideFunction {

  const registry: Record<FnTestEnumOverrideImpls, FnTestEnumOverrideImpl> = {}

  const wrapper: FnTestEnumOverrideFunction = {
    getImpl: (name: FnTestEnumOverrideImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestEnumOverride with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestEnumOverrideImpls, cb: IFnTestEnumOverride) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestEnumOverride with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestEnumOverride",
          /* returnType */ "OverrideEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestEnumOverride: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestEnumOverride & FnTestEnumOverrideFunction;
}

const FnTestEnumOverride = createFnTestEnumOverrideInstance();

type IFnTestNamedArgsSingleEnum = (args: {
  myArg: NamedArgsSingleEnum
}) => Promise<string>

type FnTestNamedArgsSingleEnumImpls = 'v1';

interface FnTestNamedArgsSingleEnumImpl {
    run: IFnTestNamedArgsSingleEnum;
    name: FnTestNamedArgsSingleEnumImpls;
}

interface FnTestNamedArgsSingleEnumFunction {
  registerImpl: (name: FnTestNamedArgsSingleEnumImpls, impl: FnTestNamedArgsSingleEnumImpl) => void;
  getImpl: (name: FnTestNamedArgsSingleEnumImpls) => FnTestNamedArgsSingleEnumImpl;
}

function createFnTestNamedArgsSingleEnumInstance(): IFnTestNamedArgsSingleEnum & FnTestNamedArgsSingleEnumFunction {

  const registry: Record<FnTestNamedArgsSingleEnumImpls, FnTestNamedArgsSingleEnumImpl> = {}

  const wrapper: FnTestNamedArgsSingleEnumFunction = {
    getImpl: (name: FnTestNamedArgsSingleEnumImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestNamedArgsSingleEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestNamedArgsSingleEnumImpls, cb: IFnTestNamedArgsSingleEnum) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestNamedArgsSingleEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestNamedArgsSingleEnum",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnum"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnum
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestNamedArgsSingleEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnum
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestNamedArgsSingleEnum & FnTestNamedArgsSingleEnumFunction;
}

const FnTestNamedArgsSingleEnum = createFnTestNamedArgsSingleEnumInstance();

type IFnTestOutputAdapter = (arg: string) => Promise<string>

type FnTestOutputAdapterImpls = 'v1';

interface FnTestOutputAdapterImpl {
    run: IFnTestOutputAdapter;
    name: FnTestOutputAdapterImpls;
}

interface FnTestOutputAdapterFunction {
  registerImpl: (name: FnTestOutputAdapterImpls, impl: FnTestOutputAdapterImpl) => void;
  getImpl: (name: FnTestOutputAdapterImpls) => FnTestOutputAdapterImpl;
}

function createFnTestOutputAdapterInstance(): IFnTestOutputAdapter & FnTestOutputAdapterFunction {

  const registry: Record<FnTestOutputAdapterImpls, FnTestOutputAdapterImpl> = {}

  const wrapper: FnTestOutputAdapterFunction = {
    getImpl: (name: FnTestOutputAdapterImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestOutputAdapter with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestOutputAdapterImpls, cb: IFnTestOutputAdapter) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestOutputAdapter with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestOutputAdapter",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestOutputAdapter: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestOutputAdapter & FnTestOutputAdapterFunction;
}

const FnTestOutputAdapter = createFnTestOutputAdapterInstance();

type IGetDataType = (args: {
  text: string
}) => Promise<RaysData>

type GetDataTypeImpls = 'default_config';

interface GetDataTypeImpl {
    run: IGetDataType;
    name: GetDataTypeImpls;
}

interface GetDataTypeFunction {
  registerImpl: (name: GetDataTypeImpls, impl: GetDataTypeImpl) => void;
  getImpl: (name: GetDataTypeImpls) => GetDataTypeImpl;
}

function createGetDataTypeInstance(): IGetDataType & GetDataTypeFunction {

  const registry: Record<GetDataTypeImpls, GetDataTypeImpl> = {}

  const wrapper: GetDataTypeFunction = {
    getImpl: (name: GetDataTypeImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GetDataType with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GetDataTypeImpls, cb: IGetDataType) => {
      if (registry[name]) {
        throw new Error(`Implementation for GetDataType with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"GetDataType",
          /* returnType */ "RaysData",
          /* paramters */ [
            [
              "text",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            text: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for GetDataType: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    text: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IGetDataType & GetDataTypeFunction;
}

const GetDataType = createGetDataTypeInstance();

type IGetOrderInfo = (args: {
  email: Email
}) => Promise<OrderInfo>

type GetOrderInfoImpls = 'default_config';

interface GetOrderInfoImpl {
    run: IGetOrderInfo;
    name: GetOrderInfoImpls;
}

interface GetOrderInfoFunction {
  registerImpl: (name: GetOrderInfoImpls, impl: GetOrderInfoImpl) => void;
  getImpl: (name: GetOrderInfoImpls) => GetOrderInfoImpl;
}

function createGetOrderInfoInstance(): IGetOrderInfo & GetOrderInfoFunction {

  const registry: Record<GetOrderInfoImpls, GetOrderInfoImpl> = {}

  const wrapper: GetOrderInfoFunction = {
    getImpl: (name: GetOrderInfoImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GetOrderInfo with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GetOrderInfoImpls, cb: IGetOrderInfo) => {
      if (registry[name]) {
        throw new Error(`Implementation for GetOrderInfo with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"GetOrderInfo",
          /* returnType */ "OrderInfo",
          /* paramters */ [
            [
              "email",
              "Email"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            email: Email
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for GetOrderInfo: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    email: Email
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IGetOrderInfo & GetOrderInfoFunction;
}

const GetOrderInfo = createGetOrderInfoInstance();

type IGetQuery = (args: {
  query: string
}) => Promise<SearchParams>

type GetQueryImpls = 'default_config';

interface GetQueryImpl {
    run: IGetQuery;
    name: GetQueryImpls;
}

interface GetQueryFunction {
  registerImpl: (name: GetQueryImpls, impl: GetQueryImpl) => void;
  getImpl: (name: GetQueryImpls) => GetQueryImpl;
}

function createGetQueryInstance(): IGetQuery & GetQueryFunction {

  const registry: Record<GetQueryImpls, GetQueryImpl> = {}

  const wrapper: GetQueryFunction = {
    getImpl: (name: GetQueryImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GetQuery with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GetQueryImpls, cb: IGetQuery) => {
      if (registry[name]) {
        throw new Error(`Implementation for GetQuery with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"GetQuery",
          /* returnType */ "SearchParams",
          /* paramters */ [
            [
              "query",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            query: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for GetQuery: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    query: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IGetQuery & GetQueryFunction;
}

const GetQuery = createGetQueryInstance();

type IOptionalTest_Function = (arg: string) => Promise<OptionalTest_ReturnType | null[]>

type OptionalTest_FunctionImpls = 'v1';

interface OptionalTest_FunctionImpl {
    run: IOptionalTest_Function;
    name: OptionalTest_FunctionImpls;
}

interface OptionalTest_FunctionFunction {
  registerImpl: (name: OptionalTest_FunctionImpls, impl: OptionalTest_FunctionImpl) => void;
  getImpl: (name: OptionalTest_FunctionImpls) => OptionalTest_FunctionImpl;
}

function createOptionalTest_FunctionInstance(): IOptionalTest_Function & OptionalTest_FunctionFunction {

  const registry: Record<OptionalTest_FunctionImpls, OptionalTest_FunctionImpl> = {}

  const wrapper: OptionalTest_FunctionFunction = {
    getImpl: (name: OptionalTest_FunctionImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for OptionalTest_Function with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: OptionalTest_FunctionImpls, cb: IOptionalTest_Function) => {
      if (registry[name]) {
        throw new Error(`Implementation for OptionalTest_Function with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"OptionalTest_Function",
          /* returnType */ "OptionalTest_ReturnType | null[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for OptionalTest_Function: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IOptionalTest_Function & OptionalTest_FunctionFunction;
}

const OptionalTest_Function = createOptionalTest_FunctionInstance();

type IOptionalTest_Function_V2 = (args: {
  input: string
}) => Promise<OptionalTest_ReturnTypev2 | null[]>

type OptionalTest_Function_V2Impls = 'default_config';

interface OptionalTest_Function_V2Impl {
    run: IOptionalTest_Function_V2;
    name: OptionalTest_Function_V2Impls;
}

interface OptionalTest_Function_V2Function {
  registerImpl: (name: OptionalTest_Function_V2Impls, impl: OptionalTest_Function_V2Impl) => void;
  getImpl: (name: OptionalTest_Function_V2Impls) => OptionalTest_Function_V2Impl;
}

function createOptionalTest_Function_V2Instance(): IOptionalTest_Function_V2 & OptionalTest_Function_V2Function {

  const registry: Record<OptionalTest_Function_V2Impls, OptionalTest_Function_V2Impl> = {}

  const wrapper: OptionalTest_Function_V2Function = {
    getImpl: (name: OptionalTest_Function_V2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for OptionalTest_Function_V2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: OptionalTest_Function_V2Impls, cb: IOptionalTest_Function_V2) => {
      if (registry[name]) {
        throw new Error(`Implementation for OptionalTest_Function_V2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"OptionalTest_Function_V2",
          /* returnType */ "OptionalTest_ReturnTypev2 | null[]",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for OptionalTest_Function_V2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IOptionalTest_Function_V2 & OptionalTest_Function_V2Function;
}

const OptionalTest_Function_V2 = createOptionalTest_Function_V2Instance();

type IPromptTest = (arg: string) => Promise<string>

type PromptTestImpls = 'bird_chat' | 'claude_chat' | 'claude_chat_with_chat_msgs' | 'claude_chat_with_chat_msgs_no_system' | 'ollama_chat' | 'openai_chat' | 'openai_chat_with_chat_msgs' | 'openai_chat_with_chat_msgs_no_system';

interface PromptTestImpl {
    run: IPromptTest;
    name: PromptTestImpls;
}

interface PromptTestFunction {
  registerImpl: (name: PromptTestImpls, impl: PromptTestImpl) => void;
  getImpl: (name: PromptTestImpls) => PromptTestImpl;
}

function createPromptTestInstance(): IPromptTest & PromptTestFunction {

  const registry: Record<PromptTestImpls, PromptTestImpl> = {}

  const wrapper: PromptTestFunction = {
    getImpl: (name: PromptTestImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for PromptTest with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: PromptTestImpls, cb: IPromptTest) => {
      if (registry[name]) {
        throw new Error(`Implementation for PromptTest with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"PromptTest",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['bird_chat', 'claude_chat', 'claude_chat_with_chat_msgs', 'claude_chat_with_chat_msgs_no_system', 'ollama_chat', 'openai_chat', 'openai_chat_with_chat_msgs', 'openai_chat_with_chat_msgs_no_system'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for PromptTest: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('claude_chat').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IPromptTest & PromptTestFunction;
}

const PromptTest = createPromptTestInstance();

type ITestFnNamedArgsSingleBool = (args: {
  myBool: boolean
}) => Promise<string>

type TestFnNamedArgsSingleBoolImpls = 'v1';

interface TestFnNamedArgsSingleBoolImpl {
    run: ITestFnNamedArgsSingleBool;
    name: TestFnNamedArgsSingleBoolImpls;
}

interface TestFnNamedArgsSingleBoolFunction {
  registerImpl: (name: TestFnNamedArgsSingleBoolImpls, impl: TestFnNamedArgsSingleBoolImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleBoolImpls) => TestFnNamedArgsSingleBoolImpl;
}

function createTestFnNamedArgsSingleBoolInstance(): ITestFnNamedArgsSingleBool & TestFnNamedArgsSingleBoolFunction {

  const registry: Record<TestFnNamedArgsSingleBoolImpls, TestFnNamedArgsSingleBoolImpl> = {}

  const wrapper: TestFnNamedArgsSingleBoolFunction = {
    getImpl: (name: TestFnNamedArgsSingleBoolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleBoolImpls, cb: ITestFnNamedArgsSingleBool) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleBool",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myBool",
              "boolean"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myBool: boolean
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myBool: boolean
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleBool & TestFnNamedArgsSingleBoolFunction;
}

const TestFnNamedArgsSingleBool = createTestFnNamedArgsSingleBoolInstance();

type ITestFnNamedArgsSingleClass = (args: {
  myArg: NamedArgsSingleClass
}) => Promise<string>

type TestFnNamedArgsSingleClassImpls = 'v1';

interface TestFnNamedArgsSingleClassImpl {
    run: ITestFnNamedArgsSingleClass;
    name: TestFnNamedArgsSingleClassImpls;
}

interface TestFnNamedArgsSingleClassFunction {
  registerImpl: (name: TestFnNamedArgsSingleClassImpls, impl: TestFnNamedArgsSingleClassImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleClassImpls) => TestFnNamedArgsSingleClassImpl;
}

function createTestFnNamedArgsSingleClassInstance(): ITestFnNamedArgsSingleClass & TestFnNamedArgsSingleClassFunction {

  const registry: Record<TestFnNamedArgsSingleClassImpls, TestFnNamedArgsSingleClassImpl> = {}

  const wrapper: TestFnNamedArgsSingleClassFunction = {
    getImpl: (name: TestFnNamedArgsSingleClassImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleClassImpls, cb: ITestFnNamedArgsSingleClass) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleClass",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleClass"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleClass
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleClass
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleClass & TestFnNamedArgsSingleClassFunction;
}

const TestFnNamedArgsSingleClass = createTestFnNamedArgsSingleClassInstance();

type ITestFnNamedArgsSingleEnumList = (args: {
  myArg: NamedArgsSingleEnumList[]
}) => Promise<string>

type TestFnNamedArgsSingleEnumListImpls = 'v1';

interface TestFnNamedArgsSingleEnumListImpl {
    run: ITestFnNamedArgsSingleEnumList;
    name: TestFnNamedArgsSingleEnumListImpls;
}

interface TestFnNamedArgsSingleEnumListFunction {
  registerImpl: (name: TestFnNamedArgsSingleEnumListImpls, impl: TestFnNamedArgsSingleEnumListImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleEnumListImpls) => TestFnNamedArgsSingleEnumListImpl;
}

function createTestFnNamedArgsSingleEnumListInstance(): ITestFnNamedArgsSingleEnumList & TestFnNamedArgsSingleEnumListFunction {

  const registry: Record<TestFnNamedArgsSingleEnumListImpls, TestFnNamedArgsSingleEnumListImpl> = {}

  const wrapper: TestFnNamedArgsSingleEnumListFunction = {
    getImpl: (name: TestFnNamedArgsSingleEnumListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleEnumList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleEnumListImpls, cb: ITestFnNamedArgsSingleEnumList) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleEnumList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleEnumList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnumList[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnumList[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleEnumList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnumList[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleEnumList & TestFnNamedArgsSingleEnumListFunction;
}

const TestFnNamedArgsSingleEnumList = createTestFnNamedArgsSingleEnumListInstance();

type ITestFnNamedArgsSingleFloat = (args: {
  myFloat: number
}) => Promise<string>

type TestFnNamedArgsSingleFloatImpls = 'v1';

interface TestFnNamedArgsSingleFloatImpl {
    run: ITestFnNamedArgsSingleFloat;
    name: TestFnNamedArgsSingleFloatImpls;
}

interface TestFnNamedArgsSingleFloatFunction {
  registerImpl: (name: TestFnNamedArgsSingleFloatImpls, impl: TestFnNamedArgsSingleFloatImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleFloatImpls) => TestFnNamedArgsSingleFloatImpl;
}

function createTestFnNamedArgsSingleFloatInstance(): ITestFnNamedArgsSingleFloat & TestFnNamedArgsSingleFloatFunction {

  const registry: Record<TestFnNamedArgsSingleFloatImpls, TestFnNamedArgsSingleFloatImpl> = {}

  const wrapper: TestFnNamedArgsSingleFloatFunction = {
    getImpl: (name: TestFnNamedArgsSingleFloatImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleFloat with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleFloatImpls, cb: ITestFnNamedArgsSingleFloat) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleFloat with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleFloat",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myFloat",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myFloat: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleFloat: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myFloat: number
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleFloat & TestFnNamedArgsSingleFloatFunction;
}

const TestFnNamedArgsSingleFloat = createTestFnNamedArgsSingleFloatInstance();

type ITestFnNamedArgsSingleInt = (args: {
  myInt: number
}) => Promise<string>

type TestFnNamedArgsSingleIntImpls = 'v1';

interface TestFnNamedArgsSingleIntImpl {
    run: ITestFnNamedArgsSingleInt;
    name: TestFnNamedArgsSingleIntImpls;
}

interface TestFnNamedArgsSingleIntFunction {
  registerImpl: (name: TestFnNamedArgsSingleIntImpls, impl: TestFnNamedArgsSingleIntImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleIntImpls) => TestFnNamedArgsSingleIntImpl;
}

function createTestFnNamedArgsSingleIntInstance(): ITestFnNamedArgsSingleInt & TestFnNamedArgsSingleIntFunction {

  const registry: Record<TestFnNamedArgsSingleIntImpls, TestFnNamedArgsSingleIntImpl> = {}

  const wrapper: TestFnNamedArgsSingleIntFunction = {
    getImpl: (name: TestFnNamedArgsSingleIntImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleInt with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleIntImpls, cb: ITestFnNamedArgsSingleInt) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleInt with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleInt",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myInt",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myInt: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleInt: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myInt: number
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleInt & TestFnNamedArgsSingleIntFunction;
}

const TestFnNamedArgsSingleInt = createTestFnNamedArgsSingleIntInstance();

type ITestFnNamedArgsSingleString = (args: {
  myString: string
}) => Promise<string>

type TestFnNamedArgsSingleStringImpls = 'v1';

interface TestFnNamedArgsSingleStringImpl {
    run: ITestFnNamedArgsSingleString;
    name: TestFnNamedArgsSingleStringImpls;
}

interface TestFnNamedArgsSingleStringFunction {
  registerImpl: (name: TestFnNamedArgsSingleStringImpls, impl: TestFnNamedArgsSingleStringImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleStringImpls) => TestFnNamedArgsSingleStringImpl;
}

function createTestFnNamedArgsSingleStringInstance(): ITestFnNamedArgsSingleString & TestFnNamedArgsSingleStringFunction {

  const registry: Record<TestFnNamedArgsSingleStringImpls, TestFnNamedArgsSingleStringImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleString with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringImpls, cb: ITestFnNamedArgsSingleString) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleString with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleString",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleString: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleString & TestFnNamedArgsSingleStringFunction;
}

const TestFnNamedArgsSingleString = createTestFnNamedArgsSingleStringInstance();

type ITestFnNamedArgsSingleStringArray = (args: {
  myStringArray: string[]
}) => Promise<string>

type TestFnNamedArgsSingleStringArrayImpls = 'v1';

interface TestFnNamedArgsSingleStringArrayImpl {
    run: ITestFnNamedArgsSingleStringArray;
    name: TestFnNamedArgsSingleStringArrayImpls;
}

interface TestFnNamedArgsSingleStringArrayFunction {
  registerImpl: (name: TestFnNamedArgsSingleStringArrayImpls, impl: TestFnNamedArgsSingleStringArrayImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleStringArrayImpls) => TestFnNamedArgsSingleStringArrayImpl;
}

function createTestFnNamedArgsSingleStringArrayInstance(): ITestFnNamedArgsSingleStringArray & TestFnNamedArgsSingleStringArrayFunction {

  const registry: Record<TestFnNamedArgsSingleStringArrayImpls, TestFnNamedArgsSingleStringArrayImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringArrayFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringArrayImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleStringArray with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringArrayImpls, cb: ITestFnNamedArgsSingleStringArray) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleStringArray with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleStringArray",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myStringArray",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myStringArray: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleStringArray: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myStringArray: string[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleStringArray & TestFnNamedArgsSingleStringArrayFunction;
}

const TestFnNamedArgsSingleStringArray = createTestFnNamedArgsSingleStringArrayInstance();

type ITestFnNamedArgsSingleStringList = (args: {
  myArg: string[]
}) => Promise<string>

type TestFnNamedArgsSingleStringListImpls = 'v1';

interface TestFnNamedArgsSingleStringListImpl {
    run: ITestFnNamedArgsSingleStringList;
    name: TestFnNamedArgsSingleStringListImpls;
}

interface TestFnNamedArgsSingleStringListFunction {
  registerImpl: (name: TestFnNamedArgsSingleStringListImpls, impl: TestFnNamedArgsSingleStringListImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleStringListImpls) => TestFnNamedArgsSingleStringListImpl;
}

function createTestFnNamedArgsSingleStringListInstance(): ITestFnNamedArgsSingleStringList & TestFnNamedArgsSingleStringListFunction {

  const registry: Record<TestFnNamedArgsSingleStringListImpls, TestFnNamedArgsSingleStringListImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringListFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringListImpls, cb: ITestFnNamedArgsSingleStringList) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleStringList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: string[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleStringList & TestFnNamedArgsSingleStringListFunction;
}

const TestFnNamedArgsSingleStringList = createTestFnNamedArgsSingleStringListInstance();

type ITestFnNamedArgsSyntax = (args: {
  var: string, var_with_underscores: string
}) => Promise<string>

type TestFnNamedArgsSyntaxImpls = never;

interface TestFnNamedArgsSyntaxImpl {
    run: ITestFnNamedArgsSyntax;
    name: TestFnNamedArgsSyntaxImpls;
}

interface TestFnNamedArgsSyntaxFunction {
  registerImpl: (name: TestFnNamedArgsSyntaxImpls, impl: TestFnNamedArgsSyntaxImpl) => void;
  getImpl: (name: TestFnNamedArgsSyntaxImpls) => TestFnNamedArgsSyntaxImpl;
}

function createTestFnNamedArgsSyntaxInstance(): ITestFnNamedArgsSyntax & TestFnNamedArgsSyntaxFunction {

  const registry: Record<TestFnNamedArgsSyntaxImpls, TestFnNamedArgsSyntaxImpl> = {}

  const wrapper: TestFnNamedArgsSyntaxFunction = {
    getImpl: (name: TestFnNamedArgsSyntaxImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSyntax with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSyntaxImpls, cb: ITestFnNamedArgsSyntax) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSyntax with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSyntax",
          /* returnType */ "string",
          /* paramters */ [
            [
              "var",
              "string"
            ],
            [
              "var_with_underscores",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            var: string, var_with_underscores: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
    }
  };

  const impl = async (params : {
    var: string, var_with_underscores: string
  }) => {
    throw new Error('No implementation for TestFnNamedArgsSyntax');
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSyntax & TestFnNamedArgsSyntaxFunction;
}

const TestFnNamedArgsSyntax = createTestFnNamedArgsSyntaxInstance();

type IUnionTest_Function = (arg: string | boolean) => Promise<UnionTest_ReturnType>

type UnionTest_FunctionImpls = 'v1';

interface UnionTest_FunctionImpl {
    run: IUnionTest_Function;
    name: UnionTest_FunctionImpls;
}

interface UnionTest_FunctionFunction {
  registerImpl: (name: UnionTest_FunctionImpls, impl: UnionTest_FunctionImpl) => void;
  getImpl: (name: UnionTest_FunctionImpls) => UnionTest_FunctionImpl;
}

function createUnionTest_FunctionInstance(): IUnionTest_Function & UnionTest_FunctionFunction {

  const registry: Record<UnionTest_FunctionImpls, UnionTest_FunctionImpl> = {}

  const wrapper: UnionTest_FunctionFunction = {
    getImpl: (name: UnionTest_FunctionImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for UnionTest_Function with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: UnionTest_FunctionImpls, cb: IUnionTest_Function) => {
      if (registry[name]) {
        throw new Error(`Implementation for UnionTest_Function with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"UnionTest_Function",
          /* returnType */ "UnionTest_ReturnType",
          /* paramters */ [
            [
              "arg",
              "string | boolean"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string | boolean
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for UnionTest_Function: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string | boolean) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);

  return impl as  IUnionTest_Function & UnionTest_FunctionFunction;
}

const UnionTest_Function = createUnionTest_FunctionInstance();

type IV2_FnClassOptional = (args: {
  input: OptionalClassv2 | null
}) => Promise<string>

type V2_FnClassOptionalImpls = 'default_config';

interface V2_FnClassOptionalImpl {
    run: IV2_FnClassOptional;
    name: V2_FnClassOptionalImpls;
}

interface V2_FnClassOptionalFunction {
  registerImpl: (name: V2_FnClassOptionalImpls, impl: V2_FnClassOptionalImpl) => void;
  getImpl: (name: V2_FnClassOptionalImpls) => V2_FnClassOptionalImpl;
}

function createV2_FnClassOptionalInstance(): IV2_FnClassOptional & V2_FnClassOptionalFunction {

  const registry: Record<V2_FnClassOptionalImpls, V2_FnClassOptionalImpl> = {}

  const wrapper: V2_FnClassOptionalFunction = {
    getImpl: (name: V2_FnClassOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnClassOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnClassOptionalImpls, cb: IV2_FnClassOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnClassOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnClassOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "input",
              "OptionalClassv2 | null"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: OptionalClassv2 | null
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnClassOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: OptionalClassv2 | null
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnClassOptional & V2_FnClassOptionalFunction;
}

const V2_FnClassOptional = createV2_FnClassOptionalInstance();

type IV2_FnClassOptional2 = (args: {
  input: ClassOptionalFieldsv2
}) => Promise<string>

type V2_FnClassOptional2Impls = 'default_config';

interface V2_FnClassOptional2Impl {
    run: IV2_FnClassOptional2;
    name: V2_FnClassOptional2Impls;
}

interface V2_FnClassOptional2Function {
  registerImpl: (name: V2_FnClassOptional2Impls, impl: V2_FnClassOptional2Impl) => void;
  getImpl: (name: V2_FnClassOptional2Impls) => V2_FnClassOptional2Impl;
}

function createV2_FnClassOptional2Instance(): IV2_FnClassOptional2 & V2_FnClassOptional2Function {

  const registry: Record<V2_FnClassOptional2Impls, V2_FnClassOptional2Impl> = {}

  const wrapper: V2_FnClassOptional2Function = {
    getImpl: (name: V2_FnClassOptional2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnClassOptional2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnClassOptional2Impls, cb: IV2_FnClassOptional2) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnClassOptional2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnClassOptional2",
          /* returnType */ "string",
          /* paramters */ [
            [
              "input",
              "ClassOptionalFieldsv2"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: ClassOptionalFieldsv2
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnClassOptional2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: ClassOptionalFieldsv2
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnClassOptional2 & V2_FnClassOptional2Function;
}

const V2_FnClassOptional2 = createV2_FnClassOptional2Instance();

type IV2_FnEnumListOutput = (args: {
  input: string
}) => Promise<EnumOutput[]>

type V2_FnEnumListOutputImpls = 'default_config';

interface V2_FnEnumListOutputImpl {
    run: IV2_FnEnumListOutput;
    name: V2_FnEnumListOutputImpls;
}

interface V2_FnEnumListOutputFunction {
  registerImpl: (name: V2_FnEnumListOutputImpls, impl: V2_FnEnumListOutputImpl) => void;
  getImpl: (name: V2_FnEnumListOutputImpls) => V2_FnEnumListOutputImpl;
}

function createV2_FnEnumListOutputInstance(): IV2_FnEnumListOutput & V2_FnEnumListOutputFunction {

  const registry: Record<V2_FnEnumListOutputImpls, V2_FnEnumListOutputImpl> = {}

  const wrapper: V2_FnEnumListOutputFunction = {
    getImpl: (name: V2_FnEnumListOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnEnumListOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnEnumListOutputImpls, cb: IV2_FnEnumListOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnEnumListOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnEnumListOutput",
          /* returnType */ "EnumOutput[]",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnEnumListOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnEnumListOutput & V2_FnEnumListOutputFunction;
}

const V2_FnEnumListOutput = createV2_FnEnumListOutputInstance();

type IV2_FnEnumOutput = (args: {
  input: string
}) => Promise<EnumOutput2>

type V2_FnEnumOutputImpls = 'default_config';

interface V2_FnEnumOutputImpl {
    run: IV2_FnEnumOutput;
    name: V2_FnEnumOutputImpls;
}

interface V2_FnEnumOutputFunction {
  registerImpl: (name: V2_FnEnumOutputImpls, impl: V2_FnEnumOutputImpl) => void;
  getImpl: (name: V2_FnEnumOutputImpls) => V2_FnEnumOutputImpl;
}

function createV2_FnEnumOutputInstance(): IV2_FnEnumOutput & V2_FnEnumOutputFunction {

  const registry: Record<V2_FnEnumOutputImpls, V2_FnEnumOutputImpl> = {}

  const wrapper: V2_FnEnumOutputFunction = {
    getImpl: (name: V2_FnEnumOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnEnumOutputImpls, cb: IV2_FnEnumOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnEnumOutput",
          /* returnType */ "EnumOutput2",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnEnumOutput & V2_FnEnumOutputFunction;
}

const V2_FnEnumOutput = createV2_FnEnumOutputInstance();

type IV2_FnNamedArgsSingleStringOptional = (args: {
  myString: string | null
}) => Promise<string>

type V2_FnNamedArgsSingleStringOptionalImpls = 'default_config';

interface V2_FnNamedArgsSingleStringOptionalImpl {
    run: IV2_FnNamedArgsSingleStringOptional;
    name: V2_FnNamedArgsSingleStringOptionalImpls;
}

interface V2_FnNamedArgsSingleStringOptionalFunction {
  registerImpl: (name: V2_FnNamedArgsSingleStringOptionalImpls, impl: V2_FnNamedArgsSingleStringOptionalImpl) => void;
  getImpl: (name: V2_FnNamedArgsSingleStringOptionalImpls) => V2_FnNamedArgsSingleStringOptionalImpl;
}

function createV2_FnNamedArgsSingleStringOptionalInstance(): IV2_FnNamedArgsSingleStringOptional & V2_FnNamedArgsSingleStringOptionalFunction {

  const registry: Record<V2_FnNamedArgsSingleStringOptionalImpls, V2_FnNamedArgsSingleStringOptionalImpl> = {}

  const wrapper: V2_FnNamedArgsSingleStringOptionalFunction = {
    getImpl: (name: V2_FnNamedArgsSingleStringOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnNamedArgsSingleStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnNamedArgsSingleStringOptionalImpls, cb: IV2_FnNamedArgsSingleStringOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnNamedArgsSingleStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnNamedArgsSingleStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string | null"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string | null
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnNamedArgsSingleStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string | null
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnNamedArgsSingleStringOptional & V2_FnNamedArgsSingleStringOptionalFunction;
}

const V2_FnNamedArgsSingleStringOptional = createV2_FnNamedArgsSingleStringOptionalInstance();

type IV2_FnOutputBool = (args: {
  input: string
}) => Promise<boolean>

type V2_FnOutputBoolImpls = 'default_config';

interface V2_FnOutputBoolImpl {
    run: IV2_FnOutputBool;
    name: V2_FnOutputBoolImpls;
}

interface V2_FnOutputBoolFunction {
  registerImpl: (name: V2_FnOutputBoolImpls, impl: V2_FnOutputBoolImpl) => void;
  getImpl: (name: V2_FnOutputBoolImpls) => V2_FnOutputBoolImpl;
}

function createV2_FnOutputBoolInstance(): IV2_FnOutputBool & V2_FnOutputBoolFunction {

  const registry: Record<V2_FnOutputBoolImpls, V2_FnOutputBoolImpl> = {}

  const wrapper: V2_FnOutputBoolFunction = {
    getImpl: (name: V2_FnOutputBoolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnOutputBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnOutputBoolImpls, cb: IV2_FnOutputBool) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnOutputBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnOutputBool",
          /* returnType */ "boolean",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnOutputBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnOutputBool & V2_FnOutputBoolFunction;
}

const V2_FnOutputBool = createV2_FnOutputBoolInstance();

type IV2_FnOutputClass = (args: {
  input: string
}) => Promise<TestOutputClass2>

type V2_FnOutputClassImpls = 'default_config';

interface V2_FnOutputClassImpl {
    run: IV2_FnOutputClass;
    name: V2_FnOutputClassImpls;
}

interface V2_FnOutputClassFunction {
  registerImpl: (name: V2_FnOutputClassImpls, impl: V2_FnOutputClassImpl) => void;
  getImpl: (name: V2_FnOutputClassImpls) => V2_FnOutputClassImpl;
}

function createV2_FnOutputClassInstance(): IV2_FnOutputClass & V2_FnOutputClassFunction {

  const registry: Record<V2_FnOutputClassImpls, V2_FnOutputClassImpl> = {}

  const wrapper: V2_FnOutputClassFunction = {
    getImpl: (name: V2_FnOutputClassImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnOutputClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnOutputClassImpls, cb: IV2_FnOutputClass) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnOutputClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnOutputClass",
          /* returnType */ "TestOutputClass2",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnOutputClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnOutputClass & V2_FnOutputClassFunction;
}

const V2_FnOutputClass = createV2_FnOutputClassInstance();

type IV2_FnOutputClassList = (args: {
  input: string
}) => Promise<TestOutputClass[]>

type V2_FnOutputClassListImpls = 'default_config';

interface V2_FnOutputClassListImpl {
    run: IV2_FnOutputClassList;
    name: V2_FnOutputClassListImpls;
}

interface V2_FnOutputClassListFunction {
  registerImpl: (name: V2_FnOutputClassListImpls, impl: V2_FnOutputClassListImpl) => void;
  getImpl: (name: V2_FnOutputClassListImpls) => V2_FnOutputClassListImpl;
}

function createV2_FnOutputClassListInstance(): IV2_FnOutputClassList & V2_FnOutputClassListFunction {

  const registry: Record<V2_FnOutputClassListImpls, V2_FnOutputClassListImpl> = {}

  const wrapper: V2_FnOutputClassListFunction = {
    getImpl: (name: V2_FnOutputClassListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnOutputClassList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnOutputClassListImpls, cb: IV2_FnOutputClassList) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnOutputClassList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnOutputClassList",
          /* returnType */ "TestOutputClass[]",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnOutputClassList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnOutputClassList & V2_FnOutputClassListFunction;
}

const V2_FnOutputClassList = createV2_FnOutputClassListInstance();

type IV2_FnOutputStringList = (args: {
  input: string
}) => Promise<string[]>

type V2_FnOutputStringListImpls = 'default_config';

interface V2_FnOutputStringListImpl {
    run: IV2_FnOutputStringList;
    name: V2_FnOutputStringListImpls;
}

interface V2_FnOutputStringListFunction {
  registerImpl: (name: V2_FnOutputStringListImpls, impl: V2_FnOutputStringListImpl) => void;
  getImpl: (name: V2_FnOutputStringListImpls) => V2_FnOutputStringListImpl;
}

function createV2_FnOutputStringListInstance(): IV2_FnOutputStringList & V2_FnOutputStringListFunction {

  const registry: Record<V2_FnOutputStringListImpls, V2_FnOutputStringListImpl> = {}

  const wrapper: V2_FnOutputStringListFunction = {
    getImpl: (name: V2_FnOutputStringListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnOutputStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnOutputStringListImpls, cb: IV2_FnOutputStringList) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnOutputStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnOutputStringList",
          /* returnType */ "string[]",
          /* paramters */ [
            [
              "input",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnOutputStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnOutputStringList & V2_FnOutputStringListFunction;
}

const V2_FnOutputStringList = createV2_FnOutputStringListInstance();

type IV2_FnStringOptional = (args: {
  input: string | null
}) => Promise<string>

type V2_FnStringOptionalImpls = 'default_config';

interface V2_FnStringOptionalImpl {
    run: IV2_FnStringOptional;
    name: V2_FnStringOptionalImpls;
}

interface V2_FnStringOptionalFunction {
  registerImpl: (name: V2_FnStringOptionalImpls, impl: V2_FnStringOptionalImpl) => void;
  getImpl: (name: V2_FnStringOptionalImpls) => V2_FnStringOptionalImpl;
}

function createV2_FnStringOptionalInstance(): IV2_FnStringOptional & V2_FnStringOptionalFunction {

  const registry: Record<V2_FnStringOptionalImpls, V2_FnStringOptionalImpl> = {}

  const wrapper: V2_FnStringOptionalFunction = {
    getImpl: (name: V2_FnStringOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnStringOptionalImpls, cb: IV2_FnStringOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "input",
              "string | null"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string | null
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string | null
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnStringOptional & V2_FnStringOptionalFunction;
}

const V2_FnStringOptional = createV2_FnStringOptionalInstance();

type IV2_FnTestNamedArgsSingleEnum = (args: {
  myArg: NamedArgsSingleEnum2
}) => Promise<string>

type V2_FnTestNamedArgsSingleEnumImpls = 'default_config';

interface V2_FnTestNamedArgsSingleEnumImpl {
    run: IV2_FnTestNamedArgsSingleEnum;
    name: V2_FnTestNamedArgsSingleEnumImpls;
}

interface V2_FnTestNamedArgsSingleEnumFunction {
  registerImpl: (name: V2_FnTestNamedArgsSingleEnumImpls, impl: V2_FnTestNamedArgsSingleEnumImpl) => void;
  getImpl: (name: V2_FnTestNamedArgsSingleEnumImpls) => V2_FnTestNamedArgsSingleEnumImpl;
}

function createV2_FnTestNamedArgsSingleEnumInstance(): IV2_FnTestNamedArgsSingleEnum & V2_FnTestNamedArgsSingleEnumFunction {

  const registry: Record<V2_FnTestNamedArgsSingleEnumImpls, V2_FnTestNamedArgsSingleEnumImpl> = {}

  const wrapper: V2_FnTestNamedArgsSingleEnumFunction = {
    getImpl: (name: V2_FnTestNamedArgsSingleEnumImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_FnTestNamedArgsSingleEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_FnTestNamedArgsSingleEnumImpls, cb: IV2_FnTestNamedArgsSingleEnum) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_FnTestNamedArgsSingleEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_FnTestNamedArgsSingleEnum",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnum2"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnum2
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_FnTestNamedArgsSingleEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnum2
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_FnTestNamedArgsSingleEnum & V2_FnTestNamedArgsSingleEnumFunction;
}

const V2_FnTestNamedArgsSingleEnum = createV2_FnTestNamedArgsSingleEnumInstance();

type IV2_TestFnNamedArgsSingleBool = (args: {
  myBool: boolean
}) => Promise<string>

type V2_TestFnNamedArgsSingleBoolImpls = 'default_config';

interface V2_TestFnNamedArgsSingleBoolImpl {
    run: IV2_TestFnNamedArgsSingleBool;
    name: V2_TestFnNamedArgsSingleBoolImpls;
}

interface V2_TestFnNamedArgsSingleBoolFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleBoolImpls, impl: V2_TestFnNamedArgsSingleBoolImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleBoolImpls) => V2_TestFnNamedArgsSingleBoolImpl;
}

function createV2_TestFnNamedArgsSingleBoolInstance(): IV2_TestFnNamedArgsSingleBool & V2_TestFnNamedArgsSingleBoolFunction {

  const registry: Record<V2_TestFnNamedArgsSingleBoolImpls, V2_TestFnNamedArgsSingleBoolImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleBoolFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleBoolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleBoolImpls, cb: IV2_TestFnNamedArgsSingleBool) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleBool",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myBool",
              "boolean"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myBool: boolean
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myBool: boolean
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleBool & V2_TestFnNamedArgsSingleBoolFunction;
}

const V2_TestFnNamedArgsSingleBool = createV2_TestFnNamedArgsSingleBoolInstance();

type IV2_TestFnNamedArgsSingleClass = (args: {
  myArg: NamedArgsSingleClass2
}) => Promise<string>

type V2_TestFnNamedArgsSingleClassImpls = 'default_config';

interface V2_TestFnNamedArgsSingleClassImpl {
    run: IV2_TestFnNamedArgsSingleClass;
    name: V2_TestFnNamedArgsSingleClassImpls;
}

interface V2_TestFnNamedArgsSingleClassFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleClassImpls, impl: V2_TestFnNamedArgsSingleClassImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleClassImpls) => V2_TestFnNamedArgsSingleClassImpl;
}

function createV2_TestFnNamedArgsSingleClassInstance(): IV2_TestFnNamedArgsSingleClass & V2_TestFnNamedArgsSingleClassFunction {

  const registry: Record<V2_TestFnNamedArgsSingleClassImpls, V2_TestFnNamedArgsSingleClassImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleClassFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleClassImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleClassImpls, cb: IV2_TestFnNamedArgsSingleClass) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleClass",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleClass2"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleClass2
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleClass2
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleClass & V2_TestFnNamedArgsSingleClassFunction;
}

const V2_TestFnNamedArgsSingleClass = createV2_TestFnNamedArgsSingleClassInstance();

type IV2_TestFnNamedArgsSingleEnumList = (args: {
  myArg: NamedArgsSingleEnumList2[]
}) => Promise<string>

type V2_TestFnNamedArgsSingleEnumListImpls = 'default_config';

interface V2_TestFnNamedArgsSingleEnumListImpl {
    run: IV2_TestFnNamedArgsSingleEnumList;
    name: V2_TestFnNamedArgsSingleEnumListImpls;
}

interface V2_TestFnNamedArgsSingleEnumListFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleEnumListImpls, impl: V2_TestFnNamedArgsSingleEnumListImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleEnumListImpls) => V2_TestFnNamedArgsSingleEnumListImpl;
}

function createV2_TestFnNamedArgsSingleEnumListInstance(): IV2_TestFnNamedArgsSingleEnumList & V2_TestFnNamedArgsSingleEnumListFunction {

  const registry: Record<V2_TestFnNamedArgsSingleEnumListImpls, V2_TestFnNamedArgsSingleEnumListImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleEnumListFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleEnumListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleEnumList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleEnumListImpls, cb: IV2_TestFnNamedArgsSingleEnumList) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleEnumList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleEnumList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnumList2[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnumList2[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleEnumList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnumList2[]
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleEnumList & V2_TestFnNamedArgsSingleEnumListFunction;
}

const V2_TestFnNamedArgsSingleEnumList = createV2_TestFnNamedArgsSingleEnumListInstance();

type IV2_TestFnNamedArgsSingleFloat = (args: {
  myFloat: number
}) => Promise<string>

type V2_TestFnNamedArgsSingleFloatImpls = 'default_config';

interface V2_TestFnNamedArgsSingleFloatImpl {
    run: IV2_TestFnNamedArgsSingleFloat;
    name: V2_TestFnNamedArgsSingleFloatImpls;
}

interface V2_TestFnNamedArgsSingleFloatFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleFloatImpls, impl: V2_TestFnNamedArgsSingleFloatImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleFloatImpls) => V2_TestFnNamedArgsSingleFloatImpl;
}

function createV2_TestFnNamedArgsSingleFloatInstance(): IV2_TestFnNamedArgsSingleFloat & V2_TestFnNamedArgsSingleFloatFunction {

  const registry: Record<V2_TestFnNamedArgsSingleFloatImpls, V2_TestFnNamedArgsSingleFloatImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleFloatFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleFloatImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleFloat with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleFloatImpls, cb: IV2_TestFnNamedArgsSingleFloat) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleFloat with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleFloat",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myFloat",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myFloat: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleFloat: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myFloat: number
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleFloat & V2_TestFnNamedArgsSingleFloatFunction;
}

const V2_TestFnNamedArgsSingleFloat = createV2_TestFnNamedArgsSingleFloatInstance();

type IV2_TestFnNamedArgsSingleInt = (args: {
  myInt: number
}) => Promise<string>

type V2_TestFnNamedArgsSingleIntImpls = 'default_config';

interface V2_TestFnNamedArgsSingleIntImpl {
    run: IV2_TestFnNamedArgsSingleInt;
    name: V2_TestFnNamedArgsSingleIntImpls;
}

interface V2_TestFnNamedArgsSingleIntFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleIntImpls, impl: V2_TestFnNamedArgsSingleIntImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleIntImpls) => V2_TestFnNamedArgsSingleIntImpl;
}

function createV2_TestFnNamedArgsSingleIntInstance(): IV2_TestFnNamedArgsSingleInt & V2_TestFnNamedArgsSingleIntFunction {

  const registry: Record<V2_TestFnNamedArgsSingleIntImpls, V2_TestFnNamedArgsSingleIntImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleIntFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleIntImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleInt with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleIntImpls, cb: IV2_TestFnNamedArgsSingleInt) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleInt with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleInt",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myInt",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myInt: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleInt: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myInt: number
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleInt & V2_TestFnNamedArgsSingleIntFunction;
}

const V2_TestFnNamedArgsSingleInt = createV2_TestFnNamedArgsSingleIntInstance();

type IV2_TestFnNamedArgsSingleString = (args: {
  myString: string
}) => Promise<string>

type V2_TestFnNamedArgsSingleStringImpls = 'default_config';

interface V2_TestFnNamedArgsSingleStringImpl {
    run: IV2_TestFnNamedArgsSingleString;
    name: V2_TestFnNamedArgsSingleStringImpls;
}

interface V2_TestFnNamedArgsSingleStringFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleStringImpls, impl: V2_TestFnNamedArgsSingleStringImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleStringImpls) => V2_TestFnNamedArgsSingleStringImpl;
}

function createV2_TestFnNamedArgsSingleStringInstance(): IV2_TestFnNamedArgsSingleString & V2_TestFnNamedArgsSingleStringFunction {

  const registry: Record<V2_TestFnNamedArgsSingleStringImpls, V2_TestFnNamedArgsSingleStringImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleStringFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleStringImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleString with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleStringImpls, cb: IV2_TestFnNamedArgsSingleString) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleString with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleString",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleString: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleString & V2_TestFnNamedArgsSingleStringFunction;
}

const V2_TestFnNamedArgsSingleString = createV2_TestFnNamedArgsSingleStringInstance();

type IV2_TestFnNamedArgsSingleStringArray = (args: {
  myStringArray: string[]
}) => Promise<string>

type V2_TestFnNamedArgsSingleStringArrayImpls = 'default_config';

interface V2_TestFnNamedArgsSingleStringArrayImpl {
    run: IV2_TestFnNamedArgsSingleStringArray;
    name: V2_TestFnNamedArgsSingleStringArrayImpls;
}

interface V2_TestFnNamedArgsSingleStringArrayFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleStringArrayImpls, impl: V2_TestFnNamedArgsSingleStringArrayImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleStringArrayImpls) => V2_TestFnNamedArgsSingleStringArrayImpl;
}

function createV2_TestFnNamedArgsSingleStringArrayInstance(): IV2_TestFnNamedArgsSingleStringArray & V2_TestFnNamedArgsSingleStringArrayFunction {

  const registry: Record<V2_TestFnNamedArgsSingleStringArrayImpls, V2_TestFnNamedArgsSingleStringArrayImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleStringArrayFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleStringArrayImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleStringArray with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleStringArrayImpls, cb: IV2_TestFnNamedArgsSingleStringArray) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleStringArray with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleStringArray",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myStringArray",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myStringArray: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleStringArray: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myStringArray: string[]
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleStringArray & V2_TestFnNamedArgsSingleStringArrayFunction;
}

const V2_TestFnNamedArgsSingleStringArray = createV2_TestFnNamedArgsSingleStringArrayInstance();

type IV2_TestFnNamedArgsSingleStringList = (args: {
  myArg: NamedArgsSingleClassList2[]
}) => Promise<string>

type V2_TestFnNamedArgsSingleStringListImpls = 'default_config';

interface V2_TestFnNamedArgsSingleStringListImpl {
    run: IV2_TestFnNamedArgsSingleStringList;
    name: V2_TestFnNamedArgsSingleStringListImpls;
}

interface V2_TestFnNamedArgsSingleStringListFunction {
  registerImpl: (name: V2_TestFnNamedArgsSingleStringListImpls, impl: V2_TestFnNamedArgsSingleStringListImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSingleStringListImpls) => V2_TestFnNamedArgsSingleStringListImpl;
}

function createV2_TestFnNamedArgsSingleStringListInstance(): IV2_TestFnNamedArgsSingleStringList & V2_TestFnNamedArgsSingleStringListFunction {

  const registry: Record<V2_TestFnNamedArgsSingleStringListImpls, V2_TestFnNamedArgsSingleStringListImpl> = {}

  const wrapper: V2_TestFnNamedArgsSingleStringListFunction = {
    getImpl: (name: V2_TestFnNamedArgsSingleStringListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSingleStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSingleStringListImpls, cb: IV2_TestFnNamedArgsSingleStringList) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSingleStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSingleStringList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleClassList2[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleClassList2[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSingleStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleClassList2[]
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSingleStringList & V2_TestFnNamedArgsSingleStringListFunction;
}

const V2_TestFnNamedArgsSingleStringList = createV2_TestFnNamedArgsSingleStringListInstance();

type IV2_TestFnNamedArgsSyntax = (args: {
  var: string, var_with_underscores: string
}) => Promise<string>

type V2_TestFnNamedArgsSyntaxImpls = 'default_config';

interface V2_TestFnNamedArgsSyntaxImpl {
    run: IV2_TestFnNamedArgsSyntax;
    name: V2_TestFnNamedArgsSyntaxImpls;
}

interface V2_TestFnNamedArgsSyntaxFunction {
  registerImpl: (name: V2_TestFnNamedArgsSyntaxImpls, impl: V2_TestFnNamedArgsSyntaxImpl) => void;
  getImpl: (name: V2_TestFnNamedArgsSyntaxImpls) => V2_TestFnNamedArgsSyntaxImpl;
}

function createV2_TestFnNamedArgsSyntaxInstance(): IV2_TestFnNamedArgsSyntax & V2_TestFnNamedArgsSyntaxFunction {

  const registry: Record<V2_TestFnNamedArgsSyntaxImpls, V2_TestFnNamedArgsSyntaxImpl> = {}

  const wrapper: V2_TestFnNamedArgsSyntaxFunction = {
    getImpl: (name: V2_TestFnNamedArgsSyntaxImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_TestFnNamedArgsSyntax with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_TestFnNamedArgsSyntaxImpls, cb: IV2_TestFnNamedArgsSyntax) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_TestFnNamedArgsSyntax with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_TestFnNamedArgsSyntax",
          /* returnType */ "string",
          /* paramters */ [
            [
              "var",
              "string"
            ],
            [
              "var_with_underscores",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            var: string, var_with_underscores: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_TestFnNamedArgsSyntax: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    var: string, var_with_underscores: string
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_TestFnNamedArgsSyntax & V2_TestFnNamedArgsSyntaxFunction;
}

const V2_TestFnNamedArgsSyntax = createV2_TestFnNamedArgsSyntaxInstance();

type IV2_UnionTest_Function = (args: {
  input: string | boolean
}) => Promise<UnionTest_ReturnTypev2>

type V2_UnionTest_FunctionImpls = 'default_config';

interface V2_UnionTest_FunctionImpl {
    run: IV2_UnionTest_Function;
    name: V2_UnionTest_FunctionImpls;
}

interface V2_UnionTest_FunctionFunction {
  registerImpl: (name: V2_UnionTest_FunctionImpls, impl: V2_UnionTest_FunctionImpl) => void;
  getImpl: (name: V2_UnionTest_FunctionImpls) => V2_UnionTest_FunctionImpl;
}

function createV2_UnionTest_FunctionInstance(): IV2_UnionTest_Function & V2_UnionTest_FunctionFunction {

  const registry: Record<V2_UnionTest_FunctionImpls, V2_UnionTest_FunctionImpl> = {}

  const wrapper: V2_UnionTest_FunctionFunction = {
    getImpl: (name: V2_UnionTest_FunctionImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for V2_UnionTest_Function with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: V2_UnionTest_FunctionImpls, cb: IV2_UnionTest_Function) => {
      if (registry[name]) {
        throw new Error(`Implementation for V2_UnionTest_Function with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"V2_UnionTest_Function",
          /* returnType */ "UnionTest_ReturnTypev2",
          /* paramters */ [
            [
              "input",
              "string | boolean"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            input: string | boolean
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['default_config'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for V2_UnionTest_Function: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    input: string | boolean
  }) => {
    return wrapper.getImpl('default_config').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IV2_UnionTest_Function & V2_UnionTest_FunctionFunction;
}

const V2_UnionTest_Function = createV2_UnionTest_FunctionInstance();


export { ClassifyMessage, IClassifyMessage, ClassifyMessageFunction, ClassifyMessage2, IClassifyMessage2, ClassifyMessage2Function, ClassifyMessage3, IClassifyMessage3, ClassifyMessage3Function, ExtractNames, IExtractNames, ExtractNamesFunction, ExtractResume, IExtractResume, ExtractResumeFunction, ExtractResume2, IExtractResume2, ExtractResume2Function, FnClassOptional, IFnClassOptional, FnClassOptionalFunction, FnClassOptional2, IFnClassOptional2, FnClassOptional2Function, FnClassOptionalOutput, IFnClassOptionalOutput, FnClassOptionalOutputFunction, FnClassOptionalOutput2, IFnClassOptionalOutput2, FnClassOptionalOutput2Function, FnClassOptionalOutput2_V2, IFnClassOptionalOutput2_V2, FnClassOptionalOutput2_V2Function, FnEnumListOutput, IFnEnumListOutput, FnEnumListOutputFunction, FnEnumOutput, IFnEnumOutput, FnEnumOutputFunction, FnNamedArgsSingleStringOptional, IFnNamedArgsSingleStringOptional, FnNamedArgsSingleStringOptionalFunction, FnOutputBool, IFnOutputBool, FnOutputBoolFunction, FnOutputClass, IFnOutputClass, FnOutputClassFunction, FnOutputClassList, IFnOutputClassList, FnOutputClassListFunction, FnOutputClassWithEnum, IFnOutputClassWithEnum, FnOutputClassWithEnumFunction, FnOutputClassWithEnum_V2, IFnOutputClassWithEnum_V2, FnOutputClassWithEnum_V2Function, FnOutputStringList, IFnOutputStringList, FnOutputStringListFunction, FnStringOptional, IFnStringOptional, FnStringOptionalFunction, FnTestAliasedEnumOutput, IFnTestAliasedEnumOutput, FnTestAliasedEnumOutputFunction, FnTestClassAlias, IFnTestClassAlias, FnTestClassAliasFunction, FnTestClassOverride, IFnTestClassOverride, FnTestClassOverrideFunction, FnTestEnumOverride, IFnTestEnumOverride, FnTestEnumOverrideFunction, FnTestNamedArgsSingleEnum, IFnTestNamedArgsSingleEnum, FnTestNamedArgsSingleEnumFunction, FnTestOutputAdapter, IFnTestOutputAdapter, FnTestOutputAdapterFunction, GetDataType, IGetDataType, GetDataTypeFunction, GetOrderInfo, IGetOrderInfo, GetOrderInfoFunction, GetQuery, IGetQuery, GetQueryFunction, OptionalTest_Function, IOptionalTest_Function, OptionalTest_FunctionFunction, OptionalTest_Function_V2, IOptionalTest_Function_V2, OptionalTest_Function_V2Function, PromptTest, IPromptTest, PromptTestFunction, TestFnNamedArgsSingleBool, ITestFnNamedArgsSingleBool, TestFnNamedArgsSingleBoolFunction, TestFnNamedArgsSingleClass, ITestFnNamedArgsSingleClass, TestFnNamedArgsSingleClassFunction, TestFnNamedArgsSingleEnumList, ITestFnNamedArgsSingleEnumList, TestFnNamedArgsSingleEnumListFunction, TestFnNamedArgsSingleFloat, ITestFnNamedArgsSingleFloat, TestFnNamedArgsSingleFloatFunction, TestFnNamedArgsSingleInt, ITestFnNamedArgsSingleInt, TestFnNamedArgsSingleIntFunction, TestFnNamedArgsSingleString, ITestFnNamedArgsSingleString, TestFnNamedArgsSingleStringFunction, TestFnNamedArgsSingleStringArray, ITestFnNamedArgsSingleStringArray, TestFnNamedArgsSingleStringArrayFunction, TestFnNamedArgsSingleStringList, ITestFnNamedArgsSingleStringList, TestFnNamedArgsSingleStringListFunction, TestFnNamedArgsSyntax, ITestFnNamedArgsSyntax, TestFnNamedArgsSyntaxFunction, UnionTest_Function, IUnionTest_Function, UnionTest_FunctionFunction, V2_FnClassOptional, IV2_FnClassOptional, V2_FnClassOptionalFunction, V2_FnClassOptional2, IV2_FnClassOptional2, V2_FnClassOptional2Function, V2_FnEnumListOutput, IV2_FnEnumListOutput, V2_FnEnumListOutputFunction, V2_FnEnumOutput, IV2_FnEnumOutput, V2_FnEnumOutputFunction, V2_FnNamedArgsSingleStringOptional, IV2_FnNamedArgsSingleStringOptional, V2_FnNamedArgsSingleStringOptionalFunction, V2_FnOutputBool, IV2_FnOutputBool, V2_FnOutputBoolFunction, V2_FnOutputClass, IV2_FnOutputClass, V2_FnOutputClassFunction, V2_FnOutputClassList, IV2_FnOutputClassList, V2_FnOutputClassListFunction, V2_FnOutputStringList, IV2_FnOutputStringList, V2_FnOutputStringListFunction, V2_FnStringOptional, IV2_FnStringOptional, V2_FnStringOptionalFunction, V2_FnTestNamedArgsSingleEnum, IV2_FnTestNamedArgsSingleEnum, V2_FnTestNamedArgsSingleEnumFunction, V2_TestFnNamedArgsSingleBool, IV2_TestFnNamedArgsSingleBool, V2_TestFnNamedArgsSingleBoolFunction, V2_TestFnNamedArgsSingleClass, IV2_TestFnNamedArgsSingleClass, V2_TestFnNamedArgsSingleClassFunction, V2_TestFnNamedArgsSingleEnumList, IV2_TestFnNamedArgsSingleEnumList, V2_TestFnNamedArgsSingleEnumListFunction, V2_TestFnNamedArgsSingleFloat, IV2_TestFnNamedArgsSingleFloat, V2_TestFnNamedArgsSingleFloatFunction, V2_TestFnNamedArgsSingleInt, IV2_TestFnNamedArgsSingleInt, V2_TestFnNamedArgsSingleIntFunction, V2_TestFnNamedArgsSingleString, IV2_TestFnNamedArgsSingleString, V2_TestFnNamedArgsSingleStringFunction, V2_TestFnNamedArgsSingleStringArray, IV2_TestFnNamedArgsSingleStringArray, V2_TestFnNamedArgsSingleStringArrayFunction, V2_TestFnNamedArgsSingleStringList, IV2_TestFnNamedArgsSingleStringList, V2_TestFnNamedArgsSingleStringListFunction, V2_TestFnNamedArgsSyntax, IV2_TestFnNamedArgsSyntax, V2_TestFnNamedArgsSyntaxFunction, V2_UnionTest_Function, IV2_UnionTest_Function, V2_UnionTest_FunctionFunction }

