// This file is auto-generated. Do not edit this file manually.
//
// Disable formatting for this file to avoid linting errors.
// tslint:disable
// @ts-nocheck


import { Resume, Category } from './types';
import { traceAsync, FireBamlEvent } from '@boundaryml/baml-core/ffi_layer';


type IClassifyMessage = (args: {
  message: string, message_date: string
}) => Promise<Category[]>

type ClassifyMessageImpls = 'level1';

interface ClassifyMessageImpl {
    run: IClassifyMessage;
    name: ClassifyMessageImpls;
}

interface ClassifyMessageFunction {
  registerImpl: (name: ClassifyMessageImpls, impl: ClassifyMessageImpl) => void;
  getImpl: (name: ClassifyMessageImpls) => ClassifyMessageImpl;
}

function createClassifyMessageInstance(): IClassifyMessage & ClassifyMessageFunction {

  const registry: Record<ClassifyMessageImpls, ClassifyMessageImpl> = {}

  const wrapper: ClassifyMessageFunction = {
    getImpl: (name: ClassifyMessageImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ClassifyMessage with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ClassifyMessageImpls, cb: IClassifyMessage) => {
      if (registry[name]) {
        throw new Error(`Implementation for ClassifyMessage with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ClassifyMessage",
          /* returnType */ "Category[]",
          /* paramters */ [
            [
              "message",
              "string"
            ],
            [
              "message_date",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            message: string, message_date: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['level1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ClassifyMessage: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    message: string, message_date: string
  }) => {
    return wrapper.getImpl('level1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IClassifyMessage & ClassifyMessageFunction;
}

const ClassifyMessage = createClassifyMessageInstance();

type IExtractResume = (arg: string) => Promise<Resume>

type ExtractResumeImpls = 'version1';

interface ExtractResumeImpl {
    run: IExtractResume;
    name: ExtractResumeImpls;
}

interface ExtractResumeFunction {
  registerImpl: (name: ExtractResumeImpls, impl: ExtractResumeImpl) => void;
  getImpl: (name: ExtractResumeImpls) => ExtractResumeImpl;
}

function createExtractResumeInstance(): IExtractResume & ExtractResumeFunction {

  const registry: Record<ExtractResumeImpls, ExtractResumeImpl> = {}

  const wrapper: ExtractResumeFunction = {
    getImpl: (name: ExtractResumeImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractResume with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractResumeImpls, cb: IExtractResume) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractResume with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"ExtractResume",
          /* returnType */ "Resume",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['version1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractResume: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('version1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractResume & ExtractResumeFunction;
}

const ExtractResume = createExtractResumeInstance();


export { ClassifyMessage, IClassifyMessage, ClassifyMessageFunction, ExtractResume, IExtractResume, ExtractResumeFunction }