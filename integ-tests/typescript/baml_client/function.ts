// This file is auto-generated. Do not edit this file manually.
//
// Disable formatting for this file to avoid linting errors.
// tslint:disable
// @ts-nocheck
/* eslint-disable */


import { ClassOptionalFields, ClassOptionalOutput, ClassOptionalOutput2, EnumOutput, NamedArgsSingleClass, NamedArgsSingleEnum, NamedArgsSingleEnumList, OptionalClass, OverrideClass, OverrideEnum, TestClassAlias, TestClassWithEnum, TestEnum, TestOutputClass } from './types';
import { FireBamlEvent, traceAsync } from '@boundaryml/baml-core/ffi_layer';


type IFnClassOptional = (arg: OptionalClass | null) => Promise<string>

type FnClassOptionalImpls = 'v1';

interface FnClassOptionalImpl {
    run: IFnClassOptional;
    name: FnClassOptionalImpls;
}

interface FnClassOptionalFunction {
  registerImpl: (name: FnClassOptionalImpls, impl: FnClassOptionalImpl) => void;
  getImpl: (name: FnClassOptionalImpls) => FnClassOptionalImpl;
}

function createFnClassOptionalInstance(): IFnClassOptional & FnClassOptionalFunction {

  const registry: Record<FnClassOptionalImpls, FnClassOptionalImpl> = {}

  const wrapper: FnClassOptionalFunction = {
    getImpl: (name: FnClassOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalImpls, cb: IFnClassOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "OptionalClass | null"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: OptionalClass | null
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: OptionalClass | null) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptional & FnClassOptionalFunction;
}

const FnClassOptional = createFnClassOptionalInstance();

type IFnClassOptional2 = (arg: ClassOptionalFields) => Promise<string>

type FnClassOptional2Impls = 'v1';

interface FnClassOptional2Impl {
    run: IFnClassOptional2;
    name: FnClassOptional2Impls;
}

interface FnClassOptional2Function {
  registerImpl: (name: FnClassOptional2Impls, impl: FnClassOptional2Impl) => void;
  getImpl: (name: FnClassOptional2Impls) => FnClassOptional2Impl;
}

function createFnClassOptional2Instance(): IFnClassOptional2 & FnClassOptional2Function {

  const registry: Record<FnClassOptional2Impls, FnClassOptional2Impl> = {}

  const wrapper: FnClassOptional2Function = {
    getImpl: (name: FnClassOptional2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptional2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptional2Impls, cb: IFnClassOptional2) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptional2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptional2",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "ClassOptionalFields"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: ClassOptionalFields
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptional2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: ClassOptionalFields) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptional2 & FnClassOptional2Function;
}

const FnClassOptional2 = createFnClassOptional2Instance();

type IFnClassOptionalOutput = (arg: string) => Promise<ClassOptionalOutput | null>

type FnClassOptionalOutputImpls = 'v1';

interface FnClassOptionalOutputImpl {
    run: IFnClassOptionalOutput;
    name: FnClassOptionalOutputImpls;
}

interface FnClassOptionalOutputFunction {
  registerImpl: (name: FnClassOptionalOutputImpls, impl: FnClassOptionalOutputImpl) => void;
  getImpl: (name: FnClassOptionalOutputImpls) => FnClassOptionalOutputImpl;
}

function createFnClassOptionalOutputInstance(): IFnClassOptionalOutput & FnClassOptionalOutputFunction {

  const registry: Record<FnClassOptionalOutputImpls, FnClassOptionalOutputImpl> = {}

  const wrapper: FnClassOptionalOutputFunction = {
    getImpl: (name: FnClassOptionalOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutputImpls, cb: IFnClassOptionalOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput",
          /* returnType */ "ClassOptionalOutput | null",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptionalOutput & FnClassOptionalOutputFunction;
}

const FnClassOptionalOutput = createFnClassOptionalOutputInstance();

type IFnClassOptionalOutput2 = (arg: string) => Promise<ClassOptionalOutput2 | null>

type FnClassOptionalOutput2Impls = 'v1';

interface FnClassOptionalOutput2Impl {
    run: IFnClassOptionalOutput2;
    name: FnClassOptionalOutput2Impls;
}

interface FnClassOptionalOutput2Function {
  registerImpl: (name: FnClassOptionalOutput2Impls, impl: FnClassOptionalOutput2Impl) => void;
  getImpl: (name: FnClassOptionalOutput2Impls) => FnClassOptionalOutput2Impl;
}

function createFnClassOptionalOutput2Instance(): IFnClassOptionalOutput2 & FnClassOptionalOutput2Function {

  const registry: Record<FnClassOptionalOutput2Impls, FnClassOptionalOutput2Impl> = {}

  const wrapper: FnClassOptionalOutput2Function = {
    getImpl: (name: FnClassOptionalOutput2Impls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutput2Impls, cb: IFnClassOptionalOutput2) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput2",
          /* returnType */ "ClassOptionalOutput2 | null",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnClassOptionalOutput2 & FnClassOptionalOutput2Function;
}

const FnClassOptionalOutput2 = createFnClassOptionalOutput2Instance();

type IFnEnumListOutput = (arg: string) => Promise<EnumOutput[]>

type FnEnumListOutputImpls = 'v1';

interface FnEnumListOutputImpl {
    run: IFnEnumListOutput;
    name: FnEnumListOutputImpls;
}

interface FnEnumListOutputFunction {
  registerImpl: (name: FnEnumListOutputImpls, impl: FnEnumListOutputImpl) => void;
  getImpl: (name: FnEnumListOutputImpls) => FnEnumListOutputImpl;
}

function createFnEnumListOutputInstance(): IFnEnumListOutput & FnEnumListOutputFunction {

  const registry: Record<FnEnumListOutputImpls, FnEnumListOutputImpl> = {}

  const wrapper: FnEnumListOutputFunction = {
    getImpl: (name: FnEnumListOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnEnumListOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnEnumListOutputImpls, cb: IFnEnumListOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnEnumListOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnEnumListOutput",
          /* returnType */ "EnumOutput[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnEnumListOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnEnumListOutput & FnEnumListOutputFunction;
}

const FnEnumListOutput = createFnEnumListOutputInstance();

type IFnEnumOutput = (arg: string) => Promise<EnumOutput>

type FnEnumOutputImpls = 'v1';

interface FnEnumOutputImpl {
    run: IFnEnumOutput;
    name: FnEnumOutputImpls;
}

interface FnEnumOutputFunction {
  registerImpl: (name: FnEnumOutputImpls, impl: FnEnumOutputImpl) => void;
  getImpl: (name: FnEnumOutputImpls) => FnEnumOutputImpl;
}

function createFnEnumOutputInstance(): IFnEnumOutput & FnEnumOutputFunction {

  const registry: Record<FnEnumOutputImpls, FnEnumOutputImpl> = {}

  const wrapper: FnEnumOutputFunction = {
    getImpl: (name: FnEnumOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnEnumOutputImpls, cb: IFnEnumOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnEnumOutput",
          /* returnType */ "EnumOutput",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnEnumOutput & FnEnumOutputFunction;
}

const FnEnumOutput = createFnEnumOutputInstance();

type IFnNamedArgsSingleStringOptional = (args: {
  myString: string | null
}) => Promise<string>

type FnNamedArgsSingleStringOptionalImpls = 'v1';

interface FnNamedArgsSingleStringOptionalImpl {
    run: IFnNamedArgsSingleStringOptional;
    name: FnNamedArgsSingleStringOptionalImpls;
}

interface FnNamedArgsSingleStringOptionalFunction {
  registerImpl: (name: FnNamedArgsSingleStringOptionalImpls, impl: FnNamedArgsSingleStringOptionalImpl) => void;
  getImpl: (name: FnNamedArgsSingleStringOptionalImpls) => FnNamedArgsSingleStringOptionalImpl;
}

function createFnNamedArgsSingleStringOptionalInstance(): IFnNamedArgsSingleStringOptional & FnNamedArgsSingleStringOptionalFunction {

  const registry: Record<FnNamedArgsSingleStringOptionalImpls, FnNamedArgsSingleStringOptionalImpl> = {}

  const wrapper: FnNamedArgsSingleStringOptionalFunction = {
    getImpl: (name: FnNamedArgsSingleStringOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnNamedArgsSingleStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnNamedArgsSingleStringOptionalImpls, cb: IFnNamedArgsSingleStringOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnNamedArgsSingleStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnNamedArgsSingleStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string | null"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string | null
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnNamedArgsSingleStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string | null
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnNamedArgsSingleStringOptional & FnNamedArgsSingleStringOptionalFunction;
}

const FnNamedArgsSingleStringOptional = createFnNamedArgsSingleStringOptionalInstance();

type IFnOutputBool = (arg: string) => Promise<boolean>

type FnOutputBoolImpls = 'v1';

interface FnOutputBoolImpl {
    run: IFnOutputBool;
    name: FnOutputBoolImpls;
}

interface FnOutputBoolFunction {
  registerImpl: (name: FnOutputBoolImpls, impl: FnOutputBoolImpl) => void;
  getImpl: (name: FnOutputBoolImpls) => FnOutputBoolImpl;
}

function createFnOutputBoolInstance(): IFnOutputBool & FnOutputBoolFunction {

  const registry: Record<FnOutputBoolImpls, FnOutputBoolImpl> = {}

  const wrapper: FnOutputBoolFunction = {
    getImpl: (name: FnOutputBoolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputBoolImpls, cb: IFnOutputBool) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputBool",
          /* returnType */ "boolean",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputBool & FnOutputBoolFunction;
}

const FnOutputBool = createFnOutputBoolInstance();

type IFnOutputClass = (arg: string) => Promise<TestOutputClass>

type FnOutputClassImpls = 'v1';

interface FnOutputClassImpl {
    run: IFnOutputClass;
    name: FnOutputClassImpls;
}

interface FnOutputClassFunction {
  registerImpl: (name: FnOutputClassImpls, impl: FnOutputClassImpl) => void;
  getImpl: (name: FnOutputClassImpls) => FnOutputClassImpl;
}

function createFnOutputClassInstance(): IFnOutputClass & FnOutputClassFunction {

  const registry: Record<FnOutputClassImpls, FnOutputClassImpl> = {}

  const wrapper: FnOutputClassFunction = {
    getImpl: (name: FnOutputClassImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassImpls, cb: IFnOutputClass) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClass",
          /* returnType */ "TestOutputClass",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClass & FnOutputClassFunction;
}

const FnOutputClass = createFnOutputClassInstance();

type IFnOutputClassList = (arg: string) => Promise<TestOutputClass[]>

type FnOutputClassListImpls = 'v1';

interface FnOutputClassListImpl {
    run: IFnOutputClassList;
    name: FnOutputClassListImpls;
}

interface FnOutputClassListFunction {
  registerImpl: (name: FnOutputClassListImpls, impl: FnOutputClassListImpl) => void;
  getImpl: (name: FnOutputClassListImpls) => FnOutputClassListImpl;
}

function createFnOutputClassListInstance(): IFnOutputClassList & FnOutputClassListFunction {

  const registry: Record<FnOutputClassListImpls, FnOutputClassListImpl> = {}

  const wrapper: FnOutputClassListFunction = {
    getImpl: (name: FnOutputClassListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassListImpls, cb: IFnOutputClassList) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassList",
          /* returnType */ "TestOutputClass[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClassList & FnOutputClassListFunction;
}

const FnOutputClassList = createFnOutputClassListInstance();

type IFnOutputClassWithEnum = (arg: string) => Promise<TestClassWithEnum>

type FnOutputClassWithEnumImpls = 'v1';

interface FnOutputClassWithEnumImpl {
    run: IFnOutputClassWithEnum;
    name: FnOutputClassWithEnumImpls;
}

interface FnOutputClassWithEnumFunction {
  registerImpl: (name: FnOutputClassWithEnumImpls, impl: FnOutputClassWithEnumImpl) => void;
  getImpl: (name: FnOutputClassWithEnumImpls) => FnOutputClassWithEnumImpl;
}

function createFnOutputClassWithEnumInstance(): IFnOutputClassWithEnum & FnOutputClassWithEnumFunction {

  const registry: Record<FnOutputClassWithEnumImpls, FnOutputClassWithEnumImpl> = {}

  const wrapper: FnOutputClassWithEnumFunction = {
    getImpl: (name: FnOutputClassWithEnumImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassWithEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassWithEnumImpls, cb: IFnOutputClassWithEnum) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassWithEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassWithEnum",
          /* returnType */ "TestClassWithEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassWithEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputClassWithEnum & FnOutputClassWithEnumFunction;
}

const FnOutputClassWithEnum = createFnOutputClassWithEnumInstance();

type IFnOutputStringList = (arg: string) => Promise<string[]>

type FnOutputStringListImpls = 'v1';

interface FnOutputStringListImpl {
    run: IFnOutputStringList;
    name: FnOutputStringListImpls;
}

interface FnOutputStringListFunction {
  registerImpl: (name: FnOutputStringListImpls, impl: FnOutputStringListImpl) => void;
  getImpl: (name: FnOutputStringListImpls) => FnOutputStringListImpl;
}

function createFnOutputStringListInstance(): IFnOutputStringList & FnOutputStringListFunction {

  const registry: Record<FnOutputStringListImpls, FnOutputStringListImpl> = {}

  const wrapper: FnOutputStringListFunction = {
    getImpl: (name: FnOutputStringListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputStringListImpls, cb: IFnOutputStringList) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputStringList",
          /* returnType */ "string[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnOutputStringList & FnOutputStringListFunction;
}

const FnOutputStringList = createFnOutputStringListInstance();

type IFnStringOptional = (arg: string | null) => Promise<string>

type FnStringOptionalImpls = 'v1';

interface FnStringOptionalImpl {
    run: IFnStringOptional;
    name: FnStringOptionalImpls;
}

interface FnStringOptionalFunction {
  registerImpl: (name: FnStringOptionalImpls, impl: FnStringOptionalImpl) => void;
  getImpl: (name: FnStringOptionalImpls) => FnStringOptionalImpl;
}

function createFnStringOptionalInstance(): IFnStringOptional & FnStringOptionalFunction {

  const registry: Record<FnStringOptionalImpls, FnStringOptionalImpl> = {}

  const wrapper: FnStringOptionalFunction = {
    getImpl: (name: FnStringOptionalImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnStringOptionalImpls, cb: IFnStringOptional) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string | null"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string | null
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string | null) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnStringOptional & FnStringOptionalFunction;
}

const FnStringOptional = createFnStringOptionalInstance();

type IFnTestAliasedEnumOutput = (arg: string) => Promise<TestEnum>

type FnTestAliasedEnumOutputImpls = 'v1';

interface FnTestAliasedEnumOutputImpl {
    run: IFnTestAliasedEnumOutput;
    name: FnTestAliasedEnumOutputImpls;
}

interface FnTestAliasedEnumOutputFunction {
  registerImpl: (name: FnTestAliasedEnumOutputImpls, impl: FnTestAliasedEnumOutputImpl) => void;
  getImpl: (name: FnTestAliasedEnumOutputImpls) => FnTestAliasedEnumOutputImpl;
}

function createFnTestAliasedEnumOutputInstance(): IFnTestAliasedEnumOutput & FnTestAliasedEnumOutputFunction {

  const registry: Record<FnTestAliasedEnumOutputImpls, FnTestAliasedEnumOutputImpl> = {}

  const wrapper: FnTestAliasedEnumOutputFunction = {
    getImpl: (name: FnTestAliasedEnumOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestAliasedEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestAliasedEnumOutputImpls, cb: IFnTestAliasedEnumOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestAliasedEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestAliasedEnumOutput",
          /* returnType */ "TestEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestAliasedEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestAliasedEnumOutput & FnTestAliasedEnumOutputFunction;
}

const FnTestAliasedEnumOutput = createFnTestAliasedEnumOutputInstance();

type IFnTestClassAlias = (arg: string) => Promise<TestClassAlias>

type FnTestClassAliasImpls = 'v1';

interface FnTestClassAliasImpl {
    run: IFnTestClassAlias;
    name: FnTestClassAliasImpls;
}

interface FnTestClassAliasFunction {
  registerImpl: (name: FnTestClassAliasImpls, impl: FnTestClassAliasImpl) => void;
  getImpl: (name: FnTestClassAliasImpls) => FnTestClassAliasImpl;
}

function createFnTestClassAliasInstance(): IFnTestClassAlias & FnTestClassAliasFunction {

  const registry: Record<FnTestClassAliasImpls, FnTestClassAliasImpl> = {}

  const wrapper: FnTestClassAliasFunction = {
    getImpl: (name: FnTestClassAliasImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestClassAlias with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestClassAliasImpls, cb: IFnTestClassAlias) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestClassAlias with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestClassAlias",
          /* returnType */ "TestClassAlias",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestClassAlias: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestClassAlias & FnTestClassAliasFunction;
}

const FnTestClassAlias = createFnTestClassAliasInstance();

type IFnTestClassOverride = (arg: string) => Promise<OverrideClass>

type FnTestClassOverrideImpls = 'v1';

interface FnTestClassOverrideImpl {
    run: IFnTestClassOverride;
    name: FnTestClassOverrideImpls;
}

interface FnTestClassOverrideFunction {
  registerImpl: (name: FnTestClassOverrideImpls, impl: FnTestClassOverrideImpl) => void;
  getImpl: (name: FnTestClassOverrideImpls) => FnTestClassOverrideImpl;
}

function createFnTestClassOverrideInstance(): IFnTestClassOverride & FnTestClassOverrideFunction {

  const registry: Record<FnTestClassOverrideImpls, FnTestClassOverrideImpl> = {}

  const wrapper: FnTestClassOverrideFunction = {
    getImpl: (name: FnTestClassOverrideImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestClassOverride with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestClassOverrideImpls, cb: IFnTestClassOverride) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestClassOverride with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestClassOverride",
          /* returnType */ "OverrideClass",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestClassOverride: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestClassOverride & FnTestClassOverrideFunction;
}

const FnTestClassOverride = createFnTestClassOverrideInstance();

type IFnTestEnumOverride = (arg: string) => Promise<OverrideEnum>

type FnTestEnumOverrideImpls = 'v1';

interface FnTestEnumOverrideImpl {
    run: IFnTestEnumOverride;
    name: FnTestEnumOverrideImpls;
}

interface FnTestEnumOverrideFunction {
  registerImpl: (name: FnTestEnumOverrideImpls, impl: FnTestEnumOverrideImpl) => void;
  getImpl: (name: FnTestEnumOverrideImpls) => FnTestEnumOverrideImpl;
}

function createFnTestEnumOverrideInstance(): IFnTestEnumOverride & FnTestEnumOverrideFunction {

  const registry: Record<FnTestEnumOverrideImpls, FnTestEnumOverrideImpl> = {}

  const wrapper: FnTestEnumOverrideFunction = {
    getImpl: (name: FnTestEnumOverrideImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestEnumOverride with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestEnumOverrideImpls, cb: IFnTestEnumOverride) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestEnumOverride with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestEnumOverride",
          /* returnType */ "OverrideEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestEnumOverride: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestEnumOverride & FnTestEnumOverrideFunction;
}

const FnTestEnumOverride = createFnTestEnumOverrideInstance();

type IFnTestNamedArgsSingleEnum = (args: {
  myArg: NamedArgsSingleEnum
}) => Promise<string>

type FnTestNamedArgsSingleEnumImpls = 'v1';

interface FnTestNamedArgsSingleEnumImpl {
    run: IFnTestNamedArgsSingleEnum;
    name: FnTestNamedArgsSingleEnumImpls;
}

interface FnTestNamedArgsSingleEnumFunction {
  registerImpl: (name: FnTestNamedArgsSingleEnumImpls, impl: FnTestNamedArgsSingleEnumImpl) => void;
  getImpl: (name: FnTestNamedArgsSingleEnumImpls) => FnTestNamedArgsSingleEnumImpl;
}

function createFnTestNamedArgsSingleEnumInstance(): IFnTestNamedArgsSingleEnum & FnTestNamedArgsSingleEnumFunction {

  const registry: Record<FnTestNamedArgsSingleEnumImpls, FnTestNamedArgsSingleEnumImpl> = {}

  const wrapper: FnTestNamedArgsSingleEnumFunction = {
    getImpl: (name: FnTestNamedArgsSingleEnumImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestNamedArgsSingleEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestNamedArgsSingleEnumImpls, cb: IFnTestNamedArgsSingleEnum) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestNamedArgsSingleEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestNamedArgsSingleEnum",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnum"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnum
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestNamedArgsSingleEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnum
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestNamedArgsSingleEnum & FnTestNamedArgsSingleEnumFunction;
}

const FnTestNamedArgsSingleEnum = createFnTestNamedArgsSingleEnumInstance();

type IFnTestOutputAdapter = (arg: string) => Promise<string>

type FnTestOutputAdapterImpls = 'v1';

interface FnTestOutputAdapterImpl {
    run: IFnTestOutputAdapter;
    name: FnTestOutputAdapterImpls;
}

interface FnTestOutputAdapterFunction {
  registerImpl: (name: FnTestOutputAdapterImpls, impl: FnTestOutputAdapterImpl) => void;
  getImpl: (name: FnTestOutputAdapterImpls) => FnTestOutputAdapterImpl;
}

function createFnTestOutputAdapterInstance(): IFnTestOutputAdapter & FnTestOutputAdapterFunction {

  const registry: Record<FnTestOutputAdapterImpls, FnTestOutputAdapterImpl> = {}

  const wrapper: FnTestOutputAdapterFunction = {
    getImpl: (name: FnTestOutputAdapterImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestOutputAdapter with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestOutputAdapterImpls, cb: IFnTestOutputAdapter) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestOutputAdapter with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestOutputAdapter",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestOutputAdapter: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnTestOutputAdapter & FnTestOutputAdapterFunction;
}

const FnTestOutputAdapter = createFnTestOutputAdapterInstance();

type IFnUnionStringBoolWithArrayOutput = (arg: string) => Promise<number>

type FnUnionStringBoolWithArrayOutputImpls = 'v1';

interface FnUnionStringBoolWithArrayOutputImpl {
    run: IFnUnionStringBoolWithArrayOutput;
    name: FnUnionStringBoolWithArrayOutputImpls;
}

interface FnUnionStringBoolWithArrayOutputFunction {
  registerImpl: (name: FnUnionStringBoolWithArrayOutputImpls, impl: FnUnionStringBoolWithArrayOutputImpl) => void;
  getImpl: (name: FnUnionStringBoolWithArrayOutputImpls) => FnUnionStringBoolWithArrayOutputImpl;
}

function createFnUnionStringBoolWithArrayOutputInstance(): IFnUnionStringBoolWithArrayOutput & FnUnionStringBoolWithArrayOutputFunction {

  const registry: Record<FnUnionStringBoolWithArrayOutputImpls, FnUnionStringBoolWithArrayOutputImpl> = {}

  const wrapper: FnUnionStringBoolWithArrayOutputFunction = {
    getImpl: (name: FnUnionStringBoolWithArrayOutputImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnUnionStringBoolWithArrayOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnUnionStringBoolWithArrayOutputImpls, cb: IFnUnionStringBoolWithArrayOutput) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnUnionStringBoolWithArrayOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnUnionStringBoolWithArrayOutput",
          /* returnType */ "number",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnUnionStringBoolWithArrayOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IFnUnionStringBoolWithArrayOutput & FnUnionStringBoolWithArrayOutputFunction;
}

const FnUnionStringBoolWithArrayOutput = createFnUnionStringBoolWithArrayOutputInstance();

type IPromptTest = (arg: string) => Promise<string>

type PromptTestImpls = 'claude_chat' | 'claude_chat_with_chat_msgs' | 'openai_chat' | 'openai_chat_with_chat_msgs';

interface PromptTestImpl {
    run: IPromptTest;
    name: PromptTestImpls;
}

interface PromptTestFunction {
  registerImpl: (name: PromptTestImpls, impl: PromptTestImpl) => void;
  getImpl: (name: PromptTestImpls) => PromptTestImpl;
}

function createPromptTestInstance(): IPromptTest & PromptTestFunction {

  const registry: Record<PromptTestImpls, PromptTestImpl> = {}

  const wrapper: PromptTestFunction = {
    getImpl: (name: PromptTestImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for PromptTest with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: PromptTestImpls, cb: IPromptTest) => {
      if (registry[name]) {
        throw new Error(`Implementation for PromptTest with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"PromptTest",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        })
      };
    },
    validate: () => {
      const targets = ['claude_chat', 'claude_chat_with_chat_msgs', 'openai_chat', 'openai_chat_with_chat_msgs'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for PromptTest: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('claude_chat').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IPromptTest & PromptTestFunction;
}

const PromptTest = createPromptTestInstance();

type ITestFnNamedArgsSingleBool = (args: {
  myBool: boolean
}) => Promise<string>

type TestFnNamedArgsSingleBoolImpls = 'v1';

interface TestFnNamedArgsSingleBoolImpl {
    run: ITestFnNamedArgsSingleBool;
    name: TestFnNamedArgsSingleBoolImpls;
}

interface TestFnNamedArgsSingleBoolFunction {
  registerImpl: (name: TestFnNamedArgsSingleBoolImpls, impl: TestFnNamedArgsSingleBoolImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleBoolImpls) => TestFnNamedArgsSingleBoolImpl;
}

function createTestFnNamedArgsSingleBoolInstance(): ITestFnNamedArgsSingleBool & TestFnNamedArgsSingleBoolFunction {

  const registry: Record<TestFnNamedArgsSingleBoolImpls, TestFnNamedArgsSingleBoolImpl> = {}

  const wrapper: TestFnNamedArgsSingleBoolFunction = {
    getImpl: (name: TestFnNamedArgsSingleBoolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleBoolImpls, cb: ITestFnNamedArgsSingleBool) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleBool",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myBool",
              "boolean"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myBool: boolean
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myBool: boolean
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleBool & TestFnNamedArgsSingleBoolFunction;
}

const TestFnNamedArgsSingleBool = createTestFnNamedArgsSingleBoolInstance();

type ITestFnNamedArgsSingleClass = (args: {
  myArg: NamedArgsSingleClass
}) => Promise<string>

type TestFnNamedArgsSingleClassImpls = 'v1';

interface TestFnNamedArgsSingleClassImpl {
    run: ITestFnNamedArgsSingleClass;
    name: TestFnNamedArgsSingleClassImpls;
}

interface TestFnNamedArgsSingleClassFunction {
  registerImpl: (name: TestFnNamedArgsSingleClassImpls, impl: TestFnNamedArgsSingleClassImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleClassImpls) => TestFnNamedArgsSingleClassImpl;
}

function createTestFnNamedArgsSingleClassInstance(): ITestFnNamedArgsSingleClass & TestFnNamedArgsSingleClassFunction {

  const registry: Record<TestFnNamedArgsSingleClassImpls, TestFnNamedArgsSingleClassImpl> = {}

  const wrapper: TestFnNamedArgsSingleClassFunction = {
    getImpl: (name: TestFnNamedArgsSingleClassImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleClassImpls, cb: ITestFnNamedArgsSingleClass) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleClass",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleClass"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleClass
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleClass
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleClass & TestFnNamedArgsSingleClassFunction;
}

const TestFnNamedArgsSingleClass = createTestFnNamedArgsSingleClassInstance();

type ITestFnNamedArgsSingleEnumList = (args: {
  myArg: NamedArgsSingleEnumList[]
}) => Promise<string>

type TestFnNamedArgsSingleEnumListImpls = 'v1';

interface TestFnNamedArgsSingleEnumListImpl {
    run: ITestFnNamedArgsSingleEnumList;
    name: TestFnNamedArgsSingleEnumListImpls;
}

interface TestFnNamedArgsSingleEnumListFunction {
  registerImpl: (name: TestFnNamedArgsSingleEnumListImpls, impl: TestFnNamedArgsSingleEnumListImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleEnumListImpls) => TestFnNamedArgsSingleEnumListImpl;
}

function createTestFnNamedArgsSingleEnumListInstance(): ITestFnNamedArgsSingleEnumList & TestFnNamedArgsSingleEnumListFunction {

  const registry: Record<TestFnNamedArgsSingleEnumListImpls, TestFnNamedArgsSingleEnumListImpl> = {}

  const wrapper: TestFnNamedArgsSingleEnumListFunction = {
    getImpl: (name: TestFnNamedArgsSingleEnumListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleEnumList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleEnumListImpls, cb: ITestFnNamedArgsSingleEnumList) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleEnumList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleEnumList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnumList[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnumList[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleEnumList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnumList[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleEnumList & TestFnNamedArgsSingleEnumListFunction;
}

const TestFnNamedArgsSingleEnumList = createTestFnNamedArgsSingleEnumListInstance();

type ITestFnNamedArgsSingleFloat = (args: {
  myFloat: number
}) => Promise<string>

type TestFnNamedArgsSingleFloatImpls = 'v1';

interface TestFnNamedArgsSingleFloatImpl {
    run: ITestFnNamedArgsSingleFloat;
    name: TestFnNamedArgsSingleFloatImpls;
}

interface TestFnNamedArgsSingleFloatFunction {
  registerImpl: (name: TestFnNamedArgsSingleFloatImpls, impl: TestFnNamedArgsSingleFloatImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleFloatImpls) => TestFnNamedArgsSingleFloatImpl;
}

function createTestFnNamedArgsSingleFloatInstance(): ITestFnNamedArgsSingleFloat & TestFnNamedArgsSingleFloatFunction {

  const registry: Record<TestFnNamedArgsSingleFloatImpls, TestFnNamedArgsSingleFloatImpl> = {}

  const wrapper: TestFnNamedArgsSingleFloatFunction = {
    getImpl: (name: TestFnNamedArgsSingleFloatImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleFloat with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleFloatImpls, cb: ITestFnNamedArgsSingleFloat) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleFloat with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleFloat",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myFloat",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myFloat: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleFloat: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myFloat: number
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleFloat & TestFnNamedArgsSingleFloatFunction;
}

const TestFnNamedArgsSingleFloat = createTestFnNamedArgsSingleFloatInstance();

type ITestFnNamedArgsSingleInt = (args: {
  myInt: number
}) => Promise<string>

type TestFnNamedArgsSingleIntImpls = 'v1';

interface TestFnNamedArgsSingleIntImpl {
    run: ITestFnNamedArgsSingleInt;
    name: TestFnNamedArgsSingleIntImpls;
}

interface TestFnNamedArgsSingleIntFunction {
  registerImpl: (name: TestFnNamedArgsSingleIntImpls, impl: TestFnNamedArgsSingleIntImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleIntImpls) => TestFnNamedArgsSingleIntImpl;
}

function createTestFnNamedArgsSingleIntInstance(): ITestFnNamedArgsSingleInt & TestFnNamedArgsSingleIntFunction {

  const registry: Record<TestFnNamedArgsSingleIntImpls, TestFnNamedArgsSingleIntImpl> = {}

  const wrapper: TestFnNamedArgsSingleIntFunction = {
    getImpl: (name: TestFnNamedArgsSingleIntImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleInt with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleIntImpls, cb: ITestFnNamedArgsSingleInt) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleInt with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleInt",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myInt",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myInt: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleInt: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myInt: number
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleInt & TestFnNamedArgsSingleIntFunction;
}

const TestFnNamedArgsSingleInt = createTestFnNamedArgsSingleIntInstance();

type ITestFnNamedArgsSingleString = (args: {
  myString: string
}) => Promise<string>

type TestFnNamedArgsSingleStringImpls = 'v1';

interface TestFnNamedArgsSingleStringImpl {
    run: ITestFnNamedArgsSingleString;
    name: TestFnNamedArgsSingleStringImpls;
}

interface TestFnNamedArgsSingleStringFunction {
  registerImpl: (name: TestFnNamedArgsSingleStringImpls, impl: TestFnNamedArgsSingleStringImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleStringImpls) => TestFnNamedArgsSingleStringImpl;
}

function createTestFnNamedArgsSingleStringInstance(): ITestFnNamedArgsSingleString & TestFnNamedArgsSingleStringFunction {

  const registry: Record<TestFnNamedArgsSingleStringImpls, TestFnNamedArgsSingleStringImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleString with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringImpls, cb: ITestFnNamedArgsSingleString) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleString with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleString",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleString: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleString & TestFnNamedArgsSingleStringFunction;
}

const TestFnNamedArgsSingleString = createTestFnNamedArgsSingleStringInstance();

type ITestFnNamedArgsSingleStringArray = (args: {
  myStringArray: string[]
}) => Promise<string>

type TestFnNamedArgsSingleStringArrayImpls = 'v1';

interface TestFnNamedArgsSingleStringArrayImpl {
    run: ITestFnNamedArgsSingleStringArray;
    name: TestFnNamedArgsSingleStringArrayImpls;
}

interface TestFnNamedArgsSingleStringArrayFunction {
  registerImpl: (name: TestFnNamedArgsSingleStringArrayImpls, impl: TestFnNamedArgsSingleStringArrayImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleStringArrayImpls) => TestFnNamedArgsSingleStringArrayImpl;
}

function createTestFnNamedArgsSingleStringArrayInstance(): ITestFnNamedArgsSingleStringArray & TestFnNamedArgsSingleStringArrayFunction {

  const registry: Record<TestFnNamedArgsSingleStringArrayImpls, TestFnNamedArgsSingleStringArrayImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringArrayFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringArrayImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleStringArray with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringArrayImpls, cb: ITestFnNamedArgsSingleStringArray) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleStringArray with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleStringArray",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myStringArray",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myStringArray: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleStringArray: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myStringArray: string[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleStringArray & TestFnNamedArgsSingleStringArrayFunction;
}

const TestFnNamedArgsSingleStringArray = createTestFnNamedArgsSingleStringArrayInstance();

type ITestFnNamedArgsSingleStringList = (args: {
  myArg: string[]
}) => Promise<string>

type TestFnNamedArgsSingleStringListImpls = 'v1';

interface TestFnNamedArgsSingleStringListImpl {
    run: ITestFnNamedArgsSingleStringList;
    name: TestFnNamedArgsSingleStringListImpls;
}

interface TestFnNamedArgsSingleStringListFunction {
  registerImpl: (name: TestFnNamedArgsSingleStringListImpls, impl: TestFnNamedArgsSingleStringListImpl) => void;
  getImpl: (name: TestFnNamedArgsSingleStringListImpls) => TestFnNamedArgsSingleStringListImpl;
}

function createTestFnNamedArgsSingleStringListInstance(): ITestFnNamedArgsSingleStringList & TestFnNamedArgsSingleStringListFunction {

  const registry: Record<TestFnNamedArgsSingleStringListImpls, TestFnNamedArgsSingleStringListImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringListFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringListImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringListImpls, cb: ITestFnNamedArgsSingleStringList) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleStringList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: string[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSingleStringList & TestFnNamedArgsSingleStringListFunction;
}

const TestFnNamedArgsSingleStringList = createTestFnNamedArgsSingleStringListInstance();

type ITestFnNamedArgsSyntax = (args: {
  var: string, var_with_underscores: string
}) => Promise<string>

type TestFnNamedArgsSyntaxImpls = never;

interface TestFnNamedArgsSyntaxImpl {
    run: ITestFnNamedArgsSyntax;
    name: TestFnNamedArgsSyntaxImpls;
}

interface TestFnNamedArgsSyntaxFunction {
  registerImpl: (name: TestFnNamedArgsSyntaxImpls, impl: TestFnNamedArgsSyntaxImpl) => void;
  getImpl: (name: TestFnNamedArgsSyntaxImpls) => TestFnNamedArgsSyntaxImpl;
}

function createTestFnNamedArgsSyntaxInstance(): ITestFnNamedArgsSyntax & TestFnNamedArgsSyntaxFunction {

  const registry: Record<TestFnNamedArgsSyntaxImpls, TestFnNamedArgsSyntaxImpl> = {}

  const wrapper: TestFnNamedArgsSyntaxFunction = {
    getImpl: (name: TestFnNamedArgsSyntaxImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSyntax with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSyntaxImpls, cb: ITestFnNamedArgsSyntax) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSyntax with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSyntax",
          /* returnType */ "string",
          /* paramters */ [
            [
              "var",
              "string"
            ],
            [
              "var_with_underscores",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            var: string, var_with_underscores: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        })
      };
    },
    validate: () => {
    }
  };

  const impl = async (params : {
    var: string, var_with_underscores: string
  }) => {
    throw new Error('No implementation for TestFnNamedArgsSyntax');
  };

  Object.assign(impl, wrapper);

  return impl as  ITestFnNamedArgsSyntax & TestFnNamedArgsSyntaxFunction;
}

const TestFnNamedArgsSyntax = createTestFnNamedArgsSyntaxInstance();


export { FnClassOptional, IFnClassOptional, FnClassOptionalFunction, FnClassOptional2, IFnClassOptional2, FnClassOptional2Function, FnClassOptionalOutput, IFnClassOptionalOutput, FnClassOptionalOutputFunction, FnClassOptionalOutput2, IFnClassOptionalOutput2, FnClassOptionalOutput2Function, FnEnumListOutput, IFnEnumListOutput, FnEnumListOutputFunction, FnEnumOutput, IFnEnumOutput, FnEnumOutputFunction, FnNamedArgsSingleStringOptional, IFnNamedArgsSingleStringOptional, FnNamedArgsSingleStringOptionalFunction, FnOutputBool, IFnOutputBool, FnOutputBoolFunction, FnOutputClass, IFnOutputClass, FnOutputClassFunction, FnOutputClassList, IFnOutputClassList, FnOutputClassListFunction, FnOutputClassWithEnum, IFnOutputClassWithEnum, FnOutputClassWithEnumFunction, FnOutputStringList, IFnOutputStringList, FnOutputStringListFunction, FnStringOptional, IFnStringOptional, FnStringOptionalFunction, FnTestAliasedEnumOutput, IFnTestAliasedEnumOutput, FnTestAliasedEnumOutputFunction, FnTestClassAlias, IFnTestClassAlias, FnTestClassAliasFunction, FnTestClassOverride, IFnTestClassOverride, FnTestClassOverrideFunction, FnTestEnumOverride, IFnTestEnumOverride, FnTestEnumOverrideFunction, FnTestNamedArgsSingleEnum, IFnTestNamedArgsSingleEnum, FnTestNamedArgsSingleEnumFunction, FnTestOutputAdapter, IFnTestOutputAdapter, FnTestOutputAdapterFunction, FnUnionStringBoolWithArrayOutput, IFnUnionStringBoolWithArrayOutput, FnUnionStringBoolWithArrayOutputFunction, PromptTest, IPromptTest, PromptTestFunction, TestFnNamedArgsSingleBool, ITestFnNamedArgsSingleBool, TestFnNamedArgsSingleBoolFunction, TestFnNamedArgsSingleClass, ITestFnNamedArgsSingleClass, TestFnNamedArgsSingleClassFunction, TestFnNamedArgsSingleEnumList, ITestFnNamedArgsSingleEnumList, TestFnNamedArgsSingleEnumListFunction, TestFnNamedArgsSingleFloat, ITestFnNamedArgsSingleFloat, TestFnNamedArgsSingleFloatFunction, TestFnNamedArgsSingleInt, ITestFnNamedArgsSingleInt, TestFnNamedArgsSingleIntFunction, TestFnNamedArgsSingleString, ITestFnNamedArgsSingleString, TestFnNamedArgsSingleStringFunction, TestFnNamedArgsSingleStringArray, ITestFnNamedArgsSingleStringArray, TestFnNamedArgsSingleStringArrayFunction, TestFnNamedArgsSingleStringList, ITestFnNamedArgsSingleStringList, TestFnNamedArgsSingleStringListFunction, TestFnNamedArgsSyntax, ITestFnNamedArgsSyntax, TestFnNamedArgsSyntaxFunction }

