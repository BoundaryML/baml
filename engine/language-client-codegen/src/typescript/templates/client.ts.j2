import { BamlRuntimePy, FunctionResult, BamlCtxManager, BamlStream } from "@boundaryml/baml"
import { 
  {%- for t in types %}{{ t }}{% if !loop.last %}, {% endif %}{% endfor -%} 
} from "./types"

export class BamlClient {
  private stream_client: BamlStreamClient

  constructor(private runtime: BamlRuntimePy, private ctx_manager: BamlCtxManager) {
    this.stream_client = new BamlStreamClient(runtime, ctx_manager)
  }

  get stream() {
    return this.stream_client
  }  

  {% for fn in funcs %}
  async {{ fn.name }}(
      {% for (name, type) in fn.args -%}
      {{name}}: {{type}}{% if !loop.last %},{% endif %}
      {%- endfor %}
  ): Promise<{{fn.return_type}}> {
    const raw = await this.runtime.callFunction(
      "{{fn.name}}",
      {
        {% for (name, _) in fn.args -%}
        "{{name}}": {{name}},
        {%- endfor %}
      },
      this.ctx_manager.get(),
    )
    return raw.parsed() as {{fn.return_type}}
  }
  {% endfor %}
}

class BamlStreamClient {
  constructor(private runtime: BamlRuntimePy, private ctx_manager: BamlCtxManager) {}

  {% for fn in funcs %}
  {{ fn.name }}(
      {% for (name, type) in fn.args -%}
      {{name}}: {{type}}{% if !loop.last %},{% endif %}
      {%- endfor %}
  ): BamlStream<{{ fn.partial_return_type }}, {{ fn.return_type }}> {
    const raw = this.runtime.streamFunction(
      "{{fn.name}}",
      {
        {%- for (name, _) in fn.args %}
        "{{name}}": {{name}},
        {%- endfor %}
      },
      undefined,
      this.ctx_manager.get(),
    )
    return new BamlStream<{{ fn.partial_return_type }}, {{ fn.return_type }}>(
      raw,
      (a): a is {{ fn.partial_return_type }} => a,
      (a): a is {{ fn.return_type }} => a,
      this.ctx_manager.get(),
    )
  }
  {% endfor %}
}