require 'set'

module Baml
    class TypeRegistry < Baml::Ffi::TypeBuilder
        def initialize
            @registry = Baml::Ffi::TypeBuilder.new
            @classes = Array.new(["Blah","ClassOptionalOutput","ClassOptionalOutput2","ClassWithImage","DummyOutput","DynInputOutput","DynamicClassOne","DynamicClassTwo","DynamicOutput","Education","Email","Event","FakeImage","InnerClass","InnerClass2","NamedArgsSingleClass","OptionalTest_Prop1","OptionalTest_ReturnType","OrderInfo","Person","Quantity","RaysData","ReceiptInfo","ReceiptItem","Recipe","Resume","SearchParams","SomeClassNestedDynamic","StringToClassEntry","TestClassAlias","TestClassNested","TestClassWithEnum","TestOutputClass","UnionTest_ReturnType","WithReasoning",])
            @enums = Array.new(["Category","Category2","Category3","Color","DataType","DynEnumOne","DynEnumTwo","EnumInClass","EnumOutput","Hobby","NamedArgsSingleEnum","NamedArgsSingleEnumList","OptionalTest_CategoryType","OrderStatus","Tag","TestEnum",])
        end

        def string
            @registry.string
        end
    
        def int
            @registry.int
        end

        def float
            @registry.float
        end

        def bool
            @registry.bool
        end

        def list(inner_type)
            @registry.list(inner_type)
        end
        
        def null
            @registry.null
        end

        def map(key_type, value_type)
            @registry.map(key_type, value_type)
        end

        def union(types)
            @registry.union(types)
        end

        def add_class(name)
            if @classes.include?(name)
                raise "Class with name #{name} already exists."
            end
            if @enums.include?(name)
                raise "Enum with name #{name} already exists."
            end
            @classes.add(name)
            ClassBuilder.new(@registry, name)
        end

        def add_enum(name)
            if @classes.include?(name)
                raise "Class with name #{name} already exists."
            end
            if @enums.include?(name)
                raise "Enum with name #{name} already exists."
            end
            @enums.add(name)
            EnumBuilder.new(@registry, name)
        end

        class ClassBuilder
            def initialize(registry, name)
                @builder = registry.class_(name)
                @name = name
            end

            def type
                @registry.field
            end

            def list_properties
            end

            def add_property(name, type)
            end
            
            def props
                ClassPropertyBuilder.new(@registry.property(name).type(type))
            end
        end

        class ClassPropertyBuilder
            def initialize(builder)
                @builder = builder
            end

            def alias(s)
                @builder.alias(s)
            end

            def description(s)
                @builder.alias(s)
            end
        end

        class ClassProperties
            def initialize(builder, properties)
                @builder = builder
                @properties = properties
            end

            def method_missing(name)
                unless @properties.include?(name.to_s)
                    raise NoMethodError, "Property #{name} not found."
                end
                @bldr.value(name.to_s)
            end
        end

        class EnumBuilder
            def initialize(enum_builder, name)
                @builder = builder
                @name = name

                @values = Set.new
                @vals = EnumValues.new(@builder, @values)
            end

            def type
                @builder.field
            end

            def values
                @vals
            end

            def list_values
                @values.map { |name| [name, @builder.value(name)] }
            end

            def add_value(name)
                if @values.include?(name)
                    raise "Value #{name} already exists."
                end
                @values.add(name)
                @builder.value(name)
            end
        end

        class EnumValues
            def initialize(enum_builder, values)
                @builder = enum_builder
                @values = values
            end

            def method_missing(name)
                unless @values.include?(name.to_s)
                    raise NoMethodError, "Value #{name} not found."
                end
                @bldr.value(name.to_s)
            end
        end

        {% for cls in classes if cls.dynamic %}
        def {{cls.name}}
            return Baml::GeneratedTypeBuilder::{{cls.name}}Builder(self)
        end
        {% endfor %}

        {% for enum in enums if enum.dynamic %}
        def {{enum.name}}
            return Baml::GeneratedTypeBuilder::{{enum.name}}Builder(self)
        end
        {% endfor %}
    end

    module GeneratedTypeBuilder
        {% for cls in classes if cls.dynamic -%}
        class {{cls.name}}Builder
            def initialize(tr)
                #@type_registry = tr
                @registry = tr._tr.class_("{{cls.name}}")
                @properties = Array.new([{% for (name, _) in cls.fields %} "{{name}}", {% endfor %}])
                @props = {{cls.name}}Properties.new(@type_registry, @properties)
            end

            def type
                @registry.field
            end

            def props -> "{{cls.name}}Properties":
                @props
            end

            def list_properties
                @properties.map { |name| [name, @registry.property(name)] }
            end

            def add_property(name, type) -> ClassPropertyBuilder:
                if @properties.include?(name)
                    raise "Property #{name} already exists."
                end
                return ClassPropertyBuilder.new(@registry.property(name).type(type))
            end
        end

        class {{cls.name}}Properties
            def initialize(tr, cls_builder, properties)
                @cls_builder = cls_builder
                @properties = properties
            end

            {% for (name, type) in cls.fields %}
            def {{name}}
                return @cls_builder.property("{{name}}")
            {%- endfor %}

            {#  TODO: ruby has its own version of this
            def __getattr__(self, name: str) -> ClassPropertyBuilder:
                if name not in self.__properties:
                    raise AttributeError(f"Property {name} not found.")
                return ClassPropertyBuilder(self.__bldr.property(name))
            end #}
        end
        {% endfor %}

        {% for enum in enums if enum.dynamic %}
        class {{enum.name}}Builder
            def __init__(self, tb: _TypeBuilder):
                @builder = tb._tb.enum("{{enum.name}}")
                @values = Array.new([{% for value in enum.values %} "{{value}}", {% endfor %}])
                @vals = {{enum.name}}Values(self.__bldr, self.__values)

            def type
                return @builder.field()
            end

            def values
                @vals
            end

            def list_values(self) -> typing.List[typing.Tuple[str, EnumValueBuilder]]:
                @values.map { |name| [name, @builder.value(name)] }
            end

            def add_value(self, name: str) -> EnumValueBuilder:
                if name in self.__values:
                    raise ValueError(f"Value {name} already exists.")
                @values.add(name)
                @builder.value(name)
            end
        end

        class {{enum.name}}Values:
            def initialize(enum_bldr, values):
                @builder = enum_bldr
                @values = values
            end

            {% for value in enum.values %}
            def {{value}}
                return @builder.value("{{value}}")
            {% endfor %}

            def __getattr__(self, name: str) -> EnumValueBuilder:
                if name not in self.__values:
                    raise AttributeError(f"Value {name} not found.")
                return self.__bldr.value(name)
            end

            def method_missing(name)
                unless @values.include?(name.to_s)
                    raise NoMethodError, "Value #{name} not found."
                end
                @bldr.value(name.to_s)
            end
        end
        {% endfor %}
    end
end
