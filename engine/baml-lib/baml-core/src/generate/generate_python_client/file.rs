use std::io::Write;
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
};

use crate::configuration::Generator;
use crate::lockfile::LockFileWrapper;

#[derive(Debug, Default)]
pub(crate) struct FileCollector {
    last_file: Option<PathBuf>,
    files: HashMap<PathBuf, File>,
}

impl FileCollector {
    pub fn start_export_file<'a>(&'a mut self, path: impl AsRef<str>, name: impl AsRef<str>) {
        self.start_py_file_impl(path, name, true);
    }
    pub fn start_py_file<'a>(&'a mut self, path: impl AsRef<str>, name: impl AsRef<str>) {
        self.start_py_file_impl(path, name, false);
    }

    fn start_py_file_impl<'a>(
        &'a mut self,
        path: impl AsRef<str>,
        name: impl AsRef<str>,
        is_export: bool,
    ) {
        let cleaned_path = clean_file_name(&path);

        let cleaned_path = if is_export {
            cleaned_path
        } else {
            format!("__do_not_import/{}", cleaned_path)
        };

        let cleaned_name = clean_file_name(&name);
        // Add .py to the end of the name if another extension is not already present
        let cleaned_name = if cleaned_name.contains('.') {
            cleaned_name
        } else {
            format!("{}.py", cleaned_name)
        };

        let key = PathBuf::from(&cleaned_path).join(&cleaned_name);

        if self.last_file.is_some() {
            panic!(
                "File already started: {:?}. Can't start {:?}",
                self.last_file, key
            );
        }

        self.last_file = Some(key.clone());
        let is_export =
            (is_export && cleaned_path.starts_with("tests/")) || cleaned_name == "__init__.py";

        // Create a new file if its not already present.
        if !self.files.contains_key(&key) {
            self.files.insert(
                key.clone(),
                File::new(&cleaned_path, &cleaned_name, is_export),
            );
        }
    }

    pub fn complete_file<'a>(&'a mut self) {
        if self.last_file.is_none() {
            panic!("No file to complete");
        }

        self.last_file = None;
    }

    pub fn last_file(&mut self) -> &mut File {
        if self.last_file.is_none() {
            panic!("No file to complete");
        }
        self.last_file
            .as_ref()
            .and_then(|path| self.files.get_mut(path))
            .unwrap()
    }

    pub fn write(
        &self,
        output: &PathBuf,
        _gen: &Generator,
        lock: &LockFileWrapper,
    ) -> std::io::Result<()> {
        std::fs::create_dir(output).map_err(|e| {
            std::io::Error::new(
                e.kind(),
                format!(
                    "{}. Does the parent exist?\n{}",
                    e.to_string(),
                    output.to_string_lossy()
                ),
            )
        })?;

        let comment_prefix = r#"# This file is generated by the BAML compiler.
# Do not edit this file directly.
# Instead, edit the BAML files and recompile.

# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off

"#;
        std::fs::write(
            output.join("baml.lock"),
            serde_json::to_string_pretty(lock).unwrap(),
        )?;
        for file in self.files.values() {
            let path = output.join(file.path());
            std::fs::create_dir_all(path.parent().unwrap())?;
            std::fs::write(&path, &comment_prefix)?;
            std::fs::OpenOptions::new()
                .append(true)
                .open(&path)?
                .write_all(file.content().as_bytes())?;
        }

        Ok(())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct File {
    path: PathBuf,
    name: String,
    content: String,
    imports: HashMap<String, HashSet<String>>,
    explicit_exports: Vec<String>,
    is_export: bool,
}

pub(super) fn clean_file_name(name: impl AsRef<str>) -> String {
    name.as_ref()
        .to_ascii_lowercase()
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' || c == '/' || c == '.' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
}

impl File {
    pub(super) fn new(path: impl AsRef<str>, name: impl AsRef<str>, is_export: bool) -> Self {
        Self {
            path: path.as_ref().into(),
            name: name.as_ref().into(),
            content: String::new(),
            imports: HashMap::new(),
            explicit_exports: vec![],
            is_export,
        }
    }

    pub(crate) fn add_import(&mut self, module: &str, name: &str) {
        self.imports
            .entry(module.to_string())
            .or_default()
            .insert(name.to_string());
    }

    pub(super) fn add_import_and_reexport(&mut self, module: &str, name: &str) {
        self.add_import(module, name);
        self.add_explicit_export(name);
    }

    pub(super) fn add_explicit_export(&mut self, name: &str) {
        self.explicit_exports.push(name.to_string());
    }

    pub(super) fn add_line(&mut self, line: impl AsRef<str>) {
        self.add_indent_line(line, 0);
    }

    pub(super) fn add_indent_line<'a>(&mut self, line: impl AsRef<str>, indent: usize) {
        self.add_indent_string(line, indent);
        self.add_empty_line();
    }

    pub(super) fn add_indent_string(&mut self, string: impl AsRef<str>, indent: usize) {
        const TAB_SIZE: usize = 4;
        const TAB: &str = "                                                                  ";

        let num_spaces = indent * TAB_SIZE;

        let prefix = match num_spaces > TAB.len() {
            true => panic!("Indentation too large"),
            false => &TAB[..num_spaces],
        };
        // Split the string by newlines and add each line with the correct indent
        let mut lines = string.as_ref().split('\n').peekable();
        // Loop through the lines
        while let Some(line) = lines.next() {
            // Add the prefix if the line is not empty
            if !line.is_empty() {
                self.add_string(&prefix);
            }

            // Add the line itself
            self.add_string(line);

            // Add an empty line if there are more lines remaining
            if lines.peek().is_some() {
                self.add_empty_line();
            }
        }
    }

    #[allow(dead_code)]
    pub(super) fn add_empty_indent(&mut self, indent: usize) {
        const TAB_SIZE: usize = 4;
        const TAB: &str = "                                                                  ";

        let num_spaces = indent * TAB_SIZE;

        let prefix = match num_spaces > TAB.len() {
            true => panic!("Indentation too large"),
            false => &TAB[..num_spaces],
        };
        self.add_string(&prefix);
    }

    pub(super) fn add_empty_line(&mut self) {
        self.content.push('\n');
    }

    pub(crate) fn add_string(&mut self, string: impl AsRef<str>) {
        self.content.push_str(string.as_ref());
    }

    pub(super) fn path(&self) -> PathBuf {
        self.path.join(&self.name)
    }

    pub(crate) fn content(&self) -> String {
        let mut modules = self.imports.keys().collect::<Vec<_>>();
        modules.sort();

        let mut exports = self.explicit_exports.clone();

        let mut buffer = modules.iter().fold(String::new(), |mut buffer, module| {
            buffer.push_str(&format!("from {} import ", module));
            let mut imports = self
                .imports
                .get(*module)
                .unwrap()
                .into_iter()
                .collect::<Vec<_>>();
            imports.sort();
            buffer.push_str(
                &imports
                    .iter()
                    .fold(String::new(), |mut buffer, name| {
                        buffer.push_str(name);
                        buffer.push_str(", ");
                        buffer
                    })
                    .trim_end_matches(", "),
            );

            if module.starts_with(".") && self.is_export {
                exports.extend(imports.iter().map(|s| (*s).clone()));
            }

            buffer.push('\n');
            buffer
        });

        buffer.push_str("\n\n");
        buffer.push_str(&self.content);

        if !exports.is_empty() {
            buffer.push_str("\n\n__all__ = [\n");
            buffer.push_str(
                &exports
                    .iter()
                    .fold(String::new(), |mut buffer, name| {
                        buffer.push_str(&format!("    '{}',\n", name));
                        buffer
                    })
                    .trim_end_matches(",\n"),
            );
            buffer.push_str("\n]\n");
        }

        buffer
    }
}
