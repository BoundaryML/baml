// This file is auto-generated. Do not edit this file manually.
//
// Disable formatting for this file to avoid linting errors.
// tslint:disable
// @ts-nocheck

import { DataStruct, ShippingPort, MyObject, Container, Tool, Intent, Invoice, MeetingRequestPartial, Sentiment, Facility, Coordinate, MeetingRequest, Location, Route, DocumentTopic, Shipment, ShipmentMetadata, RoutePoint, MeetingRequestPartial2, Message, Validation, UserType, Conversation, Event, Attendee, Vessel } from './types';


// Function to check if a value is a member of the DocumentTopic enum
function isDocumentTopic(value: any): value is DocumentTopic {
  return Object.values(DocumentTopic).includes(value);
}

// Function to check if a value is a member of the Intent enum
function isIntent(value: any): value is Intent {
  return Object.values(Intent).includes(value);
}

// Function to check if a value is a member of the Sentiment enum
function isSentiment(value: any): value is Sentiment {
  return Object.values(Sentiment).includes(value);
}

// Function to check if a value is a member of the ShippingPort enum
function isShippingPort(value: any): value is ShippingPort {
  return Object.values(ShippingPort).includes(value);
}

// Function to check if a value is a member of the Tool enum
function isTool(value: any): value is Tool {
  return Object.values(Tool).includes(value);
}

// Function to check if a value is a member of the UserType enum
function isUserType(value: any): value is UserType {
  return Object.values(UserType).includes(value);
}

// Function to validate if an object is a Attendee object
function isAttendee(obj: any): obj is Attendee {
  return (
    obj &&
    typeof obj === "object"
    && ("name" in obj && (typeof obj.name === 'string'))
    && ("email" in obj && (typeof obj.email === 'string'))
  );
}


class InternalAttendee implements Attendee {
  private constructor(private data: {
    name: string,
    email: string,
  }, private raw: Attendee) {}

  static from(data: Attendee): InternalAttendee {
    return new InternalAttendee({
      name: data.name,
      email: data.email,
    }, data);
  }

  get name(): string {
    return this.data.name;
  }
  get email(): string {
    return this.data.email;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Container object
function isContainer(obj: any): obj is Container {
  return (
    obj &&
    typeof obj === "object"
    && ("number" in obj && (typeof obj.number === 'string'))
    && ("isoCode" in obj && ((obj.isoCode === null || obj.isoCode === undefined) || typeof obj.isoCode === 'string'))
    && ("status" in obj && (typeof obj.status === 'string'))
    && ("events" in obj && (Array.isArray(obj.events) && obj.events.every((x: any) => isEvent(x))))
  );
}


class InternalContainer implements Container {
  private constructor(private data: {
    number: string,
    isoCode: string | null,
    status: string,
    events: InternalEvent[],
  }, private raw: Container) {}

  static from(data: Container): InternalContainer {
    return new InternalContainer({
      number: data.number,
      isoCode: (data.isoCode === null || data.isoCode === undefined) ? null : data.isoCode,
      status: data.status,
      events: data.events.map(x => new InternalEvent(x)),
    }, data);
  }

  get number(): string {
    return this.data.number;
  }
  get isoCode(): string | null {
    return this.data.isoCode;
  }
  get status(): string {
    return this.data.status;
  }
  get events(): InternalEvent[] {
    return this.data.events;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Conversation object
function isConversation(obj: any): obj is Conversation {
  return (
    obj &&
    typeof obj === "object"
    && ("messages" in obj && (Array.isArray(obj.messages) && obj.messages.every((x: any) => isMessage(x))))
  );
}


class InternalConversation implements Conversation {
  private constructor(private data: {
    messages: InternalMessage[],
  }, private raw: Conversation) {}

  static from(data: Conversation): InternalConversation {
    return new InternalConversation({
      messages: data.messages.map(x => new InternalMessage(x)),
    }, data);
  }

  get messages(): InternalMessage[] {
    return this.data.messages;
  }

  get display(): string {
    // TODO: Implement
    return this.messages.map(m => m.display).join('\n');
  }

  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Coordinate object
function isCoordinate(obj: any): obj is Coordinate {
  return (
    obj &&
    typeof obj === "object"
    && ("lat" in obj && ((obj.lat === null || obj.lat === undefined) || typeof obj.lat === 'number'))
    && ("lng" in obj && ((obj.lng === null || obj.lng === undefined) || typeof obj.lng === 'number'))
    && ("updatedAt" in obj && ((obj.updatedAt === null || obj.updatedAt === undefined) || typeof obj.updatedAt === 'string'))
  );
}


class InternalCoordinate implements Coordinate {
  private constructor(private data: {
    lat: number | null,
    lng: number | null,
    updatedAt: string | null,
  }, private raw: Coordinate) {}

  static from(data: Coordinate): InternalCoordinate {
    return new InternalCoordinate({
      lat: (data.lat === null || data.lat === undefined) ? null : data.lat,
      lng: (data.lng === null || data.lng === undefined) ? null : data.lng,
      updatedAt: (data.updatedAt === null || data.updatedAt === undefined) ? null : data.updatedAt,
    }, data);
  }

  get lat(): number | null {
    return this.data.lat;
  }
  get lng(): number | null {
    return this.data.lng;
  }
  get updatedAt(): string | null {
    return this.data.updatedAt;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a DataStruct object
function isDataStruct(obj: any): obj is DataStruct {
  return (
    obj &&
    typeof obj === "object"
    && ("port" in obj && ((isShippingPort(obj.port)) || (typeof obj.port === 'string')))
    && ("booking_number" in obj && (typeof obj.booking_number === 'number'))
  );
}


class InternalDataStruct implements DataStruct {
  private constructor(private data: {
    port: ShippingPort | string,
    booking_number: number,
  }, private raw: DataStruct) {}

  static from(data: DataStruct): InternalDataStruct {
    return new InternalDataStruct({
      port: ((x) => {
if (isShippingPort(x)) {
  return x;
}
if (typeof x === 'string') {
  return x;
}
})(data.port),
      booking_number: data.booking_number,
    }, data);
  }

  get port(): ShippingPort | string {
    return this.data.port;
  }
  get booking_number(): number {
    return this.data.booking_number;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Event object
function isEvent(obj: any): obj is Event {
  return (
    obj &&
    typeof obj === "object"
    && ("location" in obj && (isLocation(obj.location)))
    && ("facility" in obj && (isFacility(obj.facility)))
    && ("description" in obj && (typeof obj.description === 'string'))
    && ("eventType" in obj && (typeof obj.eventType === 'string'))
    && ("eventCode" in obj && (typeof obj.eventCode === 'string'))
    && ("status" in obj && (typeof obj.status === 'string'))
    && ("date" in obj && (typeof obj.date === 'string'))
    && ("isActual" in obj && (typeof obj.isActual === 'boolean'))
    && ("isAdditionalEvent" in obj && (typeof obj.isAdditionalEvent === 'boolean'))
    && ("routeType" in obj && (typeof obj.routeType === 'string'))
    && ("transportType" in obj && (typeof obj.transportType === 'string'))
    && ("vessel" in obj && (isVessel(obj.vessel)))
    && ("voyage" in obj && (typeof obj.voyage === 'string'))
  );
}


class InternalEvent implements Event {
  private constructor(private data: {
    location: InternalLocation,
    facility: InternalFacility,
    description: string,
    eventType: string,
    eventCode: string,
    status: string,
    date: string,
    isActual: boolean,
    isAdditionalEvent: boolean,
    routeType: string,
    transportType: string,
    vessel: InternalVessel,
    voyage: string,
  }, private raw: Event) {}

  static from(data: Event): InternalEvent {
    return new InternalEvent({
      location: new InternalLocation(data.location),
      facility: new InternalFacility(data.facility),
      description: data.description,
      eventType: data.eventType,
      eventCode: data.eventCode,
      status: data.status,
      date: data.date,
      isActual: data.isActual,
      isAdditionalEvent: data.isAdditionalEvent,
      routeType: data.routeType,
      transportType: data.transportType,
      vessel: new InternalVessel(data.vessel),
      voyage: data.voyage,
    }, data);
  }

  get location(): InternalLocation {
    return this.data.location;
  }
  get facility(): InternalFacility {
    return this.data.facility;
  }
  get description(): string {
    return this.data.description;
  }
  get eventType(): string {
    return this.data.eventType;
  }
  get eventCode(): string {
    return this.data.eventCode;
  }
  get status(): string {
    return this.data.status;
  }
  get date(): string {
    return this.data.date;
  }
  get isActual(): boolean {
    return this.data.isActual;
  }
  get isAdditionalEvent(): boolean {
    return this.data.isAdditionalEvent;
  }
  get routeType(): string {
    return this.data.routeType;
  }
  get transportType(): string {
    return this.data.transportType;
  }
  get vessel(): InternalVessel {
    return this.data.vessel;
  }
  get voyage(): string {
    return this.data.voyage;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Facility object
function isFacility(obj: any): obj is Facility {
  return (
    obj &&
    typeof obj === "object"
    && ("name" in obj && (typeof obj.name === 'string'))
    && ("countryCode" in obj && (typeof obj.countryCode === 'string'))
    && ("locode" in obj && (typeof obj.locode === 'string'))
    && ("bicCode" in obj && ((obj.bicCode === null || obj.bicCode === undefined) || typeof obj.bicCode === 'string'))
    && ("smdgCode" in obj && ((obj.smdgCode === null || obj.smdgCode === undefined) || typeof obj.smdgCode === 'string'))
    && ("coordinates" in obj && (isCoordinate(obj.coordinates)))
  );
}


class InternalFacility implements Facility {
  private constructor(private data: {
    name: string,
    countryCode: string,
    locode: string,
    bicCode: string | null,
    smdgCode: string | null,
    coordinates: InternalCoordinate,
  }, private raw: Facility) {}

  static from(data: Facility): InternalFacility {
    return new InternalFacility({
      name: data.name,
      countryCode: data.countryCode,
      locode: data.locode,
      bicCode: (data.bicCode === null || data.bicCode === undefined) ? null : data.bicCode,
      smdgCode: (data.smdgCode === null || data.smdgCode === undefined) ? null : data.smdgCode,
      coordinates: new InternalCoordinate(data.coordinates),
    }, data);
  }

  get name(): string {
    return this.data.name;
  }
  get countryCode(): string {
    return this.data.countryCode;
  }
  get locode(): string {
    return this.data.locode;
  }
  get bicCode(): string | null {
    return this.data.bicCode;
  }
  get smdgCode(): string | null {
    return this.data.smdgCode;
  }
  get coordinates(): InternalCoordinate {
    return this.data.coordinates;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Invoice object
function isInvoice(obj: any): obj is Invoice {
  return (
    obj &&
    typeof obj === "object"
    && ("name" in obj && (typeof obj.name === 'string'))
    && ("amount" in obj && (typeof obj.amount === 'number'))
  );
}


class InternalInvoice implements Invoice {
  private constructor(private data: {
    name: string,
    amount: number,
  }, private raw: Invoice) {}

  static from(data: Invoice): InternalInvoice {
    return new InternalInvoice({
      name: data.name,
      amount: data.amount,
    }, data);
  }

  get name(): string {
    return this.data.name;
  }
  get amount(): number {
    return this.data.amount;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Location object
function isLocation(obj: any): obj is Location {
  return (
    obj &&
    typeof obj === "object"
    && ("name" in obj && (typeof obj.name === 'string'))
    && ("state" in obj && (typeof obj.state === 'string'))
    && ("country" in obj && (typeof obj.country === 'string'))
    && ("countryCode" in obj && (typeof obj.countryCode === 'string'))
    && ("locode" in obj && (typeof obj.locode === 'string'))
    && ("coordinates" in obj && (isCoordinate(obj.coordinates)))
    && ("timezone" in obj && (typeof obj.timezone === 'string'))
  );
}


class InternalLocation implements Location {
  private constructor(private data: {
    name: string,
    state: string,
    country: string,
    countryCode: string,
    locode: string,
    coordinates: InternalCoordinate,
    timezone: string,
  }, private raw: Location) {}

  static from(data: Location): InternalLocation {
    return new InternalLocation({
      name: data.name,
      state: data.state,
      country: data.country,
      countryCode: data.countryCode,
      locode: data.locode,
      coordinates: new InternalCoordinate(data.coordinates),
      timezone: data.timezone,
    }, data);
  }

  get name(): string {
    return this.data.name;
  }
  get state(): string {
    return this.data.state;
  }
  get country(): string {
    return this.data.country;
  }
  get countryCode(): string {
    return this.data.countryCode;
  }
  get locode(): string {
    return this.data.locode;
  }
  get coordinates(): InternalCoordinate {
    return this.data.coordinates;
  }
  get timezone(): string {
    return this.data.timezone;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a MeetingRequest object
function isMeetingRequest(obj: any): obj is MeetingRequest {
  return (
    obj &&
    typeof obj === "object"
    && ("time" in obj && (typeof obj.time === 'string'))
    && ("attendees" in obj && (Array.isArray(obj.attendees) && obj.attendees.every((x: any) => isAttendee(x))))
    && ("topic" in obj && (typeof obj.topic === 'string'))
  );
}


class InternalMeetingRequest implements MeetingRequest {
  private constructor(private data: {
    time: string,
    attendees: InternalAttendee[],
    topic: string,
  }, private raw: MeetingRequest) {}

  static from(data: MeetingRequest): InternalMeetingRequest {
    return new InternalMeetingRequest({
      time: data.time,
      attendees: data.attendees.map(x => new InternalAttendee(x)),
      topic: data.topic,
    }, data);
  }

  get time(): string {
    return this.data.time;
  }
  get attendees(): InternalAttendee[] {
    return this.data.attendees;
  }
  get topic(): string {
    return this.data.topic;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a MeetingRequestPartial object
function isMeetingRequestPartial(obj: any): obj is MeetingRequestPartial {
  return (
    obj &&
    typeof obj === "object"
    && ("time" in obj && ((obj.time === null || obj.time === undefined) || typeof obj.time === 'string'))
    && ("duration" in obj && ((obj.duration === null || obj.duration === undefined) || typeof obj.duration === 'string'))
    && ("attendees" in obj && (Array.isArray(obj.attendees) && obj.attendees.every((x: any) => typeof x === 'string')))
    && ("topic" in obj && ((obj.topic === null || obj.topic === undefined) || typeof obj.topic === 'string'))
  );
}


class InternalMeetingRequestPartial implements MeetingRequestPartial {
  private constructor(private data: {
    time: string | null,
    duration: string | null,
    attendees: string[],
    topic: string | null,
  }, private raw: MeetingRequestPartial) {}

  static from(data: MeetingRequestPartial): InternalMeetingRequestPartial {
    return new InternalMeetingRequestPartial({
      time: (data.time === null || data.time === undefined) ? null : data.time,
      duration: (data.duration === null || data.duration === undefined) ? null : data.duration,
      attendees: data.attendees.map(x => x),
      topic: (data.topic === null || data.topic === undefined) ? null : data.topic,
    }, data);
  }

  get time(): string | null {
    return this.data.time;
  }
  get duration(): string | null {
    return this.data.duration;
  }
  get attendees(): string[] {
    return this.data.attendees;
  }
  get topic(): string | null {
    return this.data.topic;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a MeetingRequestPartial2 object
function isMeetingRequestPartial2(obj: any): obj is MeetingRequestPartial2 {
  return (
    obj &&
    typeof obj === "object"
    && ("time" in obj && ((obj.time === null || obj.time === undefined) || typeof obj.time === 'string'))
    && ("duration" in obj && ((obj.duration === null || obj.duration === undefined) || typeof obj.duration === 'string'))
    && ("attendees" in obj && (Array.isArray(obj.attendees) && obj.attendees.every((x: any) => typeof x === 'string')))
    && ("topic" in obj && ((obj.topic === null || obj.topic === undefined) || typeof obj.topic === 'string'))
  );
}


class InternalMeetingRequestPartial2 implements MeetingRequestPartial2 {
  private constructor(private data: {
    time: string | null,
    duration: string | null,
    attendees: string[],
    topic: string | null,
  }, private raw: MeetingRequestPartial2) {}

  static from(data: MeetingRequestPartial2): InternalMeetingRequestPartial2 {
    return new InternalMeetingRequestPartial2({
      time: (data.time === null || data.time === undefined) ? null : data.time,
      duration: (data.duration === null || data.duration === undefined) ? null : data.duration,
      attendees: data.attendees.map(x => x),
      topic: (data.topic === null || data.topic === undefined) ? null : data.topic,
    }, data);
  }

  get time(): string | null {
    return this.data.time;
  }
  get duration(): string | null {
    return this.data.duration;
  }
  get attendees(): string[] {
    return this.data.attendees;
  }
  get topic(): string | null {
    return this.data.topic;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Message object
function isMessage(obj: any): obj is Message {
  return (
    obj &&
    typeof obj === "object"
    && ("user" in obj && (isUserType(obj.user)))
    && ("content" in obj && (typeof obj.content === 'string'))
  );
}


class InternalMessage implements Message {
  private constructor(private data: {
    user: UserType,
    content: string,
  }, private raw: Message) {}

  static from(data: Message): InternalMessage {
    return new InternalMessage({
      user: data.user,
      content: data.content,
    }, data);
  }

  get user(): UserType {
    return this.data.user;
  }
  get content(): string {
    return this.data.content;
  }

  get display(): string {
    // TODO: Implement
    if (this.user === UserType.AI) {
    return `Service Provider: ${this.content}`;
} else {
    return `User: ${this.content}`;
}
  }

  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a MyObject object
function isMyObject(obj: any): obj is MyObject {
  return (
    obj &&
    typeof obj === "object"
    && ("foo" in obj && ((typeof obj.foo === 'string') || (Array.isArray(obj.foo) && obj.foo.every((x: any) => typeof x === 'string'))))
    && ("bar" in obj && (Array.isArray(obj.bar) && obj.bar.every((x: any) => typeof x === 'string')))
  );
}


class InternalMyObject implements MyObject {
  private constructor(private data: {
    foo: string | string[],
    bar: string[],
  }, private raw: MyObject) {}

  static from(data: MyObject): InternalMyObject {
    return new InternalMyObject({
      foo: ((x) => {
if (typeof x === 'string') {
  return x;
}
if (Array.isArray(x) && x.every((x: any) => typeof x === 'string')) {
  return x.map(x => x);
}
})(data.foo),
      bar: data.bar.map(x => x),
    }, data);
  }

  get foo(): string | string[] {
    return this.data.foo;
  }
  get bar(): string[] {
    return this.data.bar;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Route object
function isRoute(obj: any): obj is Route {
  return (
    obj &&
    typeof obj === "object"
    && ("prepol" in obj && (isRoutePoint(obj.prepol)))
    && ("pol" in obj && (isRoutePoint(obj.pol)))
    && ("pod" in obj && (isRoutePoint(obj.pod)))
    && ("postpod" in obj && (isRoutePoint(obj.postpod)))
  );
}


class InternalRoute implements Route {
  private constructor(private data: {
    prepol: InternalRoutePoint,
    pol: InternalRoutePoint,
    pod: InternalRoutePoint,
    postpod: InternalRoutePoint,
  }, private raw: Route) {}

  static from(data: Route): InternalRoute {
    return new InternalRoute({
      prepol: new InternalRoutePoint(data.prepol),
      pol: new InternalRoutePoint(data.pol),
      pod: new InternalRoutePoint(data.pod),
      postpod: new InternalRoutePoint(data.postpod),
    }, data);
  }

  get prepol(): InternalRoutePoint {
    return this.data.prepol;
  }
  get pol(): InternalRoutePoint {
    return this.data.pol;
  }
  get pod(): InternalRoutePoint {
    return this.data.pod;
  }
  get postpod(): InternalRoutePoint {
    return this.data.postpod;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a RoutePoint object
function isRoutePoint(obj: any): obj is RoutePoint {
  return (
    obj &&
    typeof obj === "object"
    && ("location" in obj && ((obj.location === null || obj.location === undefined) || isLocation(obj.location)))
    && ("date" in obj && ((obj.date === null || obj.date === undefined) || typeof obj.date === 'string'))
    && ("actual" in obj && ((obj.actual === null || obj.actual === undefined) || typeof obj.actual === 'boolean'))
    && ("predictiveEta" in obj && ((obj.predictiveEta === null || obj.predictiveEta === undefined) || typeof obj.predictiveEta === 'string'))
  );
}


class InternalRoutePoint implements RoutePoint {
  private constructor(private data: {
    location: Location | null,
    date: string | null,
    actual: boolean | null,
    predictiveEta: string | null,
  }, private raw: RoutePoint) {}

  static from(data: RoutePoint): InternalRoutePoint {
    return new InternalRoutePoint({
      location: (data.location === null || data.location === undefined) ? null : new InternalLocation(data.location),
      date: (data.date === null || data.date === undefined) ? null : data.date,
      actual: (data.actual === null || data.actual === undefined) ? null : data.actual,
      predictiveEta: (data.predictiveEta === null || data.predictiveEta === undefined) ? null : data.predictiveEta,
    }, data);
  }

  get location(): Location | null {
    return this.data.location;
  }
  get date(): string | null {
    return this.data.date;
  }
  get actual(): boolean | null {
    return this.data.actual;
  }
  get predictiveEta(): string | null {
    return this.data.predictiveEta;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Shipment object
function isShipment(obj: any): obj is Shipment {
  return (
    obj &&
    typeof obj === "object"
    && ("metadata" in obj && (isShipmentMetadata(obj.metadata)))
    && ("locations" in obj && (Array.isArray(obj.locations) && obj.locations.every((x: any) => isLocation(x))))
    && ("route" in obj && (isRoute(obj.route)))
    && ("vessels" in obj && (Array.isArray(obj.vessels) && obj.vessels.every((x: any) => isVessel(x))))
    && ("facilities" in obj && (Array.isArray(obj.facilities) && obj.facilities.every((x: any) => isFacility(x))))
    && ("containers" in obj && (Array.isArray(obj.containers) && obj.containers.every((x: any) => isContainer(x))))
  );
}


class InternalShipment implements Shipment {
  private constructor(private data: {
    metadata: InternalShipmentMetadata,
    locations: InternalLocation[],
    route: InternalRoute,
    vessels: InternalVessel[],
    facilities: InternalFacility[],
    containers: InternalContainer[],
  }, private raw: Shipment) {}

  static from(data: Shipment): InternalShipment {
    return new InternalShipment({
      metadata: new InternalShipmentMetadata(data.metadata),
      locations: data.locations.map(x => new InternalLocation(x)),
      route: new InternalRoute(data.route),
      vessels: data.vessels.map(x => new InternalVessel(x)),
      facilities: data.facilities.map(x => new InternalFacility(x)),
      containers: data.containers.map(x => new InternalContainer(x)),
    }, data);
  }

  get metadata(): InternalShipmentMetadata {
    return this.data.metadata;
  }
  get locations(): InternalLocation[] {
    return this.data.locations;
  }
  get route(): InternalRoute {
    return this.data.route;
  }
  get vessels(): InternalVessel[] {
    return this.data.vessels;
  }
  get facilities(): InternalFacility[] {
    return this.data.facilities;
  }
  get containers(): InternalContainer[] {
    return this.data.containers;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a ShipmentMetadata object
function isShipmentMetadata(obj: any): obj is ShipmentMetadata {
  return (
    obj &&
    typeof obj === "object"
    && ("shipmentType" in obj && (typeof obj.shipmentType === 'string'))
    && ("shipmentNumber" in obj && (typeof obj.shipmentNumber === 'string'))
    && ("sealine" in obj && (typeof obj.sealine === 'string'))
    && ("sealineName" in obj && (typeof obj.sealineName === 'string'))
    && ("shippingStatus" in obj && (typeof obj.shippingStatus === 'string'))
    && ("updatedAt" in obj && (typeof obj.updatedAt === 'string'))
  );
}


class InternalShipmentMetadata implements ShipmentMetadata {
  private constructor(private data: {
    shipmentType: string,
    shipmentNumber: string,
    sealine: string,
    sealineName: string,
    shippingStatus: string,
    updatedAt: string,
  }, private raw: ShipmentMetadata) {}

  static from(data: ShipmentMetadata): InternalShipmentMetadata {
    return new InternalShipmentMetadata({
      shipmentType: data.shipmentType,
      shipmentNumber: data.shipmentNumber,
      sealine: data.sealine,
      sealineName: data.sealineName,
      shippingStatus: data.shippingStatus,
      updatedAt: data.updatedAt,
    }, data);
  }

  get shipmentType(): string {
    return this.data.shipmentType;
  }
  get shipmentNumber(): string {
    return this.data.shipmentNumber;
  }
  get sealine(): string {
    return this.data.sealine;
  }
  get sealineName(): string {
    return this.data.sealineName;
  }
  get shippingStatus(): string {
    return this.data.shippingStatus;
  }
  get updatedAt(): string {
    return this.data.updatedAt;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Validation object
function isValidation(obj: any): obj is Validation {
  return (
    obj &&
    typeof obj === "object"
    && ("requirements_complete" in obj && (typeof obj.requirements_complete === 'boolean'))
    && ("follow_up_question" in obj && ((obj.follow_up_question === null || obj.follow_up_question === undefined) || typeof obj.follow_up_question === 'string'))
  );
}


class InternalValidation implements Validation {
  private constructor(private data: {
    requirements_complete: boolean,
    follow_up_question: string | null,
  }, private raw: Validation) {}

  static from(data: Validation): InternalValidation {
    return new InternalValidation({
      requirements_complete: data.requirements_complete,
      follow_up_question: (data.follow_up_question === null || data.follow_up_question === undefined) ? null : data.follow_up_question,
    }, data);
  }

  get requirements_complete(): boolean {
    return this.data.requirements_complete;
  }
  get follow_up_question(): string | null {
    return this.data.follow_up_question;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}

// Function to validate if an object is a Vessel object
function isVessel(obj: any): obj is Vessel {
  return (
    obj &&
    typeof obj === "object"
    && ("name" in obj && (typeof obj.name === 'string'))
    && ("imo" in obj && (typeof obj.imo === 'number'))
    && ("callSign" in obj && (typeof obj.callSign === 'string'))
    && ("mmsi" in obj && (typeof obj.mmsi === 'number'))
    && ("flag" in obj && (typeof obj.flag === 'string'))
  );
}


class InternalVessel implements Vessel {
  private constructor(private data: {
    name: string,
    imo: number,
    callSign: string,
    mmsi: number,
    flag: string,
  }, private raw: Vessel) {}

  static from(data: Vessel): InternalVessel {
    return new InternalVessel({
      name: data.name,
      imo: data.imo,
      callSign: data.callSign,
      mmsi: data.mmsi,
      flag: data.flag,
    }, data);
  }

  get name(): string {
    return this.data.name;
  }
  get imo(): number {
    return this.data.imo;
  }
  get callSign(): string {
    return this.data.callSign;
  }
  get mmsi(): number {
    return this.data.mmsi;
  }
  get flag(): string {
    return this.data.flag;
  }


  toJSON(): string {
    return JSON.stringify(this.raw, null, 2);
  }
}


export { InternalAttendee, InternalContainer, InternalConversation, InternalCoordinate, InternalDataStruct, InternalEvent, InternalFacility, InternalInvoice, InternalLocation, InternalMeetingRequest, InternalMeetingRequestPartial, InternalMeetingRequestPartial2, InternalMessage, InternalMyObject, InternalRoute, InternalRoutePoint, InternalShipment, InternalShipmentMetadata, InternalValidation, InternalVessel }