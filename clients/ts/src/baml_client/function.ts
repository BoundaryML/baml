// This file is auto-generated. Do not edit this file manually.
//
// Disable formatting for this file to avoid linting errors.
// tslint:disable
// @ts-nocheck

import { Invoice, Intent, MyObject, DataStruct, Tool, MeetingRequestPartial, Conversation, Validation, DocumentTopic, MeetingRequest } from './types';


type IClassifyDocumentTopic = (args: {
  document_text: string
}) => Promise<DocumentTopic>

type ClassifyDocumentTopicImpls = 'simpleclassifydocumenttopic';

interface ClassifyDocumentTopicImpl {
    run: IClassifyDocumentTopic;
    name: ClassifyDocumentTopicImpls;
}

interface ClassifyDocumentTopicFunction {
  registerImpl: (name: ClassifyDocumentTopicImpls, impl: ClassifyDocumentTopicImpl) => void;
  getImpl: (name: ClassifyDocumentTopicImpls) => ClassifyDocumentTopicImpl;
}

function createClassifyDocumentTopicInstance(): IClassifyDocumentTopic & ClassifyDocumentTopicFunction {

  const registry: Record<ClassifyDocumentTopicImpls, ClassifyDocumentTopicImpl> = {}

  const wrapper: ClassifyDocumentTopicFunction = {
    getImpl: (name: ClassifyDocumentTopicImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ClassifyDocumentTopic with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ClassifyDocumentTopicImpls, impl: ClassifyDocumentTopicImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for ClassifyDocumentTopic with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['simpleclassifydocumenttopic'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ClassifyDocumentTopic: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    document_text: string
  }) => {
    return wrapper.getImpl('simpleclassifydocumenttopic').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IClassifyDocumentTopic & ClassifyDocumentTopicFunction;
}

const ClassifyDocumentTopic = createClassifyDocumentTopicInstance();

type IClassifyIntent = (args: {
  query: string
}) => Promise<Intent[]>

type ClassifyIntentImpls = 'simple' | 'advanced';

interface ClassifyIntentImpl {
    run: IClassifyIntent;
    name: ClassifyIntentImpls;
}

interface ClassifyIntentFunction {
  registerImpl: (name: ClassifyIntentImpls, impl: ClassifyIntentImpl) => void;
  getImpl: (name: ClassifyIntentImpls) => ClassifyIntentImpl;
}

function createClassifyIntentInstance(): IClassifyIntent & ClassifyIntentFunction {

  const registry: Record<ClassifyIntentImpls, ClassifyIntentImpl> = {}

  const wrapper: ClassifyIntentFunction = {
    getImpl: (name: ClassifyIntentImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ClassifyIntent with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ClassifyIntentImpls, impl: ClassifyIntentImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for ClassifyIntent with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['simple', 'advanced'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ClassifyIntent: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    query: string
  }) => {
    return wrapper.getImpl('simple').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IClassifyIntent & ClassifyIntentFunction;
}

const ClassifyIntent = createClassifyIntentInstance();

type IExtractInvoice = (arg: string) => Promise<Invoice[]>

type ExtractInvoiceImpls = 'foo';

interface ExtractInvoiceImpl {
    run: IExtractInvoice;
    name: ExtractInvoiceImpls;
}

interface ExtractInvoiceFunction {
  registerImpl: (name: ExtractInvoiceImpls, impl: ExtractInvoiceImpl) => void;
  getImpl: (name: ExtractInvoiceImpls) => ExtractInvoiceImpl;
}

function createExtractInvoiceInstance(): IExtractInvoice & ExtractInvoiceFunction {

  const registry: Record<ExtractInvoiceImpls, ExtractInvoiceImpl> = {}

  const wrapper: ExtractInvoiceFunction = {
    getImpl: (name: ExtractInvoiceImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractInvoice with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractInvoiceImpls, impl: ExtractInvoiceImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractInvoice with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['foo'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractInvoice: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('foo').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractInvoice & ExtractInvoiceFunction;
}

const ExtractInvoice = createExtractInvoiceInstance();

type IExtractMeetingRequestInfo = (args: {
  convo: Conversation, now: string
}) => Promise<MeetingRequest>

type ExtractMeetingRequestInfoImpls = 'robust' | 'simple';

interface ExtractMeetingRequestInfoImpl {
    run: IExtractMeetingRequestInfo;
    name: ExtractMeetingRequestInfoImpls;
}

interface ExtractMeetingRequestInfoFunction {
  registerImpl: (name: ExtractMeetingRequestInfoImpls, impl: ExtractMeetingRequestInfoImpl) => void;
  getImpl: (name: ExtractMeetingRequestInfoImpls) => ExtractMeetingRequestInfoImpl;
}

function createExtractMeetingRequestInfoInstance(): IExtractMeetingRequestInfo & ExtractMeetingRequestInfoFunction {

  const registry: Record<ExtractMeetingRequestInfoImpls, ExtractMeetingRequestInfoImpl> = {}

  const wrapper: ExtractMeetingRequestInfoFunction = {
    getImpl: (name: ExtractMeetingRequestInfoImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractMeetingRequestInfo with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractMeetingRequestInfoImpls, impl: ExtractMeetingRequestInfoImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractMeetingRequestInfo with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['robust', 'simple'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractMeetingRequestInfo: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    convo: Conversation, now: string
  }) => {
    return wrapper.getImpl('simple').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractMeetingRequestInfo & ExtractMeetingRequestInfoFunction;
}

const ExtractMeetingRequestInfo = createExtractMeetingRequestInfoInstance();

type IExtractMeetingRequestInfoPartial = (args: {
  convo: Conversation, now: string
}) => Promise<MeetingRequestPartial>

type ExtractMeetingRequestInfoPartialImpls = 'v1';

interface ExtractMeetingRequestInfoPartialImpl {
    run: IExtractMeetingRequestInfoPartial;
    name: ExtractMeetingRequestInfoPartialImpls;
}

interface ExtractMeetingRequestInfoPartialFunction {
  registerImpl: (name: ExtractMeetingRequestInfoPartialImpls, impl: ExtractMeetingRequestInfoPartialImpl) => void;
  getImpl: (name: ExtractMeetingRequestInfoPartialImpls) => ExtractMeetingRequestInfoPartialImpl;
}

function createExtractMeetingRequestInfoPartialInstance(): IExtractMeetingRequestInfoPartial & ExtractMeetingRequestInfoPartialFunction {

  const registry: Record<ExtractMeetingRequestInfoPartialImpls, ExtractMeetingRequestInfoPartialImpl> = {}

  const wrapper: ExtractMeetingRequestInfoPartialFunction = {
    getImpl: (name: ExtractMeetingRequestInfoPartialImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractMeetingRequestInfoPartial with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractMeetingRequestInfoPartialImpls, impl: ExtractMeetingRequestInfoPartialImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractMeetingRequestInfoPartial with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractMeetingRequestInfoPartial: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    convo: Conversation, now: string
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractMeetingRequestInfoPartial & ExtractMeetingRequestInfoPartialFunction;
}

const ExtractMeetingRequestInfoPartial = createExtractMeetingRequestInfoPartialInstance();

type IExtractObject = (args: {
  query: string
}) => Promise<MyObject[]>

type ExtractObjectImpls = 'my_impl';

interface ExtractObjectImpl {
    run: IExtractObject;
    name: ExtractObjectImpls;
}

interface ExtractObjectFunction {
  registerImpl: (name: ExtractObjectImpls, impl: ExtractObjectImpl) => void;
  getImpl: (name: ExtractObjectImpls) => ExtractObjectImpl;
}

function createExtractObjectInstance(): IExtractObject & ExtractObjectFunction {

  const registry: Record<ExtractObjectImpls, ExtractObjectImpl> = {}

  const wrapper: ExtractObjectFunction = {
    getImpl: (name: ExtractObjectImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for ExtractObject with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: ExtractObjectImpls, impl: ExtractObjectImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for ExtractObject with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['my_impl'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for ExtractObject: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    query: string
  }) => {
    return wrapper.getImpl('my_impl').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IExtractObject & ExtractObjectFunction;
}

const ExtractObject = createExtractObjectInstance();

type IGenerateOutreachEmail = (arg: string) => Promise<number[]>

type GenerateOutreachEmailImpls = 'version1';

interface GenerateOutreachEmailImpl {
    run: IGenerateOutreachEmail;
    name: GenerateOutreachEmailImpls;
}

interface GenerateOutreachEmailFunction {
  registerImpl: (name: GenerateOutreachEmailImpls, impl: GenerateOutreachEmailImpl) => void;
  getImpl: (name: GenerateOutreachEmailImpls) => GenerateOutreachEmailImpl;
}

function createGenerateOutreachEmailInstance(): IGenerateOutreachEmail & GenerateOutreachEmailFunction {

  const registry: Record<GenerateOutreachEmailImpls, GenerateOutreachEmailImpl> = {}

  const wrapper: GenerateOutreachEmailFunction = {
    getImpl: (name: GenerateOutreachEmailImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GenerateOutreachEmail with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GenerateOutreachEmailImpls, impl: GenerateOutreachEmailImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for GenerateOutreachEmail with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['version1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for GenerateOutreachEmail: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('version1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IGenerateOutreachEmail & GenerateOutreachEmailFunction;
}

const GenerateOutreachEmail = createGenerateOutreachEmailInstance();

type IGetDetailsKyle = (args: {
  query: string, context: string
}) => Promise<DataStruct[]>

type GetDetailsKyleImpls = 'v1';

interface GetDetailsKyleImpl {
    run: IGetDetailsKyle;
    name: GetDetailsKyleImpls;
}

interface GetDetailsKyleFunction {
  registerImpl: (name: GetDetailsKyleImpls, impl: GetDetailsKyleImpl) => void;
  getImpl: (name: GetDetailsKyleImpls) => GetDetailsKyleImpl;
}

function createGetDetailsKyleInstance(): IGetDetailsKyle & GetDetailsKyleFunction {

  const registry: Record<GetDetailsKyleImpls, GetDetailsKyleImpl> = {}

  const wrapper: GetDetailsKyleFunction = {
    getImpl: (name: GetDetailsKyleImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GetDetailsKyle with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GetDetailsKyleImpls, impl: GetDetailsKyleImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for GetDetailsKyle with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for GetDetailsKyle: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    query: string, context: string
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IGetDetailsKyle & GetDetailsKyleFunction;
}

const GetDetailsKyle = createGetDetailsKyleInstance();

type IGetNextQuestion = (arg: MeetingRequestPartial) => Promise<Validation>

type GetNextQuestionImpls = 'v1';

interface GetNextQuestionImpl {
    run: IGetNextQuestion;
    name: GetNextQuestionImpls;
}

interface GetNextQuestionFunction {
  registerImpl: (name: GetNextQuestionImpls, impl: GetNextQuestionImpl) => void;
  getImpl: (name: GetNextQuestionImpls) => GetNextQuestionImpl;
}

function createGetNextQuestionInstance(): IGetNextQuestion & GetNextQuestionFunction {

  const registry: Record<GetNextQuestionImpls, GetNextQuestionImpl> = {}

  const wrapper: GetNextQuestionFunction = {
    getImpl: (name: GetNextQuestionImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GetNextQuestion with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GetNextQuestionImpls, impl: GetNextQuestionImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for GetNextQuestion with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for GetNextQuestion: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: MeetingRequestPartial) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);

  return impl as  IGetNextQuestion & GetNextQuestionFunction;
}

const GetNextQuestion = createGetNextQuestionInstance();

type IGetTool = (args: {
  context: string, query: string
}) => Promise<Tool[]>

type GetToolImpls = never;

interface GetToolImpl {
    run: IGetTool;
    name: GetToolImpls;
}

interface GetToolFunction {
  registerImpl: (name: GetToolImpls, impl: GetToolImpl) => void;
  getImpl: (name: GetToolImpls) => GetToolImpl;
}

function createGetToolInstance(): IGetTool & GetToolFunction {

  const registry: Record<GetToolImpls, GetToolImpl> = {}

  const wrapper: GetToolFunction = {
    getImpl: (name: GetToolImpls) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for GetTool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: GetToolImpls, impl: GetToolImpl) => {
      if (registry[name]) {
        throw new Error(`Implementation for GetTool with name ${name} already exists`);
      }
      registry[name] = impl;
    },
    validate: () => {
    }
  };

  const impl = async (params : {
    context: string, query: string
  }) => {
    throw new Error('No implementation for GetTool');
  };

  Object.assign(impl, wrapper);

  return impl as  IGetTool & GetToolFunction;
}

const GetTool = createGetToolInstance();


export { ClassifyDocumentTopic, IClassifyDocumentTopic, ClassifyDocumentTopicFunction, ClassifyIntent, IClassifyIntent, ClassifyIntentFunction, ExtractInvoice, IExtractInvoice, ExtractInvoiceFunction, ExtractMeetingRequestInfo, IExtractMeetingRequestInfo, ExtractMeetingRequestInfoFunction, ExtractMeetingRequestInfoPartial, IExtractMeetingRequestInfoPartial, ExtractMeetingRequestInfoPartialFunction, ExtractObject, IExtractObject, ExtractObjectFunction, GenerateOutreachEmail, IGenerateOutreachEmail, GenerateOutreachEmailFunction, GetDetailsKyle, IGetDetailsKyle, GetDetailsKyleFunction, GetNextQuestion, IGetNextQuestion, GetNextQuestionFunction, GetTool, IGetTool, GetToolFunction }